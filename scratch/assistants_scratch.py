from openai import OpenAI
import openai
import os
import time
import logging

# Set up your OpenAI API key
openai.api_key = os.environ['OPENAI_API_KEY']

client = OpenAI()

# def create_assistant():
#     response = client.beta.assistants.create(
#         model="gpt-4", # Choose the model appropriate for your task
#         name="Classroom Assistant",
#         description="Helps students understand their assignments and class materials.",
#         instructions="Provide hints and explanations to help students solve their assignments without giving away direct answers."
#     )
#     return response


# def start_thread(assistant_id, question):
#     thread = openai.Thread.create(
#         assistant_id=assistant_id,
#         messages=[
#             {
#                 "role": "user",
#                 "content": question
#             }
#         ]
#     )
#     return thread

# def ask_question(thread_id, question):
#     response = openai.Message.create(
#         thread_id=thread_id,
#         role="user",
#         content=question
#     )
#     return response

# # Example usage
# assistant = create_assistant()
# thread = start_thread(assistant['id'], "How do I approach solving a quadratic equation?")
# response = ask_question(thread['id'], "Can you give me a hint?")
# print(response['content'])

# Check moderation for violation - content being processed or generated by assistant violates OpenAI's content policy or not
def check_moderation(input_content):
    try:
        moderation = client.moderations.create(input=input_content)
        # Check if the content is flagged, print violation
        if any(result['flagged'] for result in moderation.results):
            print("Content violates policies, halting process.")
            return None
        return moderation
    except Exception as e:
        print(f"An error occurred in moderation: {e}")


# Assistant and assistant file

# Create assistant
def create_assistant(name, description, model, instructions):
    try:
        assistant = client.beta.assistants.create(
            model=model,
            name=name,
            description=description,
            instructions=instructions,
        )
        return assistant
    except Exception as e:
        print(f"An error occurred in creating assistant: {e}")


# Create an assistant file by attaching a File to an assistant.
def create_assistant_file(assistant_id, file_id):
    try:
        # Assistant file object - for managing and using assistant file within OpenAI framework, keep track of and control the behavior of assistant file
        assistant_file = client.beta.assistants.files.create(
            assistant_id=assistant_id,
            file_id=file_id
        )
        return assistant_file
    except Exception as e:
        print(f"Error in creating assistant file: {e}")

# Returns a list of assistants
def list_assistants():
    try:
        assistants = client.beta.assistants.list()
        return assistants
    except Exception as e:
        print(f"An error occurred: {e}")

# Returns a list of assistant files
def list_assistant_files(assistant_id):
    try:
        files = client.beta.assistants.files.list(assistant_id=assistant_id)
        return files
    except Exception as e:
        print(f"Error listing assistant files: {e}")

# Retrieve assistant - for checking specific assistant
def retrieve_assistant(assistant_id):
    try:
        assistant_details = client.beta.assistants.retrieve(assistant_id=assistant_id)
        return assistant_details
    except Exception as e:
        print(f"An error occurred: {e}")

# Retrieve assistant file - for checking specific file
def retrieve_assistant_file(assistant_id, file_id):
    try:
        assistant_file = client.beta.assistants.files.retrieve(assistant_id=assistant_id, file_id=file_id)
        return assistant_file
    except Exception as e:
        print(f"An error occurred: {e}")

# Modifiy assistant
def modify_assistant(assistant_id, new_name, new_description, new_instructions, new_model, new_tools, new_file_ids):
    try:
        updated_assistant = client.beta.assistants.update(
            assistant_id=assistant_id,
            name=new_name,
            description=new_description,
            instructions=new_instructions,
            model=new_model,
            tools=new_tools,
            file_ids=new_file_ids
        )
        return updated_assistant
    except Exception as e:
        print(f"An error occurred: {e}")

# Delete assistant
def delete_assistant(assistant_id):
    try:
        deletion_status = client.beta.assistants.delete(assistant_id=assistant_id)
        return deletion_status
    except Exception as e:
        print(f"An error occurred: {e}")

# delete assistant file
def delete_assistant_file(assistant_id, file_id):
    try:
        deletion_status = client.beta.assistants.files.delete(assistant_id=assistant_id, file_id=file_id)
        return deletion_status
    except Exception as e:
        print(f"An error occurred: {e}")





# Thread

# Thread object
'''
{
  "id": "thread_abc123",
  "object": "thread",
  "created_at": 1699012949,
  "metadata": {}
}
'''
# Metadata - custom, additional data

# Create thread
def create_thread(messages):
    try:
        thread = client.beta.threads.create(messages=messages)
        return thread # Empty at first
    except Exception as e:
        print(f"Error in creating thread: {e}")

# Retrieve thread
def retrieve_thread(thread_id):
    try:
        thread = client.beta.threads.retrieve(thread_id)
        return thread
    except Exception as e:
        print(f"Error in retrieving thread: {e}")

# Modify thread
def modify_thread(thread_id, metadata):
    try:
        updated_thread = client.beta.threads.update(thread_id, metadata=metadata)
        return updated_thread
    except Exception as e:
        print(f"Error in modifying thread: {e}")

# Delete thread
def delete_thread(thread_id):
    try:
        response = client.beta.threads.delete(thread_id)
        return response
    except Exception as e:
        print(f"Error in deleting thread: {e}")



# Message

# Message object
'''
{
  "id": "msg_abc123",
  "object": "thread.message",
  "created_at": 1698983503,
  "thread_id": "thread_abc123",
  "role": "assistant",
  "content": [
    {
      "type": "text",
      "text": {
        "value": "Hi! How can I help you today?",
        "annotations": []
      }
    }
  ],
  "file_ids": [],
  "assistant_id": "asst_abc123",
  "run_id": "run_abc123",
  "metadata": {}
}
'''
# Message file object
'''
{
  "id": "file-abc123",
  "object": "thread.message.file",
  "created_at": 1698107661,
  "message_id": "message_QLoItBbqwyAJEzlTy4y9kOMM",
  "file_id": "file-abc123"
}

'''
# Create message
def create_message(thread_id, role, content):
    try:
        message = client.beta.threads.messages.create(
            thread_id=thread_id,
            role=role, # Entity that produced the message - user or assistant
            content=content # Text or image
        )
        return message
    except Exception as e:
        print(f"Error creating message: {e}")

# Return a list of messages for a given thread
def list_messages(thread_id):
    try:
        thread_messages = client.beta.threads.messages.list(thread_id)
        return thread_messages
    except Exception as e:
        print(f"Error listing messages: {e}")

# Return a list of message files
def list_message_files(thread_id, message_id):
    try:
        files = client.beta.threads.messages.files.list(thread_id, message_id)
        return files
    except Exception as e:
        print(f"Error listing message files: {e}")

# Retrieve a message
def retrieve_message(thread_id, message_id):
    try:
        message = client.beta.threads.messages.retrieve(thread_id, message_id)
        return message
    except Exception as e:
        print(f"Error retrieving message: {e}")

# Retrieve a message file
def retrieve_message_file(thread_id, message_id, file_id):
    try:
        file = client.beta.threads.messages.files.retrieve(thread_id, message_id, file_id)
        return file
    except Exception as e:
        print(f"Error retrieving message file: {e}")

# Modify a message
def modify_message(thread_id, message_id, new_content):
    try:
        updated_message = client.beta.threads.messages.update(
            thread_id=thread_id,
            message_id=message_id,
            content=new_content
        )
        return updated_message
    except Exception as e:
        print(f"Error modifying message: {e}")


# Runs - Represents an execution run on a thread

# Run object
'''
{
  "id": "run_abc123",
  "object": "thread.run",
  "created_at": 1698107661,
  "assistant_id": "asst_abc123",
  "thread_id": "thread_abc123",
  "status": "completed",
  "started_at": 1699073476,
  "expires_at": null,
  "cancelled_at": null,
  "failed_at": null,
  "completed_at": 1699073498,
  "last_error": null,
  "model": "gpt-4",
  "instructions": null,
  "tools": [{"type": "retrieval"}, {"type": "code_interpreter"}],
  "file_ids": [],
  "metadata": {},
  "usage": {
    "prompt_tokens": 123,
    "completion_tokens": 456,
    "total_tokens": 579
  }
}
'''

# Run step object
'''
{
  "id": "step_abc123",
  "object": "thread.run.step",
  "created_at": 1699063291,
  "run_id": "run_abc123",
  "assistant_id": "asst_abc123",
  "thread_id": "thread_abc123",
  "type": "message_creation",
  "status": "completed",
  "cancelled_at": null,
  "completed_at": 1699063291,
  "expired_at": null,
  "failed_at": null,
  "last_error": null,
  "step_details": {
    "type": "message_creation",
    "message_creation": {
      "message_id": "msg_abc123"
    }
  },
  "usage": {
    "prompt_tokens": 123,
    "completion_tokens": 456,
    "total_tokens": 579
  }
}
'''

# Create run
def create_run(thread_id, assistant_id):
    try:
        run = client.beta.threads.runs.create(
            thread_id=thread_id,
            assistant_id=assistant_id
        )
        return run
    except Exception as e:
        print(f"An error occurred: {e}")

# Create thread and run - create a thread and run it in one request
def create_thread_and_run(assistant_id, messages):
    try:
        run = client.beta.threads.create_and_run(
            assistant_id=assistant_id,
            thread={"messages": messages}
        )
        return run
    except Exception as e:
        print(f"An error occurred: {e}")

# Return a list of runs belonging to a thread
def list_runs(thread_id):
    try:
        runs = client.beta.threads.runs.list(
            thread_id=thread_id
        )
        return runs
    except Exception as e:
        print(f"An error occurred: {e}")

# Returns a list of run steps belonging to a run
def list_run_steps(thread_id, run_id):
    try:
        run_steps = client.beta.threads.runs.steps.list(
            thread_id=thread_id,
            run_id=run_id
        )
        return run_steps
    except Exception as e:
        print(f"An error occurred: {e}")

# Retrieves a run
def retrieve_run(thread_id, run_id):
    try:
        run = client.beta.threads.runs.retrieve(
            thread_id=thread_id,
            run_id=run_id
        )
        return run
    except Exception as e:
        print(f"An error occurred: {e}")

# Retrieves a run step
def retrieve_run_steps(thread_id, run_id, step_id):
    try:
        run_step = client.beta.threads.runs.steps.retrieve(
            thread_id=thread_id,
            run_id=run_id,
            step_id=step_id
        )
        return run_step
    except Exception as e:
        print(f"An error occurred: {e}")

# Modifies a run
def modify_run(thread_id, run_id, metadata):
    try:
        # Modify a run with new metadata
        run = client.beta.threads.runs.update(
            thread_id=thread_id,
            run_id=run_id,
            metadata=metadata
        )
        return run
    except Exception as e:
        print(f"An error occurred: {e}")

# Submit tool outputs to run - Do we need tool?
        
# Cancel a run
def cancel_run(thread_id, run_id):
    try:
        run = client.beta.threads.runs.cancel(
            thread_id=thread_id,
            run_id=run_id
        )
        return run
    except Exception as e:
        print(f"An error occurred: {e}")


def delete_all_assistants():
    try:
        assistants = list_assistants()
        for assistant in assistants['data']:
            delete_assistant(assistant['id'])
        print("All assistants have been deleted.")
    except Exception as e:
        print(f"An error occurred while deleting all assistants: {e}")

def delete_all_assistant_files(assistant_id):
    try:
        files = list_message_files(assistant_id)
        for file in files['data']:
            delete_assistant_file(assistant_id, file['id'])
        print("All files for the assistant have been deleted.")
    except Exception as e:
        print(f"An error occurred while deleting all files: {e}")

def display_assistant_details(assistant_id):
    assistant_details = retrieve_assistant(assistant_id)
    if assistant_details:
        print(f"Assistant ID: {assistant_id}")
        print(f"Name: {assistant_details.get('name')}")
        print(f"Description: {assistant_details.get('description')}")
        print(f"Model: {assistant_details.get('model')}")
        print("Files:")
        files = list_assistant_files(assistant_id)
        if files and files.get('data'):
            for file in files['data']:
                print(f"- File ID: {file['id']}, Name: {file.get('name')}")
        else:
            print("No files associated with this assistant.")
    else:
        print("Assistant not found.")

def main_options():
    print("\nMain Options:")
    print("1. Assistant")
    print("2. Assistant File")
    print("3. Use Assistant to get help")
    print("4. Exit")
    choice = input("Enter your choice (1-4): ")
    return choice

def assistant_options():
    while True:
        print("\nAssistant Options:")
        print("1. Create Assistant")
        print("2. Retrieve Assistant")
        print("3. List Assistants")
        print("4. Modify Assistant")
        print("5. Delete Assistant")
        print("6. Back to Main Menu")
        choice = input("Enter your choice (1-6): ")

        if choice == "1":
            name = input("\nEnter the name of the assistant: ")
            description = input("Enter a description for the assistant: ")
            model = input("Enter the model for the assistant (Use gpt-4): ")
            instructions = input("Enter instructions for the assistant: ")
            assistant = create_assistant(name, description, model, instructions)
            print(f"Assistant created: {assistant}")

        elif choice == "2":
            assistant_id = input("Enter the assistant ID: ")
            assistant = retrieve_assistant(assistant_id)
            print(f"Assistant details: {assistant}")

        elif choice == "3":
            # Add how many assistants there are?
            assistants = list_assistants()
            print("List of assistants:", assistants)

        elif choice == "4":
            assistant_id = input("Enter the assistant ID to modify: ")
            new_name = input("Enter the new name for the assistant (leave blank to keep current): ")
            new_description = input("Enter the new description for the assistant (leave blank to keep current): ")
            new_instructions = input("Enter new instructions for the assistant (leave blank to keep current): ")
            new_model = input("Enter the new model for the assistant (use gpt-4, leave blank to keep current): ")
            # tools, or file_ids?
            assistant = modify_assistant(assistant_id, new_name, new_description, new_instructions, new_model, [], [])
            print("Assistant modified:", assistant)

        elif choice == "5":
            assistant_id = input("Enter the assistant ID to delete: ")
            delete_assistant(assistant_id)
            print("Assistant deleted.")

        elif choice == "6":
            break

        else:
            print("Invalid choice. Please enter a number between 1 and 6.")

def assistant_file_options():
    while True:
        print("\nAssistant File Options:")
        print("1. Create Assistant File")
        print("2. Retrieve Assistant File")
        print("3. Delete Assistant File")
        print("4. Back to Main Menu")
        choice = input("Enter your choice (1-4): ")

        if choice == "1":
            assistant_id = input("Enter the assistant ID: ")
            file_id = input("Enter the file ID to add: ")
            assistant_file = create_assistant_file(assistant_id, file_id)
            print(f"Assistant file added: {assistant_file}")

        elif choice == "2":
            assistant_id = input("Enter the assistant ID: ")
            file_id = input("Enter the file ID to retrieve: ")
            assistant_file = retrieve_assistant_file(assistant_id, file_id)
            print("Assistant file details:", assistant_file)

        elif choice == "3":
            assistant_id = input("Enter the assistant ID: ")
            file_id = input("Enter the file ID to delete: ")
            delete_assistant_file(assistant_id, file_id)
            print("Assistant file deleted.")

        elif choice == "4":
            break

        else:
            print("Invalid choice. Please enter a number between 1 and 4.")

# Help users with the chosen assistant
def use_assistant_for_help(assistant_id):
    print("\nAssistant started to help! Type 'exit' to end.")

    # Start new conversation
    initial_message_content = input("You: ")
    if initial_message_content.lower() == 'exit':
        return

    # Create a new thread using the first message above
    try:
        # I think i can make this process easier
        thread_response = create_thread_and_run(assistant_id, [{"role": "user", "content": initial_message_content}])
        thread_id = thread_response.thread_id
        print(f"Thread created with ID: {thread_id}")

        time.sleep(2)  # Time for assistant to respond

        # Retrieve the initial response from the assistant
        messages_response = list_messages(thread_id)
        if messages_response and messages_response['data']:
            # Assuming the latest message is the assistant's response
            latest_message = messages_response['data'][-1]
            print(f"Assistant: {latest_message['content']['text']['value']}")
        else:
            print("No response from the assistant.")

        while True:
            user_input = input("You: ")
            if user_input.lower() == 'exit':
                break

            # Send the user input as a new message in the thread
            create_message(thread_id, "user", {"type": "text", "text": {"value": user_input}})

            time.sleep(2)

            messages_response = list_messages(thread_id)
            if messages_response and messages_response['data']:
                latest_message = messages_response['data'][-1]
                print(f"Assistant: {latest_message['content']['text']['value']}")
            else:
                print("No response from the assistant.")
    except Exception as e:
        print(f"An error occurred: {e}")

# Select assistant - get assistant ids from list_assistants() and make the user to choose the assistant to get help with
def select_assistant():
    try:
        assistants_response = list_assistants()
        # print(assistants_response)
        assistants = []

        if assistants_response is not None and assistants_response.data:
            assistants = assistants_response.data
        
        if not assistants:
            print("No assistants available.")
            return None
        
        print("\nAvailable Assistants:")
        # print(assistants)
        for i, assistant in enumerate(assistants, start=1):
            print(f"{i}. {assistant.name} (ID: {assistant.id})")
        
        # Select assistant
        while True:
            try:
                selection = int(input("Select an assistant by number: ")) - 1
                if 0 <= selection < len(assistants):
                    selected_assistant = assistants[selection]
                    return selected_assistant.id
                else:
                    print("Invalid selection. Please select a number listed above.")
            except ValueError:
                print("Please enter a valid number.")
                return None
    except Exception as e:
        print(f"An error occurred while selecting the assistant: {e}")
        return None

# Select assistant and get help with that assistant
def use_assistant_for_help_with_selection():
    assistant_id = select_assistant()
    if assistant_id:
        use_assistant_for_help(assistant_id)
    else:
        print("Assistant selection failed.")

def main():
    while True:
        choice = main_options()
        if choice == "1":
            assistant_options()
        elif choice == "2":
            assistant_file_options()
        elif choice == "3":
            use_assistant_for_help_with_selection()
        elif choice == "4":
            print("Exiting")
            break
        else:
            print("Invalid choice. Please enter a number between 1 and 4.")

if __name__ == "__main__":
    main()
