import asyncio
import io
import json
import os
import tarfile
import tempfile
import uuid
from textwrap import dedent

import docker


class PythonExecContainer():
    def __init__(self, image: str) -> None:
        self.image: str = image
        self.client = docker.from_env()
        self.container = None
        self.out_dir = tempfile.mkdtemp(prefix="sandbox_out_")

    def __enter__(self):
        # Start Docker container
        # duck_logger.info(f"Starting container from image: {self.image}")
        self.container = self.client.containers.run(
            self.image,
            command="sleep infinity",
            detach=True,
            tmpfs={"/out": "rw,size=100m"}
        )
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Stop and remove container
        if self.container:
            self.container.stop()
            self.container.remove()

    def _mkdir(self, path: str) -> str:
        """
        Makes a directory in the tmpfs /out directory
        """
        path = f"/out/{path}"
        self.container.exec_run(["mkdir", "-p", path])
        return path

    def _write_files(self, files: dict[str, bytes], container_dir: str):
        """
        Writes a dict of {relative_path: bytes} to the container directory

        Example:
            files = {
                "input.txt": b"...",
                "subdir/data.json": b"..."
            }

        container_dir should be a full container path, e.g. "/out/<uuid>"
        """
        # iterates over each file to copy into the container
        for rel_path, data in files.items():
            dest_path = os.path.join(container_dir, rel_path) # full path to file

            # make sure the directory exists in the container
            parent_dir = os.path.dirname(dest_path)
            self.container.exec_run(["mkdir", "-p", parent_dir])

            # Create a tar archive containing just this file
            tarstream = io.BytesIO()
            with tarfile.open(fileobj=tarstream, mode="w") as tar:
                info = tarfile.TarInfo(name=os.path.basename(dest_path))
                info.size = len(data)
                tar.addfile(info, io.BytesIO(data))

            tarstream.seek(0)

            # Send archive into the correct directory
            self.container.put_archive(parent_dir, tarstream.getvalue())

    def _gen_img_description(self, file_path):
        # This assumes you can access the figure metadata before saving
        # In practice, have user code save plot title/labels as JSON or .txt next to image
        # For now, we fall back to generic description
        return f"Image file: {os.path.basename(file_path)}"

    def _read_files(self, path: str):
        """
        Reads all files inside a directory given by path, e.g. "/out/<uuid>"
        Returns:
            {
                "path/filename": {
                    "data": bytes,
                    "description": str
                }
            }
        """
        out_files = {}

        # retrieve dir and load into tarfile
        stream, _ = self.container.get_archive(path)
        tar_bytes = b"".join(stream)
        tarstream = io.BytesIO(tar_bytes)

        with tarfile.open(fileobj=tarstream, mode="r:*") as tar:
            members = tar.getmembers()

            # parse json
            meta_data = {}
            for m in members:
                if m.isfile() and m.name.lower().endswith(".json"):
                    f = tar.extractfile(m)
                    if f:
                        try:
                            meta_data[m.name] = json.loads(f.read().decode("utf-8"))
                        except Exception:
                            pass

            # process regular files
            for m in members:
                if not m.isfile():
                    continue
                if m.name.lower().endswith(".json"):
                    continue

                f = tar.extractfile(m)
                if f:
                    data = f.read()
                else:
                    data = None

                filename = m.name  # includes relative path within tar

                # Determine description
                base, _ = os.path.splitext(filename)
                meta = meta_data.get(base + ".json")

                if meta:
                    description = (
                        f"{meta.get('plot_type', 'unknown')} plot titled "
                        f"'{meta.get('title', '')}', xlabel='{meta.get('xlabel', '')}', "
                        f"ylabel='{meta.get('ylabel', '')}'"
                    )
                else:
                    if filename.endswith("stdout.txt"):
                        description = "Python stdout and stderr output"
                    else:
                        description = f"File generated by user code: {os.path.basename(filename)}"

                out_files[filename] = {
                    "description": description,
                    "data": data
                }

        return out_files

    def _wrap_and_execute(self, code: str, path: str):
        wrapped_code = dedent(f"""\
            import sys
            import traceback
            import os
            import json
            
            # === Redirect stdout/stderr ===
            sys.stdout = open('{path}/stdout.txt', 'w')
            sys.stderr = sys.stdout
            
            # === Patch matplotlib to auto-save metadata ===
            try:
                import matplotlib.pyplot as plt
                import matplotlib.figure
            
                _original_savefig = plt.Figure.savefig
            
                def savefig_with_metadata(self, *args, **kwargs):
                    # Determine file path
                    path = args[0] if args else kwargs.get('fname', 'figure.png')
                    # Call original savefig
                    _original_savefig(self, *args, **kwargs)
            
                    # Extract metadata if axes exist
                    if self.axes:
                        ax = self.axes[0]
                        metadata = {{
                            "title": ax.get_title(),
                            "xlabel": ax.get_xlabel(),
                            "ylabel": ax.get_ylabel(),
                            "plot_type": "line" if ax.lines else "unknown"
                        }}
                    else:
                        metadata = {{"title": "", "xlabel": "", "ylabel": "", "plot_type": "unknown"}}
            
                    # Save metadata next to image
                    meta_path = os.path.splitext(path)[0] + ".json"
                    with open(meta_path, 'w') as f:
                        json.dump(metadata, f)
            
                plt.Figure.savefig = savefig_with_metadata
            except ImportError:
                # matplotlib not installed; ignore
                pass
            
            # === Execute user code safely ===
            try:
                exec({code!r})
            except Exception:
                traceback.print_exc(file=sys.stdout)
            finally:
                sys.stdout.flush()
            """)
        return self.container.exec_run(["python3", "-u", "-c", wrapped_code])

    def _run_code(self, code: str, files: dict = None): # returns json object containing all the output files and their data
        id = str(uuid.uuid4())
        dir_path = self._mkdir(id)
        if files:
            self._write_files(files, dir_path)
        self._wrap_and_execute(code, dir_path)
        # TODO: remove unique input and output dirs in _read_files
        return self._read_files(dir_path)

    async def run_code(self, code: str, files: dict = None):
        return await asyncio.to_thread(self._run_code, code, files)


async def run_code_test():
    with PythonExecContainer("byucscourseops/python-tools-sandbox:latest") as container:
        code = dedent("""\
            import time
            import matplotlib.pyplot as plt
            print("start", time.time())
            
            plt.plot([1, 2, 3, 4], [10, 20, 25, 30])
            plt.title('Example Plot')
            plt.savefig('plot.png')
            time.sleep(1)
            print("end", time.time())
            """)

        task1 = asyncio.create_task(container.run_code(code))
        task2 = asyncio.create_task(container.run_code(code))
        results = await asyncio.gather(task1, task2)
        return results


if __name__ == "__main__":
    print(asyncio.run(run_code_test()))
    # concurrent_test()
