import asyncio
import io
import json
import os
import tarfile
import tempfile
import uuid
from textwrap import dedent

import docker


class PythonExecContainer():
    def __init__(self, image: str) -> None:
        self.image: str = image
        self.client = docker.from_env()
        self.container = None
        self.out_dir = tempfile.mkdtemp(prefix="sandbox_out_")

    def __enter__(self):
        # Start Docker container
        # duck_logger.info(f"Starting container from image: {self.image}")
        self.container = self.client.containers.run(
            self.image,
            command="sleep infinity",
            detach=True,
            volumes={ # TODO: tmpfs - docker hosts/exists in ram, doesn't give access to local files
                self.out_dir: {"bind": "/out", "mode": "rw"}
            }
        )
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        # Stop and remove container
        if self.container:
            self.container.stop()
            self.container.remove()

    def _mkdir(self, path): # TODO: if not automatically created, put in __enter__
        self.container.exec_run(["mkdir", "-p", path])

    def _write_files(self, files: dict[str, bytes], path: str):
        for path, data in files.items():
            tarstream = io.BytesIO()
            tar = tarfile.TarFile(fileobj=tarstream, mode='w')

            info = tarfile.TarInfo(name=os.path.basename(path))
            info.size = len(data)
            tar.addfile(info, io.BytesIO(data))
            tar.close()
            tarstream.seek(0)

            container_dir = os.path.dirname(path)
            self.container.put_archive(container_dir, tarstream.getvalue())

    def _gen_img_description(self, file_path):
        # This assumes you can access the figure metadata before saving
        # In practice, have user code save plot title/labels as JSON or .txt next to image
        # For now, we fall back to generic description
        return f"Image file: {os.path.basename(file_path)}"

    def _read_files(self): # TODO: use get_archive isntead of os
        """
        Reads all files in the container-mounted /out directory.
        Returns a dict where each key is the filename and value is:
            {
                "data": bytes or None (for large files if you choose to skip),
                "description": str
            }
        - For matplotlib plots, it uses the auto-generated JSON metadata.
        - For stdout.txt, includes text.
        - For other files, provides a generic description.
        """
        out_files = {}

        for root, _, files in os.walk(self.out_dir): # try get_archive out to get all files or get specific files
            for file in files:
                full_path = os.path.join(root, file)
                rel_path = os.path.relpath(full_path, self.out_dir)

                # Handle matplotlib metadata files
                if file.lower().endswith(".json"):
                    # Already used for describing corresponding plot; skip storing JSON itself
                    continue

                # Check if a metadata JSON exists for this file
                base_name, ext = os.path.splitext(file)
                meta_path = os.path.join(root, f"{base_name}.json")
                description = ""

                if os.path.exists(meta_path):
                    try:
                        with open(meta_path, "r") as f:
                            meta = json.load(f)
                        description = f"{meta.get('plot_type', 'Unknown')} plot titled '{meta.get('title', '')}', xlabel='{meta.get('xlabel', '')}', ylabel='{meta.get('ylabel', '')}'"
                    except Exception:
                        description = "Plot file (metadata unreadable)"
                else:
                    # Non-plot files
                    if file == "stdout.txt":
                        description = "Python stdout and stderr output"
                    else:
                        description = f"File generated by user code: {file}"

                # Read the file data (optional: skip large binaries if you want)
                try:
                    with open(full_path, "rb") as f:
                        data = f.read()
                except Exception:
                    data = None

                out_files[rel_path] = {
                    "description": description,
                    "data": data
                }

        return out_files

    def _wrap_and_execute(self, code: str):
        wrapped_code = dedent(f"""\
            import sys
            import traceback
            import os
            import json
            
            # === Redirect stdout/stderr ===
            sys.stdout = open('/out/stdout.txt', 'w')
            sys.stderr = sys.stdout
            
            # === Patch matplotlib to auto-save metadata ===
            try:
                import matplotlib.pyplot as plt
                import matplotlib.figure
            
                _original_savefig = plt.Figure.savefig
            
                def savefig_with_metadata(self, *args, **kwargs):
                    # Determine file path
                    path = args[0] if args else kwargs.get('fname', 'figure.png')
                    # Call original savefig
                    _original_savefig(self, *args, **kwargs)
            
                    # Extract metadata if axes exist
                    if self.axes:
                        ax = self.axes[0]
                        metadata = {{
                            "title": ax.get_title(),
                            "xlabel": ax.get_xlabel(),
                            "ylabel": ax.get_ylabel(),
                            "plot_type": "line" if ax.lines else "unknown"
                        }}
                    else:
                        metadata = {{"title": "", "xlabel": "", "ylabel": "", "plot_type": "unknown"}}
            
                    # Save metadata next to image
                    meta_path = os.path.splitext(path)[0] + ".json"
                    with open(meta_path, 'w') as f:
                        json.dump(metadata, f)
            
                plt.Figure.savefig = savefig_with_metadata
            except ImportError:
                # matplotlib not installed; ignore
                pass
            
            # === Execute user code safely ===
            try:
                exec({code!r})
            except Exception:
                traceback.print_exc(file=sys.stdout)
            finally:
                sys.stdout.flush()
            """)
        return self.container.exec_run(["python3", "-u", "-c", wrapped_code])

    def _run_code(self, code: str, files: dict = None): # returns json object containing all the output files and their data
        id = str(uuid.uuid4())
        self._mkdir(f"/out/{id}") # TODO: change _write_files to have unique input and output dirs so they don't overlap
        if files:
            self._write_files(files, id)
        self._wrap_and_execute(code)
        # TODO: remove unique input and output dirs
        return self._read_files()

    async def run_code(self, code: str, files: dict = None):
        return await asyncio.to_thread(self._run_code, code, files)


async def run_code_test():
    with PythonExecContainer("byucscourseops/python-tools-sandbox:latest") as container:
        code = dedent("""\
            import time
            import matplotlib.pyplot as plt
            print("start", time.time())
            
            plt.plot([1, 2, 3, 4], [10, 20, 25, 30])
            plt.title('Example Plot')
            plt.savefig('/out/plot.png')
            time.sleep(1)
            print("end", time.time())
            """)

        task1 = asyncio.create_task(container.run_code(code))
        task2 = asyncio.create_task(container.run_code(code))
        results = await asyncio.gather(task1, task2)
        return results


if __name__ == "__main__":
    print(asyncio.run(run_code_test()))
    # concurrent_test()
