import asyncio
from pathlib import Path
import json
import yaml

import markdowndata
from quest import step, queue

from functools import reduce
import operator

from ..gen_ai.gen_ai import Agent, AIClient
from ..utils.config_types import DuckContext, AssignmentFeedbackSettings, Gradable, RubricItemResponse
from ..utils.logger import duck_logger
from ..utils.protocols import Message

ASSIGNMENT_NAME = str
SECTION = str
SECTION_NAME = str
RUBRIC_ITEM = str
REPORT_SECTION = str
FEEDBACK = str
SATISFACTORY = bool


# TODO consider give another chance if they upload no valid reports the wrong report?
# TODO ask: step functions?
# TODO consider error handling without a report

class AssignmentFeedbackWorkflow:
    def __init__(self,
                 name: str,
                 send_message,
                 settings: AssignmentFeedbackSettings,
                 single_rubric_item_grader: Agent,
                 project_scanner_agent: Agent,
                 ai_client: AIClient,
                 read_url
                 ):
        self.name = name
        self._send_message = send_message
        self._settings = settings
        self._single_rubric_item_grader = single_rubric_item_grader
        self._project_scanner_agent = project_scanner_agent
        self._ai_client = ai_client
        self.read_url = read_url

        self._assignments_rubrics: dict[ASSIGNMENT_NAME: dict[SECTION: any]] = {}
        self._populate_assignments_rubrics()

    async def __call__(self, context: DuckContext):
        """
        - Ideally, the same project name provided in the config is the first level 1 header in the document
        - If not, an agent scrubs the report for the name
        Assumptions about rubric and report:
        - Every header in the yaml rubric has a corresponding header in the md report.
            It is assumed the nesting and the names are exactly the same.
            The root yaml headers correspond to level 2 headers in the markdown
        """

        # Send an initial message
        await self._send_message(context.thread_id,
                                 self._settings.get("initial_message", "Content generated by AI may not be correct"))

        # Tell the user the supported assignments
        supported_assignments = ' '.join(self._assignments_rubrics.keys())
        await self._send_message(context.thread_id,
                                 f"The supported assignments for grading are {supported_assignments}")

        # Get the report contents from the user
        report_contents = await self._get_report_contents(context)

        if report_contents is None:
            return

        # Get the project name associated with the report
        valid_project_names = [assignment["name"] for assignment in self._settings['gradable_assignments']]
        project_name = await self._get_project_name_from_report(context, report_contents, valid_project_names)

        # break up the report into very small pieces to grade with the associated rubric item
        tasks = [
            asyncio.create_task(self.single_item_ai_grader(context, piece_name, report_section, rubric_item))
            for piece_name, rubric_item, report_section in
            self._flatten_report_and_rubric_items(report_contents, self._assignments_rubrics[project_name])
        ]

        # wait for the responses of all the items
        graded_items: list[tuple[list[SECTION_NAME], RubricItemResponse]] = await asyncio.gather(*tasks)

        # format for the user to read
        formatted_graded_items = self._format_graded_items(graded_items)

        await self._send_message(context.thread_id, formatted_graded_items)

    def _flatten_report_and_rubric_items(self, report_contents, rubric) -> list[
        tuple[list[SECTION_NAME], RUBRIC_ITEM, REPORT_SECTION]]:
        report = markdowndata.loads(report_contents)
        report_sections = report[list(report.keys())[0]]

        def helper_func(name, rubric_section, report_section):
            for section_name in rubric_section.keys():
                name.append(section_name)
                if isinstance(rubric_section[section_name], dict):
                    yield from helper_func(name, rubric_section[section_name], report_section[section_name])
                elif isinstance(rubric_section[section_name], list):
                    for section_item in rubric_section[section_name]:
                        if isinstance(section_item, dict):
                            helper_func(name, section_item, report_section['contents'])
                        print(name, section_item)
                        yield name[::], section_item, report_section[section_name]
                name.pop(-1)

        flattened = list(helper_func([], rubric, report_sections))
        return flattened

    def _format_single_response(self, response: RubricItemResponse):
        emoji = ':white_check_mark:' if response['satisfactory'] else ':x:'
        justification = response['justification']
        return f'{emoji} **{response["rubric_item"]}** - {justification}'

    def _format_graded_items(self, results: list[tuple[list[SECTION_NAME], RubricItemResponse]]):

        results = [
            (name, self._format_single_response(rubric_item_response))
            for (name, rubric_item_response) in results
        ]

        result = self._unflatten_dictionary(results)
        return self.dict_to_md(result)

    def _get_nested(self, d, keys):
        return reduce(operator.getitem, keys, d)

    def _set_nested(self, d, keys, value):
        *prefix, last = keys
        parent = reduce(lambda acc, k: acc.setdefault(k, {}), prefix, d)
        parent.setdefault(last, []).append(value)

    def _unflatten_dictionary(self, results):
        unflattened = {}
        for keys, formatted in results:
            self._set_nested(unflattened, keys, formatted)
        return unflattened

    def _get_rubric_content(self, assignment: Gradable):
        if 'rubric_path' in assignment:
            instructions = Path(assignment['rubric_path']).read_text(encoding="utf-8")
        else:
            raise ValueError(f"You must provide an 'rubric_path' for {assignment['name']}")
        return instructions

    def _populate_assignments_rubrics(self):
        # TODO add error message for failing to load yaml correctly - try/except
        for assignment in self._settings["gradable_assignments"]:
            raw_rubric_content = self._get_rubric_content(assignment)
            rubric_content = yaml.safe_load(raw_rubric_content)
            self._assignments_rubrics[assignment["name"]] = rubric_content

    def _get_project_name_directly_from_report(self, report_contents, valid_project_names):
        try:
            report_contents = markdowndata.loads(report_contents)
            top_headers = report_contents.keys()
            for header in top_headers:
                if header in valid_project_names:
                    return header
            return None
        except Exception as e:
            return None

    async def _get_project_name_using_agent(self, context, report_contents, valid_project_names):
        input = {
            'report_contents': report_contents,
            'valid_projects_names': valid_project_names
        }

        response = await self._ai_client.run_agent(context, self._project_scanner_agent, str(input))
        response = json.loads(response)  # returns structured output as specified in the config
        project = response["project_name"]

        if project not in valid_project_names:
            raise Exception(f"Invalid project name {project}")

        return project

    async def _get_project_name_from_report(self, context, report_contents: str, valid_project_names: list[str]) -> str:
        if project_name := self._get_project_name_directly_from_report(report_contents, valid_project_names):
            return project_name
        else:
            return await self._get_project_name_using_agent(context, report_contents, valid_project_names)

    async def _get_report_contents(self, context):
        try:
            await self._send_message(context.thread_id, "Please upload your md report.")
            while True:
                response = await self._wait_for_message(context.timeout)
                attachments = response.get("files", [])
                md_attachments = [attachment for attachment in attachments if "md" in attachment["filename"]]

                if not md_attachments:
                    await self._send_message(context.thread_id,
                                             "No md files were uploaded. Please upload your md report: ")
                    continue

                file_contents = "\n".join([await self.read_url(attachment['url']) for attachment in md_attachments])
                return file_contents

        except Exception as e:
            duck_logger.warning(f"Exception: {e}")
            await self._send_message(context.thread_id, "Something went wrong.")

    async def single_item_ai_grader(self, context, piece_name, report_section, rubric_item) -> tuple[
        list[SECTION_NAME], RubricItemResponse]:
        input = {"report_contents": report_section,
                 "rubric_item": rubric_item}
        raw_response = await self._ai_client.run_agent(context, self._single_rubric_item_grader, str(input))
        result = json.loads(raw_response)  # expected response = RubricItemResponse
        return piece_name, result

    # TODO unduplicate function from registration workflow?
    async def _wait_for_message(self, timeout=300) -> Message | None:
        async with queue('messages', None) as messages:
            try:
                message: Message = await asyncio.wait_for(messages.get(), timeout)
                return message
            except asyncio.TimeoutError:  # Close the thread if the conversation has closed
                return None

    def dict_to_md(self, d, level=1):
        """
        Convert a nested dict of the form
        {a: {b: {c: [1]}}}
        into markdown:

        # a
        ## b
        ### c
        - 1
        """
        lines = []

        for key, value in d.items():
            # Header line
            header_prefix = "#" * level
            lines.append(f"{header_prefix} {key}")

            # Nested dict → go one level deeper
            if isinstance(value, dict):
                lines.append(self.dict_to_md(value, level + 1))

            # List → bullet items
            elif isinstance(value, list):
                for item in value:
                    lines.append(f"- {item}")

            # Fallback: non-dict, non-list leaf
            else:
                lines.append(f"- {value}")

        return "\n".join(lines)
