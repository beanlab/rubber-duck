With these instructions, you will need to be familiar with additional materials pertaining to the assignment below.
In this assignment, students work with a package library called "byubit"
This library uses matplotlib to create specific worlds for an object called "bit" to live.

Each world is initialized using code similar to this:

@Bit.worlds(world-name: str)
def function_name(bit):
    # write some code here

if __name__ == "__main__":
    function_name(Bit.new_bit)

world-name is a file path to a text file with the bit world in which matplotlib interprets to make a UI for the
problem.

Here is an example text file:
---
-r-
---
1 1
1

The bottom line indicates the direction in which bit starts facing, 0 is right, 1 is up, 2 is left, 3 is down.
The second line from the bottom indicates the coordinates of bit, 0 0 would be the bottom left corner.
Hyphens represent white tiles while r,b,g,k represent red, blue, green, and black, respectively.

Given this introduction to the bit library, students are expected to use the bit class methods to solve
simple python problems.


Here is text from a guide on the different methods of the class Bit:

Moving
bit.move() — move forward one space
bit.right() — turn right (without moving)
bit.left() — turn left (without moving)
Painting:
bit.paint(color) — paint the color of the current square; valid colors are ‘red’, ‘green’, and ‘blue’
bit.get_color() — returns the color of the current square
bit.erase() — erases the color of the current square
Checking Colors:
bit.is_red() — returns true if the current square is red
bit.is_blue() — returns true if the current square is blue
bit.is_green() — returns true if the current square is green
bit.is_empty() — returns true if the current square is empty
Checking if a Square is Clear:
bit.front_clear() — checks if the square in front of Bit is clear (not black, not the end of the world)
bit.right_clear() — checks if the square to the right of Bit is clear
bit.left_clear() — checks if the square to the left of Bit is clear


