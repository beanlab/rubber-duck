Here are the instructions for the given homework assignment:


# Homework 6b - Grids

## 1. Grid Game

**Grid game** is the new, exciting, best-selling, award-winning game that
follows the adventures of our protagonist, represented by `@`, as it tries to
reach the treasure, represented by `!`.

At each step of the game, the player is presented with the current view of the
map. For example:

```
@ . . . . .
* * . * * .
* * . * . .
! . . . . *
```

Then the player enters `u` (up), `d` (down), `l` (left) or `r` (right) to move
the `@` within the map.

The `@` is not allowed to move out of bounds. Nor is the `@` allowed to move
onto spaced marked by `*`.

The core game-play engine of `grid_game.py` has already been written; only a few
pieces remain:

### Read the grid

Implement the `read_grid` function:

```python
def read_grid(filename):
    """
    Read the file as a grid

    Each line becomes a row.
    Spaces delineate each value within a row.
    """
```

### Print the grid

Implement the `print_grid` function:

```python
def print_grid(grid):
    """
    Print the grid with spaces between each value and newlines between each row
    """
```

### Update the grid

Implement the `update_grid` function:

```python
def update_grid(grid, old_row, old_col, new_row, new_col, empty=None):
    """
    Move the value at old_row, old_col to new_row, new_col

    Fill with cell at old_row, old_col with the empty value
    """
```

### Check if blocked

Implement the `is_blocked` function:

```python
def is_blocked(grid, row, col, blocked_value):
    """
    Return True if the value at row, col in the grid is the blocked_value

    Also return True if the row, col coordinate is out of bounds.
    """
```

With these four functions implemented correctly, `grid_game.py` will be ready
for prime time!

## Tests

Be sure you can pass the tests before you turn in the assignment. Review the
[guide on using pytest](/guide/unit3/using-pytest) if you need to review using
pytest and what to do if a test fails.

While the provided tests will tell you whether the program is working correctly
or not, they may not be as helpful for debugging your program.

You should try playing `grid_game.py` on your own to verify that the pieces work
correctly.

Here is an example play-through:

```
python grid_game.py small.txt
@ . * . .
. . . . *
. * * ! .
Action: l
@ . * . .
. . . . *
. * * ! .
Action: u
@ . * . .
. . . . *
. * * ! .
Action: d
. . * . .
@ . . . *
. * * ! .
Action: r
. . * . .
. @ . . *
. * * ! .
Action: r
. . * . .
. . @ . *
. * * ! .
Action: u
. . * . .
. . @ . *
. * * ! .
Action: d
. . * . .
. . @ . *
. * * ! .
Action: r
. . * . .
. . . @ *
. * * ! .
Action: r
. . * . .
. . . @ *
. * * ! .
Action: d
. . * . .
. . . . *
. * * @ .
You win!
```

Notice how the player tested invalid moves (like trying to move off the edge of
the grid or onto a `*`).

You are welcome to use `small.txt` and `world.txt` to test your code. You can
also make your own grid files to play with.

## Grading

| Activity  | Points |
| --------- | ------ |
| Grid game | 20     |

Manual grading will focus on fluency. 

## Even More Fun

If you are looking for an additional challenge, after you finish `grid_game.py`,
make a copy and try some of the following:

- Add other kinds of symbols to the map:
  - pits that take you back to the start
  - warps that take you to a corresponding symbol
  - items that must be retrieved _before_ you can finish the game
  - items that move (in a random direction) after each player move
- Make it a two-player game
  - provide a symbol for each player
  - prompt each player in turn for their move
  - decide what happens when players collide (or do you even allow collisions?)
  - figure out how to keep track of player positions, even when multiple players
    occupy the same space
- Make it a multi-player game
  - at the beginning, enter a sequence of player symbols
  - then prompt each player in turn for their move

Have fun!

You might consider doing some of these for free coding next week.

