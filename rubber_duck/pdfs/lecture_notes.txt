Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
CS 110 Guide
This guide contains all of the material we teach in the class. You will find both videos and tutorials, so that you can choose whichever version helps you learn the best.
How to use this guide
This guide matches the units in the class, so that you can go through the material in order. You will find numerous sections that explain a problem and then ask you to work on it with a friend:
That’s because working with a friend is the best way to learn how to program!
Your natural inclination may be that you are only “really” learning the material if you learn it entirely on your own. In reality, you will learn better if you have someone to share ideas with. Sometimes you will explain something you understand to your friend, and sometimes they will explain it to you.
Do whatever you can to find a friend to learn with.
Learning to work with others is a key part of programming. No significant piece of software can be built by just one person. If you are employed to create software in the future, you will be on a team. This means it will be crucial to learn to work with others, especially those who think differently from you. You will need to learn to communicate effectively, in both spoken and written words.
If you can practice programming with a friend now, your education and your career will both be better for it.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
CS 110 Guide
This guide contains all of the material we teach in the class. You will find both videos and tutorials, so that you can choose whichever version helps you learn the best.
How to use this guide
This guide matches the units in the class, so that you can go through the material in order. You will find numerous sections that explain a problem and then ask you to work on it with a friend:
That’s because working with a friend is the best way to learn how to program!
Your natural inclination may be that you are only “really” learning the material if you learn it entirely on your own. In reality, you will learn better if you have someone to share ideas with. Sometimes you will explain something you understand to your friend, and sometimes they will explain it to you.
Do whatever you can to find a friend to learn with.
Learning to work with others is a key part of programming. No significant piece of software can be built by just one person. If you are employed to create software in the future, you will be on a team. This means it will be crucial to learn to work with others, especially those who think differently from you. You will need to learn to communicate effectively, in both spoken and written words.
If you can practice programming with a friend now, your education and your career will both be better for it.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Introduction to Bit
Video Transcript
For the first part of the course we will be using Bit, a character that you will move around a world. Bit is depicted as a triangle:
and his world is a grid of squares:
Think of Bit as a robot that you control by writing and running code.
Basic things Bit can do
Some of the things Bit can do are:
move — one square at a time
turn_left — turn left
turn_right — turn right
paint — change the color of a square
To illustrate how Bit works, here is a short Bit program:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5, 3)
def move_around(bit):
    bit.move()
    bit.move()
    bit.paint("red")

    bit.turn_left()
    bit.move()
    bit.paint("green")

    bit.turn_right()
    bit.move()
    bit.paint("blue")


if __name__ == '__main__':
    move_around(Bit.new_bit)
We will explain all this code shortly, but for now, focus on these lines:
bit.move() — moves bit one square to the right
bit.turn_left() — turns bit to the left
bit.turn_right() — turns bit to the right
bit.paint("red") — paints the current square red
Each of these commands is a function that you are calling. Every time you call a function you use parentheses: (). Inside the parentheses are the arguments or parameters for the function.
The move(), turn_left() and turn_right() functions do not take any arguments. The paint() function takes one argument — the name of a color.
Bit understands three colors:
"red"
"green"
"blue"
These must be in double quotes or single quotes.
Running Bit on your own
To get some practice running Bit, create a folder in your cs110 project called bit. You can do this in PyCharm by right-clicking on the cs110 folder and selecting New➡️Directory:
Then create a new file in this folder called hello_bit.py. You can do this by right-clicking on the bit folder and selecting New➡️File:
Then copy and paste this code into the hello_bit.py file you created:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5, 3)
def move_around(bit):
    bit.move()
    bit.move()
    bit.paint("red")

    bit.turn_left()
    bit.move()
    bit.paint("green")

    bit.turn_right()
    bit.move()
    bit.paint("blue")


if __name__ == '__main__':
    move_around(Bit.new_bit)
You should end up with a file like this:
Running the program
Click the green triangle next to the line of code that starts with if:
We will explain this below. Here is what it looks like in PyCharm:
Here is what you should see:
This shows that bit moved through the world and painted some squares.
Use these buttons to “replay” what Bit did:
First — moves back to the first line of code
Prev — moves back one line of code
Next — moves forward one line of code
Last — moves to the last line of code
As you move, the top part of the world will tell you which line of code Python is running.
and select Run 'hello_bit'. You should see what we showed you above:
Problems?
If this code is not running properly, this means you must have missed a step when creating your PyCharm project. You should revisit this and get help from a TA as needed.
Explaining the rest of this code
Let’s go through this code line by line.
Line 1
Whenever you write a program that uses Bit, you need to start with this line:
content_copy
Copy
from byubit import Bit
This is a way of telling Python that you want to use the byubit library that you installed. You will use Bit with a capital B for special commands telling the library what to do.
Lines 4 to 16
Lines 4 to 16 contain a function called move_around():
content_copy
Copy
@Bit.empty_world(5, 3)
def move_around(bit):
    bit.move()
    bit.move()
    bit.paint("red")

    bit.turn_left()
    bit.move()
    bit.paint("green")

    bit.turn_right()
    bit.move()
    bit.paint("blue")
4: @Bit.empty_world(5, 3) — This is a decorator that tells Bit to start in an empty world that is 5 squares wide and 3 squaers tall.
5: def move_around(bit): — This is a function definition. Everything we will do this semester will involve writing Python functions.
6 to 16 — This is the function body. The function body will be run every time you call the function.
A function has five parts to it:
The def keyword tells Python you are defining a function.
The function name tells Python how someone can call this function. Here we have given the function the name move_around().
The function arguments are listed in parentheses. Here we tell Python this function takes one argument, (bit).
The function definition ends with a colon :.
The function body is the list of commands you will run when the function is called. These are indented and the indentation is very important. Every line in the function body must be indented the same amount. The usual indentation is four spaces.
Lines 19 and 20
Lines 19 and 20 contain the main block of the Python program:
content_copy
Copy
if __name__ == '__main__':
    move_around(Bit.new_bit)
Every program has to start somewhere. In Python, we call this the main block. This is where Python starts when it runs your code. Python will put a green triangle to the left of your main block so that you can click on it to run your program.
In this main block, we have one line of code:
content_copy
Copy
move_around(Bit.new_bit)
Here we are calling the move_around() function. We have to give it a bit, and we do this by saying Bit.new_bit. This creates a new bit to live in the world.
Defining versus calling a function
When we define a function with def, we are telling Python what a function means. For example, when we defined move_around() we told Python this means move Bit two squares, turn left, move another square, paint red, and so forth.
When we call a function, we are telling Python to run all of the code in the function definition. This is when Python will actually run all of the code that tells Bit what to do.
Blank lines
Python needs blank lines to separate pieces of the code. The convention is to use two blank lines between every piece. If you do not follow this convention, PyCharm will complain by putting a squiggly line underneath the line that doesn’t have enough blank lines before it.
Add an extra blank line and the warning will go away.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Practice with Bit
In your cs110 project, you should have a folder called bit. Follow the guide on Introduction to Bit if you didn’t do this yet.
First practice problem
Inside of your bit folder, create a new file called practice.py. Put this code in that file:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5, 3)
def go(bit):
    pass


if __name__ == '__main__':
    go(Bit.new_bit)
This is starter code, meaning we have given you a piece of a program but you need to fill in the rest. This is an example of the types of problems we will give you when you write code using Bit. We will give you starter code and you need to fill in the rest.
In this problem, Bit starts in a blank 5x3 world:
Write code so that Bit finishes in a world like this:
To do this, you only need to write code in the go() function definition.
Whenever you see a function that has one statement in it — pass — this is a function where you need to write code. The pass statement is a special keyword in Python that does literally nothing. It just exists as a placeholder for the code you need to write. Delete the pass keyword and write your code there.
In the guide, we will use this picture to indicate that you should pause and work out this problem a friend:
Hopefully you wrote code with a friend! Since this is a guide, we will now give you the answer to this problem. It will be really tempting to just skip to the answers. Don’t do that!
Remember, your whole purpose in life is to grow to be like Christ, and knowledge is a key part of being like Christ.
What if I don’t have a friend? Go to the lab! This is the whole purpose of lab sections, to give you an opportunity to make friends and learn to code together. If this is somehow not feasible for you, use the online lab sections in Discord. You can start your own video chat with a friend on Discord any time you want to code together.
OK, now here is the code for this problem:
content_copy
Copy
@Bit.empty_world(5, 3)
def go(bit):
    bit.move()
    bit.move()
    bit.move()
    bit.turn_left()
    bit.move()
    bit.paint("green")
We tell Bit to move forward three squares, turn left, move forward one square, and then paint green.
Practice with errors #1
In your bit folder, create a new file called no_cake.py and put this code in it:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5,3)
def make_a_cake(bit):
    bit.move()
    bit.paint('red')
    bit.move()
    bit.paint('green')
Draw out what you think this code should do.
Can you run this code? Why not?
Hopefully you drew out something like this:
Maybe you noticed that you can’t run this code because there is no main block. To run the code, you need to add this to the end:
content_copy
Copy
if __name__ == '__main__':
    make_a_cake(Bit.new_bit)
Once you add this, you will see the green triangle appear to the left, allowing you to run the code.
Practice with errors #2
In your bit folder, create a new file called get_moving.py and put this code in it:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5, 3)
def main(bit):
    bit.move
    bit.move
    bit.paint("green")


if __name__ == '__main__':
    main(Bit.new_bit)
If you run this code, what do you think will happen?
Now run the code, and you should see this:
Can you see why bit.move doesn’t do anything? The code is missing the (). Remember, bit.move() is a function, and you need to use parentheses whenever you call a function.
Try adding the parentheses and re-running the code.
Practice with errors #3
In your bit folder, create a new file called go_the_distance.py and put this code in it:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5, 3)
def go_go_go(bit):
    bit.move()
    bit.move()
    bit.move()
    bit.move()
    bit.move()
    bit.paint('green')


if __name__ == '__main__':
    go_go_go(Bit.new_bit)
If you run this code, what do you think will happen?
Now run the code and you should see this:
The top of the window will show that you tried to move “out of bounds” meaning outside of the 5x3 Bit world. You will also see an error in the bottom part of the screen in PyCharm:
Your program will stop running at the point that you ask Bit to move out of bounds, and nothing else will happen. So you will never run the bit.paint('green') instruction.
Practice with errors #4
In your bit folder, create a new file called colorful.py and put this code in it:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5, 3)
def paint_stuff(bit):
    bit.move()
    bit.paint()


if __name__ == '__main__':
    paint_stuff(Bit.new_bit)
If you run this code, what do you think will happen?
Now run the code and you should see this:
The error message at the top of the window doesn’t tell you very much. But if you look at the bottom of PyCharm you will see this:
When you see this message:
content_copy
Copy
Bit.paint() missing 1 required positional argument: 'color'
This means that you tried to call bit.paint() but you are missing the required argument — a color you want to paint. You need to use 'green', 'red', or 'blue' as the color.
Solving a problem
Download grassy_field.zip and put its contents into your bit folder. You should have a folder called grassy_field with a file called grassy_field.py and a folder called worlds:
Inside of grassy_field.py you will see this code:
content_copy
Copy
from byubit import Bit


@Bit.worlds("grassy_field")
def make_sky(bit):
    bit.paint('blue')


if __name__ == '__main__':
    make_sky(Bit.new_bit)
In this example, Bit starts in a world called grassy_field. The files needed for this world are located in the worlds folder.
The starting world for Bit looks like this:
The ending world should look like this:
However, when you run this code, you will see a comparison error:
What you see here is:
exclamation mark with a blue background — this means that square should be blue
empty Bit at the far right — this is where Bit should be located and what direction Bit should be pointing
Can you fix the code so that it works properly?
Hopefully you realized you need to call the bit.move() and bit.paint() functions:
content_copy
Copy
def make_sky(bit):
    bit.paint('blue')
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.paint('blue')

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Functions
Video Transcript
In your bit folder, create a file called three_reds.py and put this code in it:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(7, 4)
def run(bit):
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()


if __name__ == '__main__':
    run(Bit.new_bit)
If you run this code, you will see that Bit draws three red squares:
Defining your own functions
But what if you wanted to paint three red squares lots of times? If you want to do this, it helps a lot to define your own functions. You could write a function called three_red() that paints three red squares:
content_copy
Copy
def three_red(bit):
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()
There are five parts to a function:
The def keyword tells Python you are starting a function definition.
The function name tells Python the name of the function.
The function arguments (or parameters) tell Python what information the function uses when it runs (in this case uses bit) and must be in parentheses.
The colon ends the first line of the function.
The function body is indented four spaces and contains the instructions that will run when the function is called.
For now, we will always have one argument to your functions — bit. In the future, we will show you how to use multiple arguments.
Calling your function
You can call this function in your code by typing:
content_copy
Copy
three_red(bit)
Replace the contents of your three_reds.py file with:
content_copy
Copy
from byubit import Bit


def three_red(bit):
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()


@Bit.empty_world(7, 4)
def run(bit):
    three_red(bit)
    bit.turn_left()
    three_red(bit)
    bit.turn_right()
    three_red(bit)


if __name__ == '__main__':
    run(Bit.new_bit)
Here we call three_red(), turn left, call three_red() again, turn right, and then call three_red() again.
If you run this code, you should see:
The Bit decorator
Look at the code above. Notice that the decorator — @Bit.empty_world(7, 4) — only goes on the run() function. It is not on top of our new three_red() function.
You should only put the Bit decorator on your very first function — which is usually the only function called in side of your main block.
Snapshots
As soon as you start writing larger Bit programs, you will find it becomes tedious to click the Next and Prev buttons to see what your program is doing. To make things simpler, you can take a snapshot of your code at any point:
content_copy
Copy
bit.snapshot('some descriptive name')
Modify your three_reds.py file by adding one line to the end of your three_red() function:
content_copy
Copy
def three_red(bit):
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()
    bit.snapshot('End of three reds')
Now when you run this program, Bit will create a snapshot every time it finishes running three_red(). You will see a new buttons called Jump:
Pressing these will jump to the previous or next snapshot. By creating a snapshot at the end of the function, this lets you jump through your program one function call at a time.
Calling a function
Let’s look at calling a function one more time. In your bit directory, create a file called coloring_squares.py and put this code in it:
content_copy
Copy
from byubit import Bit


def reds(bit):
    bit.paint('red')
    bit.move()
    bit.paint('red')
    bit.move()


def blues(bit):
    bit.paint('blue')
    bit.move()
    bit.paint('blue')
    bit.move()


def greens(bit):
    bit.paint('green')
    bit.move()
    bit.paint('green')
    bit.move()


@Bit.empty_world(7, 3)
def run(bit):
    reds(bit)
    greens(bit)


if __name__ == '__main__':
    run(Bit.new_bit)
Take a look at this program. What do you think it will do?
If you run the program, it creates this world:
Why didn’t it paint anything blue?
Remember, functions need to be called in order to run.
We defined the blues() function, but we never called it. Since we never called it, blues() never runs, so no blue squares are ever painted.
Docstrings
When you write a function in Python, you can add a docstring to provide helpful comments on what the function does. For example, when writing our greens() function above, we could have written:
content_copy
Copy
def greens(bit):
    """
    Colors two squares green, starting with the current square.

    Bit ends on the third square, facing in the same direction as it started.
    """
    bit.paint('green')
    bit.move()
    bit.paint('green')
    bit.move()
A docstring starts and ends with triple quotes """.
A good docstring will describe what the function does and tell you the starting and ending conditions. For example in the docstring above it tells you that it starts on the current square and ends on the third square, facing in the same direction as it started. This kind of context can help you keep track of what each function does.
Naming a function
When you name a function, follow these guidelines:
Use lowercase letters
Use underscores _ to break up compound names. Your function should be called move_around() not movearound() or moveAround().

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with functions
Video Transcript
We are going to practice writing functions by drawing some smiles. Our bit world starts like this:
and we want to draw four smiles:
Planning
Before you write any code, you should plan what you want to do. A good way to do this is with pencil and paper. Find a friend and draw out how you think you would solve this problem.
Tip: Start by drawing out just one smile. Remember, you can draw one smile with a function and then draw the rest by calling that function.
What did you draw? Maybe you drew something like this:
or something like this:
There is not necessarily a right way or a wrong way to do this. There may be some ways that are easier and some that are harder, in the sense that they take more work to write the associated program. One rule of thumb is to try to move in one direction only (left to right or top to bottom), as this will generally reduce the amount of code you have to write. But we could write code to match either of these drawings!
Starting to code
Download the file linked above and store it in your bit folder. Look at the starter code in smiles.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('smiles')
def run(bit):
    pass


if __name__ == '__main__':
    run(Bit.new_bit)
What you want to do is translate your sketch into a set of functions that do each part. We are going to work off the first drawing:
Your first instinct will normally be to start writing the first piece, labeled (1) in the diagram - move right. But if you keep doing this, you will end up with a very long run() function. Instead, think at the highest level and work your way down to smaller pieces.
The first step is to draw a smile, so let’s write a function for that:
content_copy
Copy
from byubit import Bit


def draw_smile(bit):
    pass


@Bit.worlds('smiles')
def run(bit):
    draw_smile(bit)


if __name__ == '__main__':
    run(Bit.new_bit)
We are not ready to write the code there yet, so we wrote pass temporarily. Using pass makes the code valid, even though it does nothing.
Decomposition
The next step is to take each of the four steps from our drawing and turn them into functions:
content_copy
Copy
def draw_smile(bit):
    move_into_place(bit)
    left_side(bit)
    bottom(bit)
    right_side(bit)
This is called decomposition in computer science — taking a larger problem and breaking it down into smaller pieces.
Decomposition is one of the most fundamental skills you will learn in this class. It is part of a broader concept referred to as “computational thinking.” You will find that this skill will help you with problem solving in many disciplines.
As you type this into PyCharm, you will notice that PyCharm will underline these functions with red squiggly lines:
If you hover over one of them, a tip will pop up telling you what is wrong:
PyCharm is telling you the function move_into_place() is not defined yet. You can’t call a function that you haven’t written. But this is easy to fix! Just click the blue solution, Create function 'move_into_place' and PyCharm will write an empty function for you:
Click on all of the rest of these, and now you have a complete program again:
content_copy
Copy
from byubit import Bit


def move_into_place(bit):
    pass


def left_side(bit):
    pass


def bottom(bit):
    pass


def right_side(bit):
    pass


def draw_smile(bit):
    move_into_place(bit)
    left_side(bit)
    bottom(bit)
    right_side(bit)


@Bit.worlds('smiles')
def run(bit):
    draw_smile(bit)


if __name__ == '__main__':
    run(Bit.new_bit)
Filling in the functions
This program doesn’t do any drawing yet. But it has fantastic decomposition! Having the problem decomposed is an important step in programming. Filling in the details of each function is relatively easy.
Keep in mind our sketch:
Let’s fill in just one function, the first one that is called:
content_copy
Copy
def move_into_place(bit):
    """ Gets into position to draw a smile by moving to the
        top left eye and then turning right.
    """
    bit.move()
    bit.turn_right()
Notice we put bit.turn_right() here so we can get ready for the next piece.
Ok, that one is really easy, so let’s do one more:
content_copy
Copy
def left_side(bit):
    """ Paints the top left eye and the  left corner of the smile.
        Ends up facing to the right on the bottom left of the smile.
    """
    bit.paint('blue')
    bit.move()
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.turn_left()
That was actually pretty easy too!
Now, you may be tempted to keep writing code here. But it is a good idea to stop and see if these two functions are working before we fill in any more. Because all the other functions are using pass they are valid and will run. So you can run your code to see how you are doing so far:
Hey, that’s pretty good! You can see that your first two functions are working as expected.
Filling in more functions
Let’s fill in a couple more. Here’s our sketch:
We can now do the bottom of the smile:
content_copy
Copy
def bottom(bit):
    """ Paints the bottom part of the smile. Ends up facing right,
        in the bottom right corner of the smile.
    """
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.turn_left()
and the right side of the smile:
content_copy
Copy
def right_side(bit):
    bit.move()
    bit.paint('blue')
    bit.move()
    bit.move()
    bit.paint('blue')
    bit.turn_right()
Run your code to see how well those are working:
Look at that, we’ve got our first smile completed!
The rest of the smiles
Now that we can draw a single smile, we can go back to our main function:
content_copy
Copy
@Bit.worlds('smiles')
def run(bit):
    draw_smile(bit)
We need to put in code for the rest of the smiles. Let’s try this:
content_copy
Copy
@Bit.worlds('smiles')
def run(bit):
    draw_smile(bit)
    draw_smile(bit)
    draw_smile(bit)
    draw_smile(bit)
If we run this, we get a lot of errors:
Our smiles are too close together! This means we are missing some glue code. Notice how when we draw a single smile, we start off one square to the left. But when we finish a smile, we are two squares to the left of the next smile.
We can fix this by adding an extra move in between the smiles:
content_copy
Copy
@Bit.worlds('smiles')
def run(bit):
    draw_smile(bit)
    bit.move()
    draw_smile(bit)
    bit.move()
    draw_smile(bit)
    bit.move()
    draw_smile(bit)
Now when we run this we get the correct final world:
We are very happy indeed! :-)
Decomposition + write small functions = happier life
When you decompose a bigger problem into smaller steps, you end up with small functions. Each function should have a single, clear purpose. When you write code, you should live by this philosophy:
Write small functions that do one thing well.
If you also write one function at at time, and then test it, you will be more successful. It is not fun to write a very large amount of code, have a problem in that code, and not know where that problem is.
Good decomposition will make your programs easier to write and make your programs easier to understand.
Remember, when you write code, you are writing not just for yourself now, but for anyone who might read your code in the future, including your future self.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
While loops
Imagine you start with an empty 5x3 Bit world…
and you want to fill the bottom row with green squares:
You might imagine writing code like this:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5, 3)
def go_green(bit):
    bit.paint('green')
    bit.move()
    bit.paint('green')
    bit.move()
    bit.paint('green')
    bit.move()
    bit.paint('green')
    bit.move()
    bit.paint('green')


if __name__ == '__main__':
    go_green(Bit.new_bit)
If you repeat bit.paint('green') and bit.move() enough times, you will eventually paint the bottom.
But what if your world was 100 squares wide?
The approach above would get really tedious!
While
This motivates why Python (and other programming languages) have a while loop:
content_copy
Copy
def go_green(bit):
    while bit.can_move_front():
        bit.paint('green')
        bit.move()
This code says while the front of bit is clear, paint green and move forward one square.
We are introducing a new Bit function here:
content_copy
Copy
bit.can_move_front()
This function returns True if the front of bit is clear. This will return True as long as the space in front of Bit is clear, otherwise it will return False.
Let’s look at the while loop more closely:
it must start with the while keyword
this is followed by a condition that evaluates to True or False
the first line ends with a colon :
the body of the while loop is indented
Every time Python runs the while loop it checks the condition. If it is true, then it runs the lines of code in the body of the loop. After it runs the body, it checks the condition again. It will keep checking the condition and run the body every time the condition is true. It leaves the loop if the condition is false.
While in action
To practice with while loops, download the zip file linked above. Find the go_green.py file, which looks like this:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(5, 3)
def go_green(bit):
    while bit.can_move_front():
        bit.paint('green')
        bit.move()


if __name__ == '__main__':
    go_green(Bit.new_bit)
Run it, and you should see this result:
click the First button
click the Next button repeatedly and watch the code execute
You should see Python check if the front is clear. This will be True the first time, so it will paint and then move. It will check the condition again … and repeat the loop, until it checks the condition and finds that the front is not clear, so it stops.
Boundary conditions
Every time you use a while loop, you should think about the boundary conditions:
Where is Bit when the loop starts?
Where will Bit be when the loop ends?
What squares will be colored?
Which squares will not be colored?
Which direction is Bit facing at the beginning? at the end?
In the code above, when Bit finishes the while loop, the last square is left unpainted.
Painting the last square
Remember, we want the whole bottom row to be green. How do we paint the last square green?
You need to add an extra bit.paint('green') outside the while loop:
content_copy
Copy
def go_green(bit):
    while bit.can_move_front():
        bit.paint('green')
        bit.move()

    bit.paint('green')
Because this last bit.paint('green') is not indented, it is outside the while loop. When bit.can_move_front() is False, then Python will skip the loop and go to the next non-indented line. So it will paint one more square green and then finish the go_green() function:
Moving first and then painting
You could also change your go_green() function to move first and then paint green:
content_copy
Copy
def go_green(bit):
    while bit.can_move_front():
        bit.move()
        bit.paint('green')
Here, the boundary conditions will be different! This will paint every square green except the first one. Step through the code using the First and Next buttons to see why.
You can paint the entire bottom row green by placing an extra bit.paint('green') that comes before the while loop:
content_copy
Copy
def go_green(bit):
    bit.paint('green')
    while bit.can_move_front():
        bit.move()
        bit.paint('green')
It’s up to you to decide whether to paint first or move first. There is often more than one way to solve a problem.
Blocks
Bit worlds may sometimes include black squares:
Black squares stop bit from moving onto them. To see this in action, open the file called blocked.py, which is in the zip file you downloaded:
content_copy
Copy
from byubit import Bit


@Bit.worlds('blocked')
def blocked(bit):
    bit.move()


if __name__ == '__main__':
    blocked(Bit.new_bit)
All bit does here is try to move one square. But if you run the code you will see this error:
Conditions in Bit
Bit supports the following functions that check whether it is safe to move:
bit.can_move_front() — returns True if the front is clear, False otherwise
bit.can_move_right() — returns True if the right is clear, False otherwise
bit.can_move_left() — returns True if the left is clear, False otherwise
For a square to be clear, it must not be black or the edge of the world.
Looking at this world:
bit.can_move_front() is False
bit.can_move_right() is False
bit.can_move_left() is True
Look at the file called black_row.py, which is in the zip file you downloaded:
content_copy
Copy
from byubit import Bit


@Bit.worlds('black-row')
def go(bit):
    while bit.can_move_right():
        bit.move()


if __name__ == '__main__':
    go(Bit.new_bit)
Bit starts in this world:
We want to move Bit until it is next to the first black square:
The code above uses while bit.can_move_right() to move until the right is no longer clear. Run the code above and use the First and Next buttons to see how it uses this condition.
Negating conditions
You can negate conditions using the not keyword. For example:
content_copy
Copy
while not bit.can_move_right()
    bit.move()
will move Bit as long as the right side is not clear.
To see this in action, open the file called another-black-row.py, which is in the zip file you downloaded:
content_copy
Copy
from byubit import Bit


@Bit.worlds('another-black-row')
def go(bit):
    while not bit.can_move_right():
        bit.move()


if __name__ == '__main__':
    go(Bit.new_bit)
Bit starts in this world:
We want to move Bit until it gets past all of the black squares:
The code above uses while not bit.can_move_right() to move until the right is clear. Run the code and use the First and Next buttons to see how it uses this condition.
Python will check bit.can_move_right() and this will be False. But then the not turns the False to True.
At the end of the loop, Python will check bit.can_move_right() and this will be True. But then the not turns the True to False, and so Bit leaves the while loop.
More conditions in Bit
Bit also provides a way for you to check which color of square Bit is currently on top of:
bit.is_on_blue() — returns True if Bit is on a blue square
bit.is_on_green() — returns True if Bit is on a green square
bit.is_on_red() — returns True if Bit is on a red square
bit.is_on_white() — returns True if Bit is on an empty square (no color)
To see this in action, open the file green_path.py, which is in the zip file you downloaded:
content_copy
Copy
from byubit import Bit


@Bit.worlds('green-path')
def walk(bit):
    while bit.is_on_green():
        bit.move()


if __name__ == '__main__':
    walk(Bit.new_bit)
Bit starts in this world:
We want to have Bit follow the green squares until it gets past the last one:
The code above uses while bit.is_on_green() to move until the square it is on is not green. Run the code and use the First and Next buttons to see how it uses this condition.
You can find another example in blue_dot.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('blue-dot')
def go_to_blue(bit):
    while not bit.is_on_blue():
        bit.move()


if __name__ == '__main__':
    go_to_blue(Bit.new_bit)
Bit starts in this world:
We want to have Bit move until it gets to the blue square:
The code above uses while not bit.is_on_blue() to move until the square it is on is blue. Run the code and use the First and Next buttons to see how it uses this condition.
Infinite loops
Open the file called infinite_loopy.py in the zip file you downloaded:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(3, 3)
def run(bit):
    while bit.can_move_front():
        bit.move()
        bit.paint('blue')
        bit.move()
        bit.paint('blue')
        bit.turn_left()


if __name__ == '__main__':
    run(Bit.new_bit)
This code works on an empty 3x3 world:
In the code, while the front is clear, bit will:
move
paint a blue square
move
paint a blue square
turn left
You can draw this out and see that Bit will paint the bottom row blue and then turn left:
Since the front of bit is clear, it will do this again:
and again and again and again …
Thankfully, if you run the code, Bit will alert you if you have created an infinite loop:

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with while loops
Video Transcript
This problem will help you practice using while loops and decomposing problems. Download the code linked above. Bit starts in this world:
The black squares represent the ground. The green squares represent the branches of a tree. The red square represents the trunk of a tree — except it is not complete!
Your job is to fix the tree so that it looks like this:
Starter code
Download the zip file above and put it in your bit folder. You will find a file called fix_tree.py that has the following starter code:
content_copy
Copy
from byubit import Bit


@Bit.worlds('fix-tree', 'fix-another-tree')
def fix_the_tree(bit):
    # Write code here
    pass


if __name__ == '__main__':
    fix_the_tree(Bit.new_bit)
Planning
Before you write any code, you should plan what you want to do. A good way to do this is with pencil and paper. Find a friend and draw out how you think you would solve this problem.
What did you draw? Maybe you drew something like this:
Step 1: move to the tree trunk and turn left
Step 2: draw the rest of the tree trunk
Decomposing the problem
Remember from [/guide/unit1/practice-with-functions](Practice with functions), it is good practice to start at the highest or most abstract level and write functions. For example:
content_copy
Copy
def fix_the_tree(bit):
    """ Move to the trunk and the draw the trunk. """
    move_to_the_trunk(bit)
    draw_the_trunk(bit)
Remember, PyCharm will put squiggly red lines underneath the functions you haven’t defined yet:
Hover over these and select Create function in blue to create empty functions for each of them:
content_copy
Copy
def move_to_the_trunk(bit):
    pass


def draw_the_trunk(bit):
    pass


@Bit.worlds('fix-tree', 'fix-another-tree')
def fix_the_tree(bit):
    """ Move to the trunk and the draw the trunk. """
    move_to_the_trunk(bit)
    draw_the_trunk(bit)
Moving to the trunk
How would you move to the trunk? Hint: remember what we learned in the guide on while. Also, remember you want to turn left after you get to the trunk, so you can be in position to draw the trunk in the next step.
Here is one way to do this:
content_copy
Copy
def move_to_the_trunk(bit):
    """ Move until Bit gets to a red square, then turn left. """
    while not bit.is_on_red():
        bit.move()

    bit.turn_left()
Let’s stop here, run the code, and see how we are doing:
Fantastic!
Work on problems one step at a time. Don’t try to solve the whole problem at once.
Remember, we can do this if we define our functions first, and then put pass in the ones we don’t want to implement yet.
Drawing the trunk
How would you move to the trunk?
Here is one way to try to do this:
content_copy
Copy
def draw_the_trunk(bit):
    """ Move until Bit gets to a green square, painting red on the way. """
    while not bit.is_on_green():
        bit.move()
        bit.paint('red')
This code makes sense — as long as we are not on a green square, move and paint red for the trunk.
But here is what happens when we run this:
Oops! We somehow painted right through the trunk and tried to go out of bounds!
If this was your first try, don’t be embarrassed. Everybody makes mistakes like this all the time. The key is understanding why you made a mistake and being able to fix it. To a large extent, making and fixing mistakes is what coding is all about. (It’s also a lot about what life is like.)
Use the First and Next buttons. See if you can figure out why this code doesn’t work.
If you get to this step:
click Next slowly and observe each step. You will observe that Python runs your code this way:
is the current square green? no
move
paint red
is the current square green? no because we just painted it red
Aha! So we need to rethink our code. The loop can’t move and then paint red, because it will always change the tree branches to be red.
So let’s try reversing the order of those statements:
content_copy
Copy
def draw_the_trunk(bit):
    """ Move until Bit gets to a green square, painting red on the way. """
    while not bit.is_on_green():
        bit.paint('red')
        bit.move()
Run this code:
Hooray!
Be sure to click on the fix-another-tree tab and be sure your solution works for the other world:
Getting picky
You may have noticed something unusual about our solution:
content_copy
Copy
def draw_the_trunk(bit):
    """ Move until Bit gets to a green square, painting red on the way. """
    while not bit.is_on_green():
        bit.paint('red')
        bit.move()
When we run this function, Bit is already on a red square, and then we paint it red again. That’s not the end of the world, obviously. It is OK to repaint a square as long as it stays the same color. But if you want to be picky about your code (which is a good quality to have), you could solve the problem this way:
content_copy
Copy
def draw_the_trunk(bit):
    """ Move until Bit gets to a green square, painting red on the way. """
    # move one square first because we are already on red
    bit.move()
    while not bit.is_on_green():
        bit.paint('red')
        bit.move()

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Fix the bridge
Video Transcript
This problem will help you practice using while loops and decomposing problems. Download the code linked above. Bit starts in this world:
The black squares represent the ground. The blue squares represent water in a river. The red squares represents a bridge — except it is not complete!
Your job is to fix the bridge so that it looks like this:
Starter code
Download the zip file above and put it in your bit folder. You will find a file called fix_bridge.py that has the following starter code:
content_copy
Copy
from byubit import Bit


@Bit.worlds('fix-bridge', 'fix-another-bridge')
def go_fix_the_bridge(bit):
    # Write code here
    pass


if __name__ == '__main__':
    go_fix_the_bridge(Bit.new_bit)
Notice that there is another world (fix-another-bridge) so your solution will need to be general enough to solve both problems:
Planning
Before you write any code, plan out your solution with pencil and paper. Find a friend and draw out how you think you would solve this problem.
What did you draw? Maybe you drew something like this:
Step 1: Move to the bridge
Step 2: Fix the bridge
Step 3: Move off the bridge
Decomposing the problem
Now start at the highest or most abstract level and write functions. For example:
content_copy
Copy
def go_fix_the_bridge(bit):
    """ Move to the bridge, fix the bridge, and move off the bridge. """
    move_to_the_bridge(bit)
    fix_the_bridge(bit)
    move_off_the_bridge(bit)
Remember, PyCharm will put squiggly red lines underneath the functions you haven’t defined yet:
Hover over these and select Create function in blue to create empty functions for each of them:
content_copy
Copy
def move_to_the_bridge(bit):
    pass


def fix_the_bridge(bit):
    pass


def move_off_the_bridge(bit):
    pass


@Bit.worlds('fix-another-bridge', 'fix-bridge')
def go_fix_the_bridge(bit):
    """ Move to the bridge, fix the bridge, and move off the bridge. """
    move_to_the_bridge(bit)
    fix_the_bridge(bit)
    move_off_the_bridge(bit)
We define these functions with pass so that we can fill them in one at a time.
Moving to the bridge
How would you move to the bridge?
Here is one way to do this:
content_copy
Copy
def move_to_the_bridge(bit):
    """ Move to the left corner of the bridge.
        End up on the red square, facing right
    """
    while not bit.can_move_right():
        bit.move()

    # Bit is now over the left end of the bridge
    # Move down and onto the bridge, end facing to the right
    bit.turn_right()
    bit.move()
    bit.turn_left()
We can use while not bit.can_move_right() to keep moving until we get past the edge of the ground. This leaves us right above the red square. The last step is to turn, move down, and then turn back so we end up facing right. This puts Bit in good position to fix the bridge.
Stop and run your code to be sure it works:
It is OK that we haven’t solved the entire problem! We have the first step working great!
Comments
In the code above, you will see that there are some comments, which are lines starting with a pound sign #. Comments are a way to write notes to yourself and to others to explain what you were thinking when you wrote your code. They are really helpful!
Try to write comments liberally in your code. This will seem like extra work at first, but they will save you time as you write code. You will invariably take a break and come back to your code at a later time. Comments will let you know what you were thinking, especially if you are looking for bugs.
Use comments liberally!
Fix the bridge
OK, back to coding. How would you fix the bridge?
Here is one way to do this:
content_copy
Copy
def fix_the_bridge(bit):
    """ Fix the bridge. End up on the last square, facing right. """
    # move off the first red square
    bit.move()
    # now move until we get to a red square, painting as we go
    while not bit.is_on_red():
        bit.paint('red')
        bit.move()
We want to use while not bit.is_on_red() to move to the right side of the bridge. But Bit starts on a red square! So we need to move Bit one square first, and then run this while loop.
Inside the while loop, we paint first and then move. If we move first and then paint, we would skip a square.
Let’s run our code, which covers the first two steps:
We have made great progress! We have only one more step left.
Move off the bridge
How would you move off the bridge and get Bit to its final position?
Here is one way to do this:
content_copy
Copy
def move_off_the_bridge(bit):
    """ Move off the bridge and into the final position, at the right
        edge of the world, facing right.
    """
    # move off the bridge
    bit.turn_left()
    bit.move()
    bit.turn_right()

    # now move until Bit gets to the edge of the world
    while bit.can_move_front():
        bit.move()
We first have to move Bit off the bridge. Once Bit is on the ground, we can use a while loop to move to the right edge of the world.
Let’s check to be sure this works:
Wonderful! Another problem solved!
While versus while not
Notice how we sometimes use while and sometimes while not. To move to the edge of the bridge we use while not:
content_copy
Copy
while not bit.can_move_right():
    bit.move()
We are looking for a clear space, so we need to move while it is not clear on the right.
However, to move to the edge of the world, we use just while:
content_copy
Copy
while bit.can_move_front():
    bit.move()
This is because we are looking for a space that is not clear, so we need to move while it is clear.
With practice, this will become natural.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Blue ocean
Video Transcript
This problem will help you practice using while loops and decomposing problems.
Bit starts in this world:
Your job is to have Bit fill the world with a blue ocean, and end up back where they started:
Starter code
In your bit folder, create a file called blue_ocean.py. Copy and paste this code into the file:
content_copy
Copy
from byubit import Bit


@Bit.empty_world(6, 6)
def run(bit):
    # Write code here
    pass


if __name__ == '__main__':
    run(Bit.new_bit)
Planning
Before you write any code, plan out your solution with pencil and paper. Find a friend and draw out how you think you would solve this problem.
What did you draw? Maybe you decided to fill one row, go up, and fill the next row going in the opposite direction:
Step 1: Fill a pair of rows
Step 2: Fill the rest of the rows
Step 3: Go back to the start
Or maybe you decided to fill one row, then go back to the beginning of the row:
Step 1: Fill a single row
Step 2: Fill the rest of the rows
Step 3: Go back to the start
Let’s talk about these approaches for a minute:
(1) First, we want to use a loop to fill in all the rows. Don’t just copy and paste code 3 times (if you are doing pairs) or 6 times (if you are doing one row at a time).
(2) Second, to make this loop work, it is a good idea to end the first step facing up. This will allow you to use a while loop to fill in the rest of the rows, because you can keep fill rows as long as the front is clear.
(3) You can technically use either approach, filling one or two rows at a time. But filling pairs of rows only works if the number of rows is even! If we had 5 or 7 rows, the solution would break.
For this reason, we are going to use the sketch where we fill one row at a time.
Decomposing the problem
We start at the highest or most abstract level and write functions. For example:
content_copy
Copy
def run(bit):
    """ Fill an ocean by doing one row at a time. """
    fill_one_row(bit)
    while bit.can_move_front():
        # move up and turn right
        bit.move()
        bit.turn_right()
        # fill one row
        fill_one_row(bit)

    go_back_to_start(bit)
This solution has Bit fill one row and then end facing up. Then we keep moving up one row and filling rows as long as there is space to do this. Finally, we move back to the start.
Remember, PyCharm will put squiggly red lines underneath the functions you haven’t defined yet. Hover over these and select Create function in blue to create empty functions for each of them.
Filling one row
How would you fill one row and then move back to the start of the row?
In this case, filling a row consists of multiple parts — painting the row, and then going back. In cases like this, the best thing to do is to repeat the decomposition step and make two new functions:
content_copy
Copy
def fill_one_row(bit):
    """ Fill one row """
    # go forward, painting blue
    paint_row(bit)
    # turn around and go back
    turn_around(bit)
Then you can fill these in:
content_copy
Copy
def paint_row(bit):
    """ Paint an entire row blue """
    bit.paint('blue')
    while bit.can_move_front():
        bit.move()
        bit.paint('blue')
This function paints the entire row blue, starting with the first square.
content_copy
Copy
def turn_around(bit):
    """ Turn around and go back to the start of the row.
        End facing up.
    """
    # turn around
    bit.turn_right()
    bit.turn_right()
    # move back
    while bit.can_move_front():
        bit.move()

    # face up
    bit.turn_right()
This function turns around, moves all the way back, and then faces up.
Use small functions that do one thing well
If you put all of that code into one, big, fill_one_row() function, your code will still work, it will just not be as beautiful. It is easier to write and maintain code that has been decomposed into small functions.
Now let’s stop and run this code to be sure it works:
Hey, we filled all the rows! This is because our main run() function re-uses our fill_one_row() function:
content_copy
Copy
def run(bit):
    """ Fill an ocean by doing one row at a time. """
    fill_one_row(bit)
    while bit.can_move_front():
        # move up and turn right
        bit.move()
        bit.turn_right()
        # fill one row
        fill_one_row(bit)

    go_back_to_start(bit)
The only thing we have left is to write go_back_to_start().
A debugging interlude
You will probably not write your code corretly the first time. In that case, you will need to debug your code. Try removing bit.turn_right() in the run() function. Run the code and see what it does. Use the buttons to see why this happens.
Go back to the start
OK, back to coding. How would you go back to the start?
Here is one way to do this:
content_copy
Copy
def go_back_to_start(bit):
    """ Go back to the start. """
    # turn around
    bit.turn_right()
    bit.turn_right()
    # move back
    while bit.can_move_front():
        bit.move()

    # turn to face right (the way we started)
    bit.turn_left()
We need to turn around, move back, and then get Bit facing the right way. Run the code:
We did it!

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
If statements
Imagine you have Bit starting in this world:
You want to change every red square into a blue square:
You might think you could do this:
content_copy
Copy
while bit.can_move_front():
    bit.move()
    bit.paint('blue')
    bit.move()
This works, but what if you want your code to work no matter how many red dots there are? For example, you could have a world like this:
or this:
if statement
This is where we need to use an if statement. We want Bit to move from left to right and if it encounters a red square, change it to blue:
content_copy
Copy
if bit.is_on_red():
    bit.paint('blue')
These are the parts of an if statement:
it must start with the if keyword
this is followed by a condition that evaluates to True or False
the first line ends with a colon :
the body of the if statement is indented
Python checks the condition in the if statement. If it is true, then it runs the lines of code in the body of the loop. If it is not true, then it does not run the code in the body of the loop — it skips over it.
To see this in action, download the zip file listed above and put it in your bit folder. Look at the file called red-dots.py:
content_copy
Copy
from byubit import Bit


def change_square(bit):
    if bit.is_on_red():
        bit.paint('blue')


@Bit.worlds('red-dots', 'another-red-dots', 'yet-another-red-dots')
def go(bit):
    while bit.can_move_front():
        bit.move()
        change_square(bit)


if __name__ == '__main__':
    go(Bit.new_bit)
This code loads all three Bit worlds shown above. The function called go() moves forward as long as the front is clear. The function called change_square() changes a square to blue if it is red.
Click the tabs for the different worlds, and you will see that this code works for all three worlds.
Event stream pattern
This code follows the event stream pattern. The idea behind this pattern is that we use the while statement to move through the world and then the if statement to modify the world, depending on some condition.
In the code above:
go() — moves Bit forward
change_squares() — modifies the world based on conditions
Using else with if
Let’s take a look at another Bit world:
This world has some red squares and some green squares. The job for Bit this time is to turn red squares to blue and to turn any blank squares into green squares:
We can do this with an if-else statement:
content_copy
Copy
if bit.is_on_red():
    bit.paint('blue')
else:
    bit.paint('green')
This tells Bit to check if a square is red. If it is red, Bit paints it blue. Otherwise, Bit paints the square green.
These are the parts of an if-else statement:
if, a condition, and a colon
a block for the if
else, a colon
a block for the else
To see this in action,look at the file called more-red-dots.py. We again use the event stream pattern:
content_copy
Copy
from byubit import Bit


def change_squares(bit):
    if bit.is_on_red():
        bit.paint('blue')
    else:
        bit.paint('green')


@Bit.worlds('more-red-dots')
def go(bit):
    while bit.can_move_front():
        bit.move()
        change_squares(bit)


if __name__ == '__main__':
    go(Bit.new_bit)
Step through the code with First and Next to see how this works.
Using elif with if
Take a look at this world:
Bit needs to follow these rules:
while Bit is not blocked, move forward
if the current square is red, turn left
if the current square is green, turn right
otherwise, paint the current square blue
To have Bit follow these rules, we are going to use if, elif, else:
content_copy
Copy
    if bit.is_on_red():
        bit.turn_left()
    elif bit.is_on_green():
        bit.turn_right()
    else:
        bit.paint('blue')
This is how you can use these together:
if, a condition, and a colon
a block for the if
elif, a condition, and a colon
a block for the elif
else, a colon
a block for the else
Python will check each of the conditions in order:
You can add as many elif conditions as you want. There can be only one if and one else block.
To see this code in action, open the turns.py file:
content_copy
Copy
from byubit import Bit


def respond_to_square(bit):
    if bit.is_on_red():
        bit.turn_left()
    elif bit.is_on_green():
        bit.turn_right()
    else:
        bit.paint('blue')


@Bit.worlds('turns')
def go(bit):
    bit.paint('blue')
    while bit.can_move_front():
        bit.move()
        respond_to_square(bit)


if __name__ == '__main__':
    go(Bit.new_bit)
Run the code using the First and Next buttons to watch how it works, step by step.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with if statements
These problems will give you a chance to practice using if statements. Use the event stream pattern, and think carefully about when you need to use elif and else.
Download the zip file above and put it in your bit folder.
Holes
For this problem, Bit starts in this world:
Bit is a pipe, and the pipe has holes on each side. Bit’s job is to mark where the holes are so someone else can fix them. Bit goes down the center and follows these rules:
mark holes on the right by painting the current square red
mark holes on the left by painting the current square green
otherwise paint squares blue
The ending world should look like this:
You will find starter code in holes.py:
from byubit import Bit
content_copy
Copy
@Bit.worlds('holes')
def run(bit):
    # Write code here
    pass


if __name__ == '__main__':
    run(Bit.new_bit)
You should use the event stream pattern to solve this problem.
Flow chart
A good way to think about problems that use if statements is to use a flow chart:
In a flow chart, the rectangles represent a process — something you do — and the triangles represent a decision — a condition for a while loop or if statement.
The purple square represents a separate function we have to write. We can call this a helper function, because it helps the main function do its job.
In this flow chart, we have separated the main function into the left side and a helper function on the right side. This helps make the event stream pattern clear. The main function moves forward, and the helper function handles the event stream.
Writing code
How would you turn this flow chart into code?
One thing to spot from this flow chart is that we should have a while loop for the decision labeled is the front clear? because we loop back to check this repeatedly. We should have an if-elif-else statement for the other three decisions.
Here is one way to do this:
content_copy
Copy
# Solution
from byubit import Bit


def change_square(bit):
    if bit.can_move_right():
        bit.paint('red')
    elif bit.can_move_left():
        bit.paint('green')
    else:
        bit.paint('blue')


@Bit.worlds('holes')
def run(bit):
    bit.paint('blue')
    while bit.can_move_front():
        bit.move()
        change_square(bit)


if __name__ == '__main__':
    run(Bit.new_bit)
Run this code and use the buttons to step through it carefully to be sure you understand how if statements work.
Fly
In this problem, Bit starts in this world:
Bit is flying around and follows these rules:
when Bit finds a blue square, it turns left.
when Bit finds a green square, it turns right.
when Bit finds a red square, it stops.
Planning
How would you turn these rules into a flow chart?
Here is one way to do this:
The import thing to recognize here is that the main function checks whether the current square is red. This is because of the final rule listed above — when Bit finds a red square, it stops. Instead of moving while the front is clear, we move while the current square is not red.
We are again using the event stream pattern, with a main function that moves forward and a helper function that turns as needed.
Coding
Can you turn this into code?
Notice that the main function moves while the current square is not red. This is a signal that you need to use while not bit.is_on_red(). Here is the code:
content_copy
Copy
# Solution
from byubit import Bit


def maybe_turn(bit):
    if bit.is_on_blue():
        bit.turn_left()
    elif bit.is_on_green():
        bit.turn_right()


@Bit.worlds('fly')
def run(bit):
    while not bit.is_on_red():
        bit.move()
        maybe_turn(bit)


if __name__ == '__main__':
    run(Bit.new_bit)
The if statement uses elif but does not need an else.
We could have also written the maybe_turn() function as:
content_copy
Copy
def maybe_turn(bit):
    if bit.is_on_blue():
        bit.turn_left()
    if bit.is_on_green():
        bit.turn_right()
This works because Bit can never be on a square that is both blue and green at the same time.
We could also have reversed the bit.move() and the maybe_turn():
content_copy
Copy
def run(bit):
    while not bit.is_on_red():
        maybe_turn(bit)
        bit.move()
The solution works whether Bit moves and then turns, or if Bit turns and then moves. This works because Bit does not start on a square that is blue or green. If it did, then you would want to check for a turn before moving.
Run the code above and use the buttons to be sure you understand how and why it works.
Possible bugs
Try adding these bugs to the code above to see what happens:
In the main function, go forward while the front is clear.
In the maybe_turn() function, turn right on blue and left on green.
In the maybe_turn() function, use else instead of elif.
In each case, step through the code with First and Next to observe what happens.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with event streams
These problems will give you a chance to practice using event streams to solve problems. The idea behind this pattern is that we use a while loop to move through the world, and then inside the while loop we use an if statement to modify the world, depending on some conditions:
content_copy
Copy
while keep_moving(bit):
    if some_condition(bit):
        do_something(bit)
    elif some_other_condition(bit):
        do_another_thing(bit)
    else:
        do_the_default_thing(bit)
As you work on these problems, remember to:
Draw out your solution.
Break your solution into multiple pieces, with each one being a function.
Write and test one function as a time.
As you write a function, define the stopping conditions and use the event stream pattern.
Use glue code in between functions as needed.
When you are debugging, you can use bit.snapshot() to capture what the world looks like at that point, and then use buttons to jump to snapshots.
Download the zip file above and put it in your bit folder.
Hurdles
Video Transcript
For this problem, Bit needs to jump hurdles. Here is an example world:
To complete the task, Bit needs to walk over each hurdle, with its path painted in green:
Be aware! There is a second world that looks like this:
and the finish looks like this:
This makes solving the problem a little tricky! Bit might start at a hurdle and there may not be much space between hurdles.
Planning
Draw out a solution to this problem. Think about how you would get Bit to move forward and walk any hurdles it encounters. What keeps Bit moving forward? What events should it handle as it moves forward?
One example of what you could draw:
This drawing is saying that there are these steps:
move and paint until Bit gets to a hurdle
if left is clear, go over the hurdle
keep going until the front and left are blocked (or keep going while the front or left is clear)
In this solution, we assume there are hurdles, so we think of the solution as: move to a hurdle, go over a hurdle, and then keep doing that. In this case, we can tell Bit to keep moving or jumping hurdles as long as the front or the left is clear.
This kind of solution can work, but it is quite a bit more work to program correctly. A better way to think about it is to use the event stream pattern:
while the left is clear:
if the front is clear:
move and paint
else
go over the hurdle
In this solution, Bit keeps moving or jumping hurdles as long as the left is clear. Then inside the loop Bit moves and paints if the front is clear, otherwise (the front is not clear) it jumps over a hurdle.
The key is recognizing that Bit keeps moving as long as the left is clear (since the front won’t always be clear). Each of the worlds has the left blocked at the end.
Starting to code
Let’s turn the second drawing into some code. In the zip file above you will find hurdles.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('hurdles', 'more-hurdles')
def run(bit):
    # Write code here
    pass


if __name__ == '__main__':
    run(Bit.new_bit)
In the run function, we can write the event stream:
content_copy
Copy
def run(bit):
    bit.paint('green')
    while bit.can_move_left():
        if bit.can_move_front():
            bit.move()
            bit.paint('green')
        else:
            go_over_hurdle(bit)
Write an empty go_over_hurdle() function:
content_copy
Copy
def go_over_hurdle(bit):
    pass
Run this code and see how we are doing so far:
Do not be discouraged! In this case, Bit gets into an infinite loop. This is because we told Bit to keep moving as long as the left is free, but left out going over hurdles. So Bit gets to a hurdle and does nothing, but the left is still free.
Here is the second world:
Not much is happening in the second world because Bit starts at a hurdle. But we did paint the first square green. :-)
Going over a hurdle
Now let’s do the part where Bit goes over a hurdle. It helps to again think of this as an event stream:
If we turn Bit left, then what is the stopping condition? We want to keep going as long as the front is clear. As we are doing this, if the right is clear, then Bit should turn right.
content_copy
Copy
def go_over_hurdle(bit):
    # turn left
    bit.turn_left()
    # an event stream for the hurdle
    while bit.can_move_front():
        bit.move()
        bit.paint('green')
        if bit.can_move_right():
            bit.turn_right()

    # turn left again
    bit.turn_left()
Run this code now and see if we can make it over the hurdles:
Excellent!
Let’s also check that it solves the second world:
Stupendous!
Elevators
Video Transcript
In this problem, Bit needs to take a series of elevators. The world looks like this:
The floors are in black and the elevators are represented with green. Bit travels from right to left and, when it meets an elevator, goes up to the next floor. At the end, the world should look like this:
Planning
Draw out a solution to this problem. What steps does Bit need to take? What is the stopping condition?
Here is one way to draw this out:
while the front is clear
move forward
if the square is green
go up
Writing the code
Let’s turn this drawing into some code. In the zip file above you will find elevators.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('elevators')
def run(bit):
    # Write code here
    pass


if __name__ == '__main__':
    run(Bit.new_bit)
We can put the main loop for the event stream pattern into the run() function:
content_copy
Copy
def run(bit):
    while bit.can_move_front():
        bit.move()
        if bit.is_on_green():
            go_up(bit)
We can then define go_up():
content_copy
Copy
def go_up(bit):
    # turn right
    bit.turn_right()
    # go up the elevator
    while bit.can_move_left():
        bit.move()
        bit.paint('green')

    # go above the floor and then turn left
    bit.move()
    bit.turn_left()
If we run this code, here is what happens:
Nice! Use the buttons to step through the code to be sure you understand how it works.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Return
So far we have been calling functions and not expecting anything back. For example, when we define and call a function called paint_green():
content_copy
Copy
def paint_green(bit):
    while bit.can_move_front():
        bit.paint('green')


@Bit.empty_world(5, 3)
def go(bit):
    paint_green(bit)
We are essentially saying “run the paint_green() function”, without expecting anything back:
Functions can all return values back to the place where they were called:
content_copy
Copy
def keep_going(bit):
    if bit.is_on_blue():
        return False

    else:
        return True


@Bit.empty_world(5, 3)
def go(bit):
    while keep_going(bit):
        bit.move()
Here, the code is saying, “run the keep_going() function, and give me back either True or False”:
TO return a value from a function, use the return statement. The value after return is sent to the place where you called the function. For now, we will be using return True and return False, and we will show you additional examples later.
Example
Let’s see return in action. In this problem, Bit tries to follow a straight, blue trail:
Sometimes the trail is longer:
Download the zip file linked above and store it in your bit folder. Find the file called blue_trail:
content_copy
Copy
from byubit import Bit


def keep_going(bit):
    if not bit.can_move_front():
        return False

    elif not bit.is_on_blue():
        return False

    else:
        return True


@Bit.worlds('blue-trail', 'blue-trail2')
def run(bit):
    while keep_going(bit):
        bit.move()


if __name__ == '__main__':
    run(Bit.new_bit)
The keep_going() function returns False if (a) Bit is not clear in front or (b) the current square is not blue. It returns True in all other cases.
Run this code and step through it with the buttons to understand how it works.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Combining Conditions
Let’s go back to the blue trail problem:
What we want here is for Bit to keep going if:
the front is clear, and
the current square is blue
In another situation, we may want Bit to paint a square blue if:
the current square is red, or
the current square is green
Notice that we are combining conditions using the word and or the word or. We can do this in Python!
and
When we use the keyword and to combine conditions, Python makes the following decision:
first condition second condition result
True True True
True False False
False True False
False False False
In other words, the combination of two conditions with and means the result is True only if both of them are True. The combination is False if either one of the conditions is False.
If we want to keep going if the front is clear and the current square is blue, we could write a function like this:
content_copy
Copy
def should_keep_going(bit):
    if bit.can_move_front() and bit.is_on_blue():
        return True
    else:
        return False
These are the two conditions we are combining with and:
Shortcut
We can rewrite the above function using a shorter version:
content_copy
Copy
def should_keep_going(bit):
    return bit.can_move_front() and bit.is_on_blue():
Any time bit.can_move_front() and bit.is_on_blue() are both true, then this function will return True. Otherwise, it will return False. This is the same as the longer version above!
Example
Let’s see this in action. Download the zip file linked above and store it in your bit folder. Find the file called blue_trail.py:
content_copy
Copy
from byubit import Bit


def should_keep_going(bit):
    return bit.can_move_front() and bit.is_on_blue()


@Bit.worlds('blue_trail', 'blue_trail2')
def go(bit):
    while should_keep_going(bit):
        bit.move()


if __name__ == '__main__':
    go(Bit.new_bit)
Run this code and you should verify it works the same as the longer version we wrote in the guide for return.
or
When we use the keyword or to combine conditions, Python makes the following decision:
first condition second condition result
True True True
True False True
False True True
False False False
In other words, the combination of two conditions with or means the result is True only if either of them is True. The combination is False only if both of the conditions are False.
If we want to paint a square blue if it is red or green, we could write a function like this:
content_copy
Copy
def should_be_blue(bit):
    return bit.is_on_red() or bit.is_on_green()
Notice that we are using a shortcut, with just a single return statement. This will return True if either the current square is red or if the current square is green.
Example
Here is a Bit world with some red and green squares:
Bit’s job is to paint a square blue if it is currently red or green. You can see code to do this by opening red-or-green.py:
content_copy
Copy
from byubit import Bit


def should_be_blue(bit):
    return bit.is_on_red() or bit.is_on_green()


@Bit.worlds('red-or-green')
def go(bit):
    while bit.can_move_front():
        bit.move()
        if should_be_blue(bit):
            bit.paint('blue')


if __name__ == '__main__':
    go(Bit.new_bit)
Run this code and step through it to see how it works. It finishes with this world:
Crossing the pond
Let’s look at an example that adds not to go with and and or. Here is Bit’s world for this problem:
The green squares above blue are lily pads. They don’t jump away as Bit passes by.
The red squares above black are flowers. They don’t jump either.
The green squares above black are frogs. They will jump if Bit passes by.
We want to move Bit to the other side of the pond, making frogs jump away.
The ending world should look like this:
In this problem, Bit needs to decide if the square it is on is a frog. Look at the rules above. We can’t just say a square is a frog if it is green, because some green squares are lily pads. A squares is a frog if it is green and the square below it is black. That means we could write this function:
content_copy
Copy
def is_frog(bit):
    """Square is a frog if it is green and above a black square"""
    return bit.is_on_green() and not bit.can_move_right()
We use bit.is_on_green() and not bit.can_move_right() to get the right condition. Notice it uses and not together.
To see this in action, open the file called cross_the_pond.py:
content_copy
Copy
from byubit import Bit


def is_frog(bit):
    """Square is a frog if it is green and above a black square"""
    return bit.is_on_green() and not bit.can_move_right()


@Bit.worlds('frog-on-rock')
def go(bit):
    while bit.can_move_front():
        bit.move()
        if is_frog(bit):
            bit.paint('white')


if __name__ == '__main__':
    go(Bit.new_bit)
Bit moves forward and if the current square is a frog, we erase that square, to indicate the frog has jumped away. We have put the logic for checking if the square represents a frog into the is_frog() function.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with conditions
These problems will give you a chance to practice using if statements with conditions that include and, or, and not. Use the event stream pattern, and think carefully about what conditions you need.
Download the zip file above and put it in your bit folder.
Freedom
For this problem, Bit starts in this world:
Can you move Bit to the first space open on both sides? This is how the world should look when it is done:
You can find some starter code in freedom.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('freedom')
def go(bit):
    # Write code here
    pass


if __name__ == '__main__':
    go(Bit.new_bit)
Planning
When should Bit stop? What is the condition you would use? Express this in words, not Python code.
There are two ways to think of this:
Bit should move until the left is clear and the right is clear.
Bit should move if the left is not clear or the right is not clear.
Solution #1
Let’s start by looking at how the first solution would work — Bit should move until the left is clear and the right is clear.
You can write this with the following functions:
content_copy
Copy
def found_freedom(bit):
    return bit.can_move_left() and bit.can_move_right()


@Bit.worlds('freedom')
def go(bit):
    while not found_freedom(bit):
        bit.move()
We have put the stopping condition the left is clear and the right is clear into a function called found_freedom() that returns True if those conditions are met.
Then in go() Bit keeps moving while not found_fredom(bit). In other words, Bit has to keep moving while the condition is not met.
Add this to your code and run it to see it working!
Solution #2
Let’s now write code so that we follow the second suggestion, Bit should move if the left is not clear or the right is not clear. You can write this with the following functions:
content_copy
Copy
def keep_moving(bit):
    return not bit.can_move_left() or not bit.can_move_right()


@Bit.worlds('freedom')
def go(bit):
    while keep_moving(bit):
        bit.move()
Here, instead of a stopping condition we have keep moving condition. We write this in the function keep_moving() that returns True if either the left is not clear or the right is not clear.
Then in go() Bit keeps moving while keep_moving(bit). In other words, Bit keeps moving while the condition is met.
Add this to your code and run it to see it working!
Spiral
Video Transcript
For this problem, Bit starts in this world:
Can you move Bit in the shape of a spiral? This is how the world should look when it is done:
You can find some starter code in spiral.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('spiral')
def run(bit):
    pass


if __name__ == '__main__':
    run(Bit.new_bit)
Planning
This problem looks more complex, but it can be simple if you focus on conditions. When should Bit stop? When should it turn left?
An important thing to notice is that the spiral stops when Bit reaches a square where the front and the left are not clear.
The stopping condition for Bit is if the front is not clear and the left is not clear.
Bit should keep moving forward when it can, but turn left if the front is blocked.
Solution
Here is one way to write these conditions:
content_copy
Copy
def end_of_spiral(bit):
    return not bit.can_move_front() and not bit.can_move_left()


@Bit.worlds('spiral')
def run(bit):
    bit.paint('blue')
    while not end_of_spiral(bit):
        if not bit.can_move_front():
            bit.turn_left()
        bit.move()
        bit.paint('blue')
We use the end_of_spiral() function to have the stopping condition. It stops if the front is not clear or the left is not clear.
We use the run() function to keep Bit moving and painting blue. We use while not end_of_spiral(bit) to keep Bit moving unless the stopping condition is met. Along the way, if the front is ever not clear, Bit turns left.
Notice that we also need an extra bit.paint('blue') to get the first square.
An alternate solution
It’s important to recognize that there are multiple solutions to many problems! For example, you could instead write conditions like this:
Bit moves as long as the front is clear
If the front is ever not clear, Bit turns left.
Notice that if both the front and left are not clear, Bit will turn left, and then the front will be blocked. We need to be sure Bit doesn’t turn left again! That makes this solution a little more tricky to write.
Here is one way to do it:
content_copy
Copy
@Bit.worlds('spiral')
def run(bit):
    while bit.can_move_front():
        bit.paint('blue')
        bit.move()
        if not bit.can_move_front():
            bit.turn_left()

    bit.paint('blue')
Notice a few things that are different from the first solution. Bit needs to paint first, then move. At this point, if the front is not clear, Bit turns left. This way Bit can keep moving forward as long as the front is clear. But if it turns left and the front is blocked, it will stop and not turn again. Finally, we have to be sure the last square is painted blue, since Bit paints before it moves.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Decomposition
We are going to spend some more time working on problems that require decomposition, which is the process of breaking a larger problem into smaller pieces.
Part of decomposition involves abstraction, meaning defining functions that can perform a particular job. When we define a function, we want to identify the following:
purpose — the purpose of the function
boundary conditions — what is happening before the function is called and after a function is called
interface — the way that your program calls the function — what parameters it gives it (if any)
Treasure
Video Transcript
To practice these concepts, let’s examine the following problem. Bit needs to find the treasure! Here is the map:
To reach the cave, Bit should:
Turn right on blue squares.
Turn left on red squares.
Once in the cave, Bit should navigate through the passage to the treasure, turning left or right as needed to reach the red square.
Planning
Work with a friend to draw this out and think about what steps you would use to solve it.
Here is one way to think about this:
Notice how there are two steps, and each step uses an event stream pattern.
Getting started
The starter code is in the zip file above, in treasure.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('treasure')
def go(bit):
    # Write code here
    pass


if __name__ == '__main__':
    go(Bit.new_bit)
We can fill in the run() function with our basic plan:
content_copy
Copy
def go(bit):
    get_to_cave(bit)
    find_treasure(bit)
Be sure to define these functions with pass:
content_copy
Copy
def get_to_cave(bit):
    pass


def find_treasure(bit):
    pass
Getting to the cave
(1) How does Bit get to the cave?
Bit should keep moving forward, turning left on red, right on blue.
(2) How does Bit know when it gets to the cave?
Bit reaches the cave when the left is not clear and the right is not clear.
Now that these are clearly defined, we can write several functions to get to the cave.
First, we will write a function to follow the turn instructions:
content_copy
Copy
def follow_turn_instructions(bit):
    """ Follow the rules for turning while navigating to the cave.
        Turn left on red, right on blue.
    """
    if bit.is_on_red():
        bit.turn_left()
    elif bit.is_on_blue():
        bit.turn_right()
This is pretty simple! It just encodes the instructions we were given to follow the directions to the cave.
Next, we will write a function to know when to stop:
content_copy
Copy
def in_cave(bit):
    """ Return true if in the cave, otherwise false. """
    return not bit.can_move_left() and not bit.can_move_right()
It can help to have a function like this because then our code that goes to the cave can just say while not in_cave(bit).
Finally, we can write the get_to_cave() function:
content_copy
Copy
def get_to_cave(bit):
    """
    Bit ends just inside the cave (black on left and right)
    To get there, Bit must turn right on blue and left on red.
    """
    bit.paint('green')
    while not in_cave(bit):
        bit.move()
        follow_turn_instructions(bit)
        bit.paint('green')
Notice how simple this code is and how easy it is to read! This is the beauty of writing some helper functions.
This code follows the event stream pattern. See the definition of this pattern at the top of the page. In this pattern, we have a while loop, and then inside the while loop use if to make choices.
Finally, do be sure to paint after Bit follows the turning instructions! Otherwise, Bit will paint the red and blue squares green before using them to turn.
Let’s run the code to see how this works:
Be sure to step through the code using the buttons so you can see how this works.
Finding the treasure
Now we can write the finding_the_treasure() function.
(1) How does Bit get to the treasure?
Go forward, and if the front is blocked, turn left if it is clear on the left, or right if it is clear on the right.
(2) When does Bit know it has reached the treasure?
When it is on a red square.
Ok, let’s write a function to handle the first part:
content_copy
Copy
def turn_to_clear(bit):
    """If left is clear, turn left, otherwise turn right."""
    if bit.can_move_left():
        bit.turn_left()
    else:
        bit.turn_right()
This function turns Bit toward whichever direction is clear.
Now we can write a function for finding the treasure:
content_copy
Copy
def find_treasure(bit):
    """Bit ends at the treasure (red square). If the front is blocked, turn in the direction that is clear."""
    while not bit.is_on_red():
        if not bit.can_move_front():
            turn_to_clear(bit)
        bit.paint('green')
        bit.move()

    bit.paint('green')
Bit keeps moving as long as it is not on a red square. It turns as needed, and otherwise keeps moving and painting.
How does this work?
Good job!
Hiking
Let’s do one more problem. In this problem, Bit wants to hike over a mountain:
Mountains can have different shapes:
Part of the decomposition process is understanding what the different examples have in commmon. We will continue to focus on the event stream pattern as a way of decomposing these problems.
When Bit hikes over a mountain, it plants a tree over every place where there is ground underneath it:
Planning
This is a tricky problem! Work with a friend to draw this out and think about what steps you would use to solve it.
Here is one way to think about this problem:
break the problem into going up and going down
to go up, move forward as long as the right is clear
if the front is blocked, jump up the ledge
to go down, move forward as long as the front is clear
if the right is clear, jump down the ledge
The key to this problem is to recognize it is hard to have a single event stream that covers the entire problem. When you are going up, you need to watch for when the front is blocked and “jump up” a ledge. But when you are going down, you need to watch for when the right is empty and “jump down” a ledge.
Getting started
The starter code is in the zip file above, in hike.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('y-mountain', 'mountain')
def run(bit):
    # Write code here
    pass


if __name__ == '__main__':
    run(Bit.new_bit)
We can fill in the run() function with our basic plan:
content_copy
Copy
def run(bit):
    go_up(bit)
    go_down(bit)
Be sure to define these functions with pass:
content_copy
Copy
def go_up(bit):
    pass


def go_down(bit):
    pass
Going up
Let’s start by going up. In run() we can call a function to go up as if it exists:
content_copy
Copy
def run(bit):
    go_up(bit)
Then we can write the go_up() function:
content_copy
Copy
def go_up(bit):
    """ Get Bit to the top of the mountain.

        Bit ends at the top of the mountain facing right,
        with an empty square to his right.

        Bit paints green all the squares immediately above a black square.
    """
    while not bit.can_move_right():
        if not bit.can_move_front():
            jump_up(bit)
        bit.move()
The key to this function is getting the stopping condition right. When are we at the top of the mountain? When we reach a ledge that goes down, so it is clear on the right. This means we can use while not bit.can_move_right() as our stopping condition.
Another important thing is to have a separate function for jump_up() whenever we reach a ledge and need to go up. We don’t know how high this ledge is and how many steps this will take, so it works well to write a separate function for jump_up():
content_copy
Copy
def jump_up(bit):
    """ Jump up the ledge.
        Start facing the wall at the bottom of the ledge.
        End at the top, facing right, with an empty square underneath
        (Bit is not "on" the ledge yet)
    """
    bit.turn_left()
    while not bit.can_move_right():
        bit.move()

    bit.turn_right()
Notice how this needs its own logic — turn left, then move as long as the right is clear, then turn right. You could put this in the go_up() function, but if you find yourself with nested while loops, that is a good reason to make a separate function.
Notice also that when Bit goes up a ledge it has the right clear. This is the stopping condition for going up the mountain in go_up()! So this is another good reason to have a separate function for jumping up, so you don’t confuse the logic with knowing when you are at the top of the mountain.
Let’s run what we have so far:
OK, not bad! Bit has made it up the mountain to exactly the place we want it to be — right over the first ledge going down. But we haven’t planted any trees. Let’s do that next.
Planting trees
To plant trees, we need a function:
content_copy
Copy
def plant_a_tree(bit):
    """ If the square below is black, plant a tree. """
    if not bit.can_move_right():
        bit.paint('green')
This will plant a tree if there is ground underneath Bit — it is not clear. Having a separate function is wise because we will also need it when Bit goes down.
We can call this function inside the go_up() function:
content_copy
Copy
def go_up(bit):
    """ Get Bit to the top of the mountain.

        Bit ends at the top of the mountain facing right,
        with an empty square to his right.

        Bit paints green all the squares immediately above a black square.
    """
    plant_a_tree(bit)
    while not bit.can_move_right():
        if not bit.can_move_front():
            jump_up(bit)
        bit.move()
        plant_a_tree(bit)
Note that we don’t need to call it inside jump_up() because there is never ground underneath Bit when it jumps up.
Let’s try that:
Nice!
Going down
Now we can write go_down():
content_copy
Copy
def go_down(bit):
    """ Bit starts at the top of the mountain (facing right,
        empty space beneath) and descends to the right,
        ending in the corner.
    """
    while bit.can_move_front():
        if bit.can_move_right():
            jump_down(bit)
        bit.move()
We want to do something similar as going up, except Bit keeps moving while the front is clear. Then, any time it is over an edge, we tell Bit to jump down.
Jumping down is similar to jumping up, but Bit moves while the front is clear.
content_copy
Copy
def jump_down(bit):
    """ Bit starts facing right with empty beneath,
        and ends facing right with black beneath.
    """
    bit.turn_right()
    while bit.can_move_front():
        bit.move()

    bit.turn_left()
Let’s see how this works:
OK, we just need to plant trees again!
Planting trees (again)
Where should we call plant_a_tree()? Let’s try what we did when going up, planting a tree after Bit moves:
content_copy
Copy
def go_down(bit):
    """ Bit starts at the top of the mountain (facing right,
        empty space beneath) and descends to the right,
        ending in the corner.
    """
    while bit.can_move_front():
        if bit.can_move_right():
            jump_down(bit)
        bit.move()
        plant_a_tree(bit)
Let’s run this:
Oops! Bit is planting trees but skipping some spots. Use the buttons to see if you can figure out why.
When Bit comes down off a ledge, it moves and then paints, so it is missing trees right at its landing spot. We can fix this by planting before moving:
content_copy
Copy
def go_down(bit):
    """ Bit starts at the top of the mountain (facing right,
        empty space beneath) and descends to the right,
        ending in the corner.
    """
    while bit.can_move_front():
        if bit.can_move_right():
            jump_down(bit)

        plant_a_tree(bit)
        bit.move()

    plant_a_tree(bit)
That means we also need a final plant_a_tree() at the end to get the last square.
If we run this:
Hooray! Problem solved! And it works for the other world too:
Hiking — A different solution
In one section of the class, a student came up with a novel way of solving the hiking problem. Essentially, his solution was:
pretend Bit is a helicopter
at the top of the screen, fly from left to right
in each column, fly down and plant a tree, then go back up
Here is how that solution looks:
content_copy
Copy
from byubit import Bit


def move_to_top(bit):
    # move to the top of the world
    # assume Bit is at the bottom of a column, facing right
    # Bit finishes at the top of the same column, facing right
    bit.turn_left()
    while bit.can_move_front():
        bit.move()
    bit.turn_right()


def drop_a_tree(bit):
    # drop a tree at the bottom of this column
    # assume Bit is at the top of a column, facing right
    # Bit moves all the way down and puts a green square at that point
    # Bit returns to the top of the same column, and ends facing right
    bit.turn_right()
    while bit.can_move_front():
        bit.move()
    bit.paint('green')
    bit.turn_left()
    move_to_top(bit)


@Bit.worlds('y-mountain', 'mountain')
def run(bit):
    # move across all the rows, first moving to the top,
    # then dropping a tree and returning to the top
    while bit.can_move_front():
        move_to_top(bit)
        drop_a_tree(bit)
        bit.move()


if __name__ == '__main__':
    run(Bit.new_bit)
Notice how when you think about a problem differently, it can open up a totally different solution, which might be quite a bit easier than your original way of looking at the problem!
Do yourself a favor
Try to write code like this! It will bless your life! :-)
Plan a problem out in advance, with a drawing and/or a flow chart.
Decompose the problem into multiple functions, each one doing one thing.
Work through each function carefully, and one or a few at a time. Test as you go.
Write clear comments to document each function.
Photo by Priscilla Du Preez on Unsplash

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Variables
Consider the following code:
content_copy
Copy
def paint_green(bit):
    while bit.can_move_front():
        bit.move()
        bit.paint('green')
This tells Bit to keep moving and painting green as long as the front is clear. So Bit will paint an entire row or column green, depending on which direction it is facing.
But what if we also want to paint rows and columns red? And yellow and green and brown and blue?
We would need to write a separate function for each one! Not great!
Functions can have multiple parameters
Never fear, it turns out that functions can take multiple parameters:
content_copy
Copy
def go(bit, color):
    """ Given a bit and a color, move and paint that color until blocked """
    while bit.can_move_front():
        bit.move()
        bit.paint(color)
The go() function takes two parameters:
a Bit
a color
Inside the go() function, the variable called bit is equal to the Bit, and the variable called color is equal to whatever color you give it. You can see this in action using the file called go_color.py in the zip file above:
content_copy
Copy
from byubit import Bit


def go(bit, color):
    """ Given a bit and a color, move and paint that color until blocked """
    while bit.can_move_front():
        bit.move()
        bit.paint(color)


@Bit.empty_world(5, 3)
def lots_of_paint(bit):
    """ Paint colors until blocked """
    go(bit, 'red')
    bit.turn_left()
    go(bit, 'green')
    bit.turn_left()
    go(bit, 'blue')


if __name__ == '__main__':
    lots_of_paint(Bit.new_bit)
Bit starts in an empty 5x3 world. It does the following:
paints a row red
turns left
paints a row green
turns left
paints a row blue
The result is this world:
Parameters become variables in a function
To see how parameters to a function work, look at this diagram:
The first time this code calls go(), it uses 'red' as the second parameter. This means that inside the go() function, there is a variable called color that is equal to the string 'red'.
The second time this code calls go(), we have this situation:
This time, the code uses 'green' as the second parameter. This means that inside the go() function, the variable called color is equal to the string 'green'.
Notice that we use the notation color → 'red' and color → 'green' in this pictures. This indicates that a variable has a name (color) and it references a value (‘red’ or ‘green’). The value of a variable can change over time.
Changing the value of a variable
You can change the value of a variable any time using this syntax:
content_copy
Copy
my_color = 'red'
Here, the variable is called my_color and its value is 'red'. Using our notation, my_color → 'red'.
Then you can call functions using this variable:
content_copy
Copy
my_color = 'red'
go(bit, my_color)
my_color = 'blue'
go(bit, my_color)
The first time, my_color → 'red' and so inside go(), color → 'red'.
The second time, the value of my_color changes, so now my_color → 'blue' and inside go(), color → 'blue'.
Painting with different colors
You can see this in action with the file called color_variables.py in the zip file above:
content_copy
Copy
from byubit import Bit


def paint_two(bit, color):
    bit.paint(color)
    bit.move()
    bit.paint(color)


def paint_three(bit, color):
    paint_two(bit, color)
    bit.move()
    bit.paint(color)


@Bit.empty_world(5, 3)
def run(bit):
    first_color = 'red'
    second_color = 'blue'

    paint_two(bit, first_color)
    bit.move()
    paint_three(bit, second_color)

    bit.turn_left()
    bit.move()
    bit.turn_left()

    paint_two(bit, second_color)
    bit.move()
    paint_three(bit, first_color)


if __name__ == '__main__':
    run(Bit.new_bit)
Here we have a function called paint_two(bit, color) that takes two parameters, a bit and a color. It does this:
paint the color
move
paint the color
We have another function called paint_three(bit, color) that takes the same two parameters. It does this:
call paint_two()
move
paint the color
This allows it to paint three colors.
Finally, we have two variables: first_color → 'red' and second_color → 'blue'. We use these two variables when we call the functions, so that we can:
paint two blue squares (using first_color)
paint three red squares (using second_color)
turn around and go to the next row up
paint two red squares (using second_color)
paint two blue squares (using first_color)
Run this code and see the result:
Getting the current color
Bit has a useful function called get_color() that lets you get the color of Bit’s current square so you can store it in a variable. For example:
content_copy
Copy
found_color = bit.get_color()
Consider the following problem. Bit is in a world with one color:
Bit’s job is to find out what color this is and then fill in the rest of the row with that same color:
But Bit doesn’t know what color it is going to have in that first square. It might be blue:
Look a the file called fill_a_color.py to see how to do this:
content_copy
Copy
from byubit import Bit


def go(bit, color):
    while bit.can_move_front():
        bit.move()
        bit.paint(color)


@Bit.worlds('color1', 'color2')
def fill_a_color(bit):
    found_color = bit.get_color()
    go(bit, found_color)


if __name__ == '__main__':
    fill_a_color(Bit.new_bit)
In fill_a_color(), Bit first gets the current color and stores it in a variable called found_color. It then uses found_color when it calls go().
Run this code and use the buttons to see that it solves both worlds. In the first world, bit.get_color() returns 'red', and so found_color → 'red'. In the second world, bit.get_color() returns 'blue', and so found_color → 'blue'.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with variables
These problems will help you practice with variables. Remember that we can define functions with two parameters:
content_copy
Copy
def go(bit, color):
    """ Given a bit and a color, move and paint that color until blocked """
    while bit.can_move_front():
        bit.move()
        bit.paint(color)
and then call them by passing in the parameters:
content_copy
Copy
go(bit, 'green')
We can also use variables to hold values:
content_copy
Copy
my_color = 'red'
and then pass those variables as parameters:
content_copy
Copy
my_color = 'red'
go(bit, my_color)
Finally, we can get the current color and store it in a variable:
content_copy
Copy
found_color = bit.get_color()
Coloring columns
In this problem, Bit needs to find the color for each column in the world:
and then fill these colors in the column above:
Planning
How would you solve this problem? Draw out your idea.
Here is a drawing showing one way to think about this problem:
while the front is clear
get the current color
fill the column
go back
Coding
You can see starter code for this problem in fill_colorful.py:
content_copy
Copy
from byubit import Bit


@Bit.worlds('colors')
def fill_colorful(bit):
    # Write code here
    pass


if __name__ == '__main__':
    fill_colorful(Bit.new_bit)
Let’s put the main loop in fill_colorful():
content_copy
Copy
def fill_colorful(bit):
    while bit.can_move_front():
        color = bit.get_color()
        fill_column(bit, color)
        go_back(bit)
        bit.move()
Then we can write fill_column():
content_copy
Copy
def fill_column(bit, color):
    """
    Fills a column with a given color. Bit starts facing right and ends
    facing up at the top of the column
    """
    bit.turn_left()
    while bit.can_move_front():
        bit.move()
        bit.paint(color)
and we can fill in pass for go_back():
content_copy
Copy
def go_back(bit):
    pass
Let’s see if we got the first part of this problem solved by running the code:
Pretty good!
Now we can fill in go_back():
content_copy
Copy
def go_back(bit):
    """
    Go back to the bottom and turn to the right.
    Bit starts by facing up at the top of the column.
    Bit ends by facing right at the bottom of the column.
    """
    # turn around
    bit.turn_right()
    bit.turn_right()
    # go back
    while bit.can_move_front():
        bit.move()
    # turn
    bit.turn_left()
Let’s run this code to see if we got the logic right to go back:
Nice. So all we need is to do the last column. We can do this by adding a few lines at the end of our main loop:
content_copy
Copy
def fill_colorful(bit):
    while bit.can_move_front():
        color = bit.get_color()
        fill_column(bit, color)
        go_back(bit)
        bit.move()

    # do the last column
    color = bit.get_color()
    fill_column(bit, color)
    go_back(bit)
Great!
A few notes
Once you start decomposing problems into multiple functions, you will see that there are lots of ways to solve problems. In this case, we could have put color = bit.get_color() into fill_column(). We also could have written a function fill_column_and_go_back() that called fill_column() and go_back().
Ultimately, how you choose to break down the problem depends on what you think makes your code easiest to read. Maybe this is easier:
content_copy
Copy
def fill_colorful(bit):
    while bit.can_move_front():
        fill_column_and_go_back(bit)
        bit.move()

    # do the last column
    fill_column_and_go_back(bit)
Coloring Ts
Video Transcript
In this problem, Bit starts in a world that provides colored squares:
Bit’s job is to get these colors, store them, erase them, and then draw three letter Ts with these colors:
The colors can be different! There is a second world that starts like this:
Planning
How would you solve this problem? Draw out your idea.
Here is a drawing showing one way to think about this problem:
get each color, store it in a variable, erasing as you go
go to the start
draw three Ts, one for each color
Coding
We have given you starter code in color_tt.py that provides much of the code you need:
content_copy
Copy
from byubit import Bit


def go(bit):
    """Go until blocked in front."""
    while bit.can_move_front():
        bit.move()


def go_to_start(bit):
    """Bit starts anywhere on the board and ends in the bottom left corner facing right."""
    bit.turn_left()
    bit.turn_left()
    go(bit)
    bit.turn_left()
    go(bit)
    bit.turn_left()


def paint_t(bit, color):
    """Paint a T. Start in the bottom left of the 3x3 box. End just outside the bottom right of the 3x3 box."""
    bit.move()
    bit.turn_left()
    bit.paint(color)
    bit.move()
    bit.paint(color)
    bit.move()
    bit.turn_left()
    bit.move()
    bit.turn_left()
    bit.turn_left()
    bit.paint(color)
    bit.move()
    bit.paint(color)
    bit.move()
    bit.paint(color)
    bit.turn_right()
    bit.move()
    bit.move()
    bit.turn_left()
    bit.move()
    bit.snapshot('T painted')


@Bit.worlds('color_tt', 'color_tt2')
def run(bit):
    pass


if __name__ == '__main__':
    run(Bit.new_bit)
All you need is to fill in the piece of this that collects and erases the colors, then calls the other functions. We can get one of the colors like this:
content_copy
Copy
def run(bit):
    # Get colors
    first_color = bit.get_color()
    bit.paint('white')
    bit.move()
Now just repeat to get all three:
content_copy
Copy
def run(bit):
    # Get colors
    first_color = bit.get_color()
    bit.paint('white')
    bit.move()

    second_color = bit.get_color()
    bit.paint('white')
    bit.move()

    third_color = bit.get_color()
    bit.paint('white')
    bit.move()
Then call the other functions we provided:
content_copy
Copy
def run(bit):
    # Get colors
    first_color = bit.get_color()
    bit.paint('white')
    bit.move()

    second_color = bit.get_color()
    bit.paint('white')
    bit.move()

    third_color = bit.get_color()
    bit.paint('white')
    bit.move()
    bit.snapshot('Got colors')

    go_to_start(bit)
    bit.snapshot('At start')

    paint_t(bit, first_color)
    paint_t(bit, second_color)
    paint_t(bit, third_color)
We have added bit.snapshot() so that you can easily step through the code and see how it works.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Interactive programs
In this unit you will be learning how to create interactive programs, meaning programs that interact with the person that is running them. Any time you interact with a program, you need both input and output. Input means that you are providing data or commands to a program. You can provide input in many ways:
typing on a laptop keyboard
drawing on a tablet
recording a podcast using a microphone
Photos by Everyday basics on Unsplash, Kelly Sikkema on Unsplash, and Christin Hume on Unsplash
When the program responds, it typically provides you with output, showing what it did for you. Following the examples above, this could be:
putting the text you type into an email
showing you a drawing based on the strokes you made
showing a soundwave that contains your interview with a guest
Everything you do on your phone is a series of you providing input (by tapping or speaking) and the phone providing output (by displaying on the screen or talking back to you).
To keep things simple, we will start with programs that only use the keyboard for input and your screen for output.
As you go through this unit, create a folder in your cs110 project called unit3. You can put all your programs there.
Print
You can provide output for your program using the print() command. To use print, you give it a string that you would like to print:
content_copy
Copy
print('Hello world!')
To see this in action, create a file in your unit3 project called printing.py. Type in this program:
content_copy
Copy
if __name__ == '__main__':
    print("Hello world!")
When you run this program, PyCharm will open a Window at the bottom to show you the output:
A few things to notice, from top top bottom:
First, the window shows you that PyCharm ran your program. In my case, it says it ran python3.11 on the printing.py program. Remember, every file in your file system has a path. In my case, the path to python3.11 is /Users/zappala/.virtualenvs/cs110/bin/python3.11 and the path to printing.py is /Users/zappala/cs110/unit3/printing.py
Next, the window shows you Hello world!, the string that you asked it to print. Python has printed this to your screen.
Below that, the window shows Process finished with exit code 0, which is normal. This means your program finished without causing any errors. You will see errors here if your program doesn’t operate correctly.
There is a series of tabs at the bottom, and you are in the Run tab. This is where Python will show you the output of running your program.
The print() command will actually allow you to give it multiple strings to print. Modify your program so it reads:
content_copy
Copy
if __name__ == '__main__':
    print("Hello world!")
    print("Hello", "world!")
    print('Hello', 'world', 'out', 'there!')
When you run this, it shows:
content_copy
Copy
Hello world!
Hello world!
Hello world out there!
The first line comes from print("Hello world!"). Python prints out the string.
The second line comes from print("Hello", "world!"). Python prints out the first string, then a space, then the second string.
The third line comes from print('Hello', 'world', 'out', 'there!'). Python prints out all of the strings you provide, separated by spaces.
Input
You can provide input to your program using the input() command. You provide input with a string to use for a prompt:
content_copy
Copy
name = input('Enter your name: ')
Python will print this prompt on the screen and then wait for the person running the program to type a response. When the person ends a line with the enter key, then Python returns their response. In the line shown above, we store the response in the variable called name.
To see this in action, create a file in your unit3 project called inputting.py. Type in this program:
content_copy
Copy
if __name__ == '__main__':
    name = input('Enter your name: ')
    print('Your name is', name)
When you run this, it shows:
content_copy
Copy
Enter your name:
Type whatever name you want:
content_copy
Copy
Enter your name: Kermit
Your name is Kermit
You can see that the print() statement prints both Your name is and the name that you type, which is stored in the variable called name.
Formatted strings
Often when we print strings, we want to print a variable mixed with other strings. When you print as above:
content_copy
Copy
print('Your name is', name)
you are somewhat limited in what you can do. A more powerful way to print is to use a formatted string:
content_copy
Copy
if __name__ == '__main__':
    name = input('Enter your name: ')
    pizza = input('Enter your favorite pizza: ')
    message = f'{name} likes {pizza} pizza!'
    print(message)
A formatted string begins with f and then has a string in quotes. Inside the string, you can use variables by putting them inside of curly brackets {}.
The above program will:
ask the person running the program to enter their name, and store their answer in the variable called name
ask the person to enter their favorite pizza, and store their answer in the variable called pizza
create a variable called message that uses a formatted string, which contains <name> likes <pizza> pizza; this ends up containing something like ‘Kermit likes pepperoni pizza’ if the person types ‘Kermit’ and ‘pepperoni’
prints message
You can see this in action by changing your program in inputting.py to include the above code. Run it and you will see something like this:
Finally, you will notice we used a variable to hold the formatted string:
content_copy
Copy
message = f'{name} likes {pizza} pizza!'
print(message)
You don’t necessarily need a variable in this case. You could just write this code:
content_copy
Copy
print(f'{name} likes {pizza} pizza!')
We are just putting the formatted string directly into print(). This works just as well!
Return
When using input() it is helpful to write small functions that call input() and return the result. So let’s revisit return, which we saw earlier in unit 2.
Take a look at this small program:
content_copy
Copy
def give_me_two():
    return 2


if __name__ == '__main__':
    value = give_me_two()
    print(value)
Python will run the main block first.
The first line inside the main block says store the return value of the give_me_two() function in a variable called value.
At this point, Python will run the give_me_two() function, which returns the value 2.
Python will take this returned value, 2, and store it in the variable called value.
Python prints 2
You can put this program in a file called demonstrating_return.py and run it:
Now replace this program with the following:
content_copy
Copy
def get_name():
    return input('What is your name? ')


if __name__ == '__main__':
    value = get_name()
    print(value)
Notice that we have a very simple function, get_name() that just calls input, gets what the person types, and then returns it. The main block calls get_name() and prints value. Run this and you get:
Welcome to Wendy’s
OK, now that you understand print(), input(), formatted strings, and return, you’re ready to write an interactive program. Write a program that:
Welcomes a person to Wendy’s: Welcome to Wendy's!
Asks for the person’s name: What is your name?
Prompts the person for a sandwich type: What kind of sandwich do you want?
Prompts the person for sandwich additions: “What do you want on it? `
Prints out an order for the staff: <person> wants a <type> sandwich with <additions>!
See if you can write this program with a friend. We’ve given you everything in this guide that you need for this task! Write your code in the unit3 folder, in a file called wendys.py. Remember to use functions and return!
Here is one way to write this program:
content_copy
Copy
def get_name():
    return input("What is your name? ")


def get_sandwich():
    return input("What kind of sandwich do you want? ")


def get_additions():
    return input("What do you want on it? ")


def print_summary(name, sandwich, adds):
    print(f"{name} wants a {sandwich} sandwich with {adds}!")


def main():
    print("Welcome to Wendy's!")
    name = get_name()
    sandwich = get_sandwich()
    adds = get_additions()
    print_summary(name, sandwich, adds)


if __name__ == '__main__':
    main()
You will notice:
This solution is broken down into a bunch of functions, many of which use the return statement.
One of the functions, print_summary() takes three arguments — the name, the sandwich, and the additions, and then prints out a formatted string using these variables. You can write functions that take s many arguments as you want.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Using a debugger
Video Transcript
As you continue learning to program, you will write larger programs, composed of many functions. When something goes wrong and your program does not work as you expected, you should use a debugger to help you find and fix the error. PyCharm has a built-in debugger that we will show you how to use.
The two most important things you will learn from CS 110 that will help you throughout your career:

(1) Decomposing programs
(2) Using a debugger
A demo program
To learn how to use a debugger, we are going to work with the following program. Put this program into a file called debugger_demo.py in your unit3 folder:
content_copy
Copy
def get_name():
    name = input('Hello, what is your name? ')
    return name


def get_age():
    age = input('And what is your age? ')
    return age


def print_message(name, age):
    print(f'{age} years ago, {name} was born!')


def main():
    name = get_name()
    age = get_age()
    print_message(name, age)


if __name__ == '__main__':
    main()
Run this program and you should see something like this:
How does this program work? Python goes through the following steps:
runs the main block inside if __name__ == '__main__'
runs the main() function
runs the get_name() function, which returns a name that is stored in name
runs the get_age() function, which returns an age that is stored in age
runs the print_message() function, which uses name and age to print the message you see
The PyCharm debugger
To use the PyCharm debugger, you will want to create a breakpoint, which is a place to stop and examine your program. You can choose any line of code in your program and tell the debugger stop here, I want to see what is going on.
You create a breakpoint in PyCharm by clicking just to the right of a line number.
In your code, click next to line 16 to create a breakpoint. PyCharm shows the breakpoint as a red dot:
Now click the green triangle in the main block, like you would if you were going to run the program, but instead select Debug:
This will open the debugging window at the bottom of the screen:
Meanwhile, the main window shows that Python has run your program, but then stopped when it got to line 16:
The function stack
The debugger window shows you a stack of the functions your program is currently using. They are ordered from most recent on the top to oldest on the bottom:
The top function listed, main is the function your program is currently in, which is where we set the breakpoint.
Click on the bottom function listed, module:
and the top window will change to show you that this is where Python started running your code, on line 22:
Python ran your main block, executed line 22, and in doing that, saw that it needed to run main().
Now click main in the function stack, and you will back to main() on line 16.
Stepping over
In the debugging window, you will see some useful buttons on the top:
Click the step over button. This will execute line 16. You will see the function stack go blank, with a small yellow circle and arrow symbol by the Console tab:
Click on the Console tab, and you will see that that Python is in the middle of running line 16, which calls the get_name() function. That function uses input(), and the console is waiting for you to type something.
Type in a name and press enter. If you click back to the Debugger window, you will see whatever you typed is now stored in the name variable:
You will also see the main window has advanced and the debugger is now on line 17:
You will also see that the value of the name variable is shown to the right of line 16.
You can see literally everything that Python is doing when it runs your code! :-)
Stepping into
Now click the step into button in the debugger window.
This will run line 17 of your code. Line 17 tells Python to run the get_age() function. Since you clicked step into, PyCharm will take you to the first line of get_age(), which is line 7 of the code:
Python has not yet executed line 7. It is sitting there telling you that this is the next line of code it will execute.
Notice that the function stack in the debugger window shows that you are now in the get_age() function:
PyCharm has added a function to the top of the stack, to keep track of where you have been while you run the program, and where you are now. You can click on any one of these functions to see the path your program took to this point.
Console and debugger side-by-side
You don’t have to constantly click back and forth between the debugger window and the console window. Click on the console tab and drag it over to the far right of the debugger window:
This will make it easier to see everything that is going on.
Some more debugging
Now click the step over button another time. This runs line 7, which asks for input:
Type in your age and press enter. You will see that the age variable contains what you typed:
This is also shown in the main window:
Step out
Now click the step out button.
This will run all the rest of the code in get_age() and stop at the next line of the previous function — main() in this case:
We are back to line 17, which is where we started before we pressed step into.
Return values
Look for a gear icon on the far left of the debug window. You may need to first click >> to see it. Click on the gear and then select Show Return Values:
Now press step over to execute line 17 and look at the return values area of the debug window:
You can see the return values for every function that has been called.
Continue pressing step over and you will execute all of the rest of the program, one line at a time.
Review of stepping
Here is the difference between the different stepping buttons:
The step over button tells PyCharm to run the current line of code, including any functions that are listed, and show the result. Stepping over a line that includes a function means that function (and any functions it calls) gets executed as well, and you just see the end result.
The step into button tells PyCharm to run the current line of code, but if it includes a function, PyCharm will go into the function and stop at its first line. Note there is another step into button to the left of the one that is circled. Don’t use that one — it will step into the code of any libraries you use, which is usually not helpful if you are only concerned about your code.
The step out button tells PyCharm to run as many lines as needed to get to the previous function in the stack. The debugger window shows you the current stack of functions, so this button stops at the next line of code in the function that is the second one from the top.
More useful buttons
There are three useful buttons on the left of the debugging window:
restart is helpful if you want to restart the debugging process all over again
stop is great if you just want to stop debugging, hopefully because you found your bug and know how to fix it
resume will run the rest of your program and will only stop if it reaches another breakpoint.
You can set multiple breakpoints in your program and then use resume to jump between them.
A “real” bug
Let’s see how everything works when we are tracking down a “real” bug. Modify your program so that the get_name() reads like this:
content_copy
Copy
def get_name():
    name = input('Hello, what is your name? ')
    name = 'Harry Potter'
    return name
Debug your program again (or click the restart button). Click the step over button to execute line 17:
No matter what you type, the get_name() function always returns 'Harry Potter'. This means we need to debug get_name().
Click and put a breakpoint at line 2.
Click the restart button. PyCharm should show your program stopped at line 17 as usual.
Click the resume button. PyCharm will continue and then stop at your second breakpoint, on line 2.
Click step over and enter a name.
Click step over and watch the name variable change!
No matter what you typed as input, the name variable gets overwritten. You’ve found the bug!
The debugging process
Yes, this was a contrived example, but you can follow this debugging process reliably to find bugs:
put a breakpoint in your main function
step over every line, watching the variables and return values
as soon as something happens that you don’t expect, create a new breakpoint in the function that is not behaving properly
restart the debugging process and debug that function
keep debugging functions as needed
This will be a lot easier if you have decomposed your program into small functions!
Now you have a new super power!

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Using pytest
We can see if our code works by running it, but this only shows us that it works for one particular case. To get a better understanding if the functions we have written are working properly, we can write tests for them. One way to do this is with pytest.
Installing the BYU pytest utilities
For CS 110, we have written some libraries that make testing and grading your code easy. You can tell if pytest is installed by running test-wendys.py below.
If it is not yet installed, follow the instructions in Installing Packages but use byu-pytest-utils instead of byubit.
Empty Suite Error
Sometimes Pycharm does not recognize pytest as the test runner for your project, and throws an “Empty Suite” error. To prevent this:
(1) In PyCharm and select:
Windows: File ➡️ Settings
MacOS: PyCharm ➡️ Settings
(2) In the search box, search for pytest. In the highlighted box, select pytest from the dropdown.
(3) Click OK to close the settings window.
Running pytest
The zip file above contains wendys.py, the program shown in the guide on interactive programs:
content_copy
Copy
def get_name():
    return input("What is your name? ")


def get_sandwich():
    return input("What kind of sandwich do you want? ")


def get_additions():
    return input("What do you want on it? ")


def print_summary(name, sandwich, adds):
    print(f"{name} wants a {sandwich} sandwich with {adds}!")


def main():
    print("Welcome to Wendy's!")
    name = get_name()
    sandwich = get_sandwich()
    adds = get_additions()
    print_summary(name, sandwich, adds)


if __name__ == '__main__':
    main()
The tests for this program are in test_wendys.py:
content_copy
Copy
from byu_pytest_utils import dialog, max_score, test_files


@dialog(
    test_files / 'wendys.txt',
    'wendys.py'
    )
@max_score(5)
def test_wendys(): ...
The diagram below explains the contents of this file:
Take a look at the file test_files/wendys.txt and this contains the expected input and output for the test:
content_copy
Copy
Welcome to Wendy's!
What is your name? <<Jorge>>
What kind of sandwich do you want? <<chicken>>
What do you want on it? <<lettuce and tomatoes>>
``Jorge wants a chicken sandwich with lettuce and tomatoes!;output;80``
If you read through this, you can see that for this test PyCharm will provide the following inputs when your program asks calls input():
Jorge
chicken
lettuce and tomatoes
The test expects your program to print out all the output shown. The dialog() decorator compares the input and output of your program to the input and output in wendys.txt.
A note on the format of the test file:
Words surrounded by <<>> are expected inputs.
Any text surrounded by grave marks is a specific section that pytest will grade, followed by a ;, the name of the test, another ;, and the associated grade percentage.
Running tests in PyCharm
To run tests in PyCharm, be sure that both the original file and the test file are in the same directory and the same folder. In our example, you want to be sure that wendys.py and test_wendys.py are in the same directory.
When you open test_wendys.py, you should see green triangles next to each test function:
In this case we have only one test function so there is only one green triangle. In some cases you may see more than one.
You can click the green triangle to run the test and see the output in the lower half of PyCharm:
You should see a green check mark on the left, indicating the code passes the test, and also in the screen you will see test_wendys.py::test_wendys PASSED.
An example of a failed test
Modify the code in wendys.py so that the function get_sandwich() reads like this:
content_copy
Copy
def get_sandwich():
    return input("What kind of bread do you want? ")
Notice that we have changed the text of the question. Now go back to test_wendys.py and run the test again. You should see an error:
You will see yellow circles with an X on the left, and then errors in red in the main part of the lower window. The easiest way to see the problem is to click on Click to see the difference. This will open a new window showing you the differences between what pytest expected and what your program did:
You can see the expected output on the left has the word sandwich highlighted, and the actual output on the right has the word bread highlighted, showing where your code has a problem.
Undo your changes to fix the problem, then rerun the tests to be sure they pass.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Upgrading a package in PyCharm
Sometimes you will need to upgrade a package we are using. This guide shows you how to do that.
(1) Open PyCharm and select:
Windows: File ➡️ Settings
MacOS: PyCharm ➡️ Settings
(2) Select Project and Python Interpreter. The settings/preferences window should look like this:
(3) Click on the package you want to upgrade. If there is an upgrade available, you will see a triangle pointing up in the Latest Version column. Then click the upgrade button:
(4) When this is done, click the OK button.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Types and operators
As you learn to program, it is helpful to understand some basic concepts that are common to all programming languages. Here we are going to cover types and operators.
Types
Every value in Python has a type. We are going to cover three basic types: string, integer, and boolean.
String
We have been using strings for some time, such as when we paint the color 'blue':
content_copy
Copy
bit.paint('blue')
The type for the value 'blue' is a string.
We have also seen strings when using input():
content_copy
Copy
student = input('What is your name? ')
If the person running your program types Emma, then the variable student references the string 'Emma'.
You can do likewise see this in the following code, where we directly set student equal to 'Emma':
content_copy
Copy
student = 'Emma'
Remember that functions can return values. So in this code:
content_copy
Copy
def get_name() :
    return input('What is your name? ')


if __name__ == '__main__':
    student = get_name()
the variable student again has a type of string. This is because get_name() returns whatever input() returns, and input() returns a string:
Integer
Another type in Python is integer. You can see this below:
content_copy
Copy
number = 5
Here, the variable number references the integer 5.
Note that there are no quotes around 5! If you instead type:
content_copy
Copy
number = '5'
Then, the variable number now references the string '5'.
Just like with strings, functions can return integers:
content_copy
Copy
def get_a_seven():
    return 7


if __name__ = '__main__':
    number = get_a_seven()
Here, get_a_seven() is a function that always returns 7, which is an integer. Likewise, the variable number eventually references the same number 7.
Boolean
Finally, when you use True or False, then these have the boolean type. For example:
content_copy
Copy
having_a_great_time = True
Here, the value having_a_great_time references the boolean True.
Likewise, we can have a function that returns a boolean:
content_copy
Copy
def i_am_hungry():
    return True


if __name__ == '__main__':
    if i_am_hungry():
        print('Now eating a salad')
Here, the function i_am_hungry() returns True, which is a boolean, and because that boolean is True, the program will print Now eating a salad.
Summary
Value Type
‘hello’ string
“why not?” string
3 integer
True boolean
False boolean
Operators
The type of a variable determines which operators you can use with it and what those operators do.
Plus
For example, we can add integers with the + operator, and this works as you would expect:
content_copy
Copy
if __name__ == '__main__':
    print(10 + 7)
This will print 17.
It may surprise you that in Python we can also use the + operator on strings:
content_copy
Copy
if __name__ == '__main__':
    print('fire' + 'place')
This will print fireplace, because for strings the + operator concatenates them.
Minus
You can use the - operator to subtract integers:
content_copy
Copy
if __name__ == '__main__':
    print(10 - 7)
This will print 3.
But you cannot use the - operator on strings! If you try it:
content_copy
Copy
if __name__ == '__main__':
    print('fire' - 'place')
you will see this error:
content_copy
Copy
Traceback (most recent call last):
  File "/Users/zappala/cs110/unit3/test.py", line 2, in <module>
    print('fire' - 'place')
          ~~~~~~~^~~~~~~~~
TypeError: unsupported operand type(s) for -: 'str' and 'str'
This is telling you that - is an “unsupported operand” in between the types ‘str’ (string) and ‘str’ (string).
Equality
Two check whether two values are equal, use two equal signs, ==. Equality is a comparison operator, meaning you use it to compare two values:
content_copy
Copy
if __name__ == '__main__':
    number = 5
    if number == 3:
        print('Your number is 3')
    elif number == 5:
        print('Your number is 5')
Here, we first try number == 3, which is False. We next try number == 5, which is True. So this program will print: Your number is 5.
Try changing the first line of the main block to set number to a different value.
Similar to integers, we can use == to compare strings:
content_copy
Copy
if __name__ == '__main__':
    your_pet = 'cat'
    if your_pet == 'dog':
        print('A dog is a good second-best pet!')
    elif your_pet == 'cat':
        print('A cat is the best pet!')
Here, we first try your_pet == 'cat', which is False. We next try your_pet == 'cat', which is True. So this program will print: A cat is the best pet!.
Greater than and less than
Both < and > are also comparison operators.
We can use > to check if one value is greater than another:
content_copy
Copy
if __name__ == '__main__':
    number = 7
    if number > 10:
        print('Your number is too high.')
    elif number > 5:
        print('Your number is just right.')
    else:
        print('Your number is too low.')
This will run the first comparison, number > 10, and it evaluates to False. The second comparison evaluates to True, so the program prints: Your number is just right.
We can likewise use < to compare values:
content_copy
Copy
if __name__ == '__main__':
    number = 7
    if number < 5:
        print('Your number is too low.')
    else:
        print('Your number is high enough')
We can also use > and < to compare strings. This will do an alphabetical comparison for you. For example:
content_copy
Copy
if __name__ == '__main__':
    animal1 = 'alligator'
    animal2 = 'zebra'
    if animal1 < animal2:
        print("Animal 1 comes before animal 2")
This will print Animal 1 comes before animal 2.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Input loops
When writing interactive programs, you often will want to loop while receiving input. The basic structure of an input is:
while some condition is True
read input
check the input and either
do something with the input
break or return from the loop
This is an event stream pattern!
The examples below will illustrate how to do this.
Road Trip
We are going to write a small program that checks helps you on a road trip:
loop forever
ask the driver “Are we there yet?”
if the answer is yes, break out of the loop
Video Transcript
The code in road_trip.py shows a program that does this:
content_copy
Copy
def is_yes(response):
    return response == "yes" or response == "Yes"


def road_trip():
    while True:
        response = input("Are we there yet? ")

        if is_yes(response):
            print("Hurray!")
            break


if __name__ == '__main__':
    road_trip()
The most important thing to notice here is that the road_trip() function uses while True to loop. This will loop literally forever unless you include some way of breaking out of the loop when a condition is met. In this case, we use break to leave the loop whenever the user types yes or Yes as input. The keyword break does exactly what it sounds like — it leaves the while loop it is inside of and goes to the next line of code that is outside of the loop. In this example, there is no other code in the road_trip() function, so once the code uses break, it leaves the function and then ends the program.
Notice also that the is_yes() function checks a response string to see if it is ‘yes’ or ‘Yes’, so we can handle different ways a person types a response. The correct way to write this code is:
content_copy
Copy
    return response == "yes" or response == "Yes"
Do NOT write:
content_copy
Copy
    return response == 'yes' or 'Yes'
This will ALWAYS return true. Imagine a person types ‘no’. Then Python will check response == 'yes', and this is False. However it then checks Yes, which by itself evaluates to True, and the function will return True. This is not what you want.
Run the program and you will see something like this:
content_copy
Copy
Are we there yet? no
Are we there yet? no
Are we there yet? nyet
Are we there yet? nope
Are we there yet? sorry
Are we there yet? sigh
Are we there yet? yes
Hurray!
Bigger
Let’s write a program to check whether one number is bigger than another. The idea is to do this:
have the person enter number1
have the person enter number2
tell the person which number is bigger
Remember, input() always returns a string! If a person enters '5' and '10', then you don’t want to compare the string ‘5’ to the string ‘10’! You will be checking which string comes first alphabetically, which is not what you want.
So whenever you use input() to enter numbers, you need to convert the string that a person enters into an integer. You do this with int():
content_copy
Copy
response = input('Enter a number: ')
number = int(response)
When you use input() to ask for a number, be sure to use int() to convert the string a person types into a number
The code in bigger.py contains a program that checks two numbers:
content_copy
Copy
def get_number():
    response = input("Enter a number: ")
    return int(response)


def main():
    number1 = get_number()
    number2 = get_number()

    if number1 > number2:
        print(f"{number1} is bigger than {number2}")

    elif number1 < number2:
        print(f"{number1} is smaller than {number2}")

    else:
        print(f"You entered {number1} twice.")


if __name__ == '__main__':
    main()
If you run this program, you will see something like this:
content_copy
Copy
Enter a number: 5
Enter a number: 10
5 is smaller than 10
Guessing game
Let’s put these two concepts together. Write a program that asks a person to guess a secret number:
loop forever
get a guess
if the guess is too high, tell them to go lower
if the guess is too low, tell them to go higher
if the guess is correct, tell them they won and break
This combines both an input loop and converting strings to integers with int(). Work with a friend to see if you can solve this problem.
The code in guessing_game.py contains a solution:
content_copy
Copy
def play(secret_number):
    while True:
        response = int(input('Guess a number: '))

        if response > secret_number:
            print('Lower!')

        elif response < secret_number:
            print('Higher!')

        else:
            print('You got it!')
            return


if __name__ == '__main__':
    play(37)
In this program we use return to break out of the while loop. This works just as well as break. The only difference is that break would continue to execute code in the play() function if there was more code after the while loop.
Notice that we “hard code” the answer to 37. Later we will show you how to choose a random number instead. If you run this program, you should see something like this:
content_copy
Copy
Guess a number: 50
Lower!
Guess a number: 20
Higher!
Guess a number: 30
Higher!
Guess a number: 35
Higher!
Guess a number: 37
You got it!

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Lists
A list contains a collection of values. You have already seen variables that hold a single value:
content_copy
Copy
number = 5
A variable that references a list can hold multiple values, in order:
content_copy
Copy
names = ['Maria', 'Mariano', 'Anna', 'Antonino']
numbers = [5, 8, 10, 13, 42]
A list can hold as many values as you want. We can even have an empty list:
content_copy
Copy
twilight_books_i_like = []
Length
To get the length of a list, use len:
content_copy
Copy
number_of_names = len(names)
Here, number_of_names will be equal to 4.
Appending to a list
One of the many functions we can perform on a list is appending items to it. This means adding items to the end of the list. For example:
content_copy
Copy
pets = ['cat', 'horse', 'dog']
pets.append('emu')
This will result in the pets list now containing ['cat', 'horse', 'dog', 'emu'].
Note the syntax here — variable dot function:
You can use input loops to start with an empty list and then add more items to it. In the zip file you will find a small program in get_names.py that illustrates how to do this:
content_copy
Copy
if __name__ == '__main__':
    names = []
    while True:
        name = input("Give me a name: ")
        if name == 'q':
            break
        names.append(name)

    print(names)
We start with an empty list, using names = [].
We use the event stream pattern, looping forever and then breaking out of the loop if the person enters ‘q’ instead of a name. (Note, if you were making a program to enter characters in Star Trek, you might not want to do it this way.)
We use append() to add each name to the list.
If you run this program, you will see something like this:
content_copy
Copy
Give me a name: me
Give me a name: you
Give me a name: everyone
Give me a name: q
['me', 'you', 'everyone']
Iteration
Once you have a list, you can iterate (or loop) through it using for ... in:
content_copy
Copy
for number in numbers:
    print(number)
Each time through the for loop, Python sets the variable number to one of the numbers in the list, in order. Since we have set the numbers variable to [5, 8, 10, 13, 42], the first time through the loop, number = 5. The second time through the loop, number = 8, and so forth. So this code will print:
content_copy
Copy
5
8
10
13
42
The name of the variable can be whatever you like. For example:
content_copy
Copy
for cute_puppies in numbers:
    print(cute_puppies)
However, you want to be sure that your friends can read your code and make sense of it!
Your code is much more readable if you use variables that make sense.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with lists
We are going to write several programs to practice using lists.
Bullets styles
Video Transcript
Write a program that:
Asks a person for a series of items.
The person inputs q when they are done.
Prints the list of items using the following bullets:
*
-
>
So the list of items is printed three times, each time using a different type of bullet.
Planning
See if you can write this program with a friend. You have starter code in the zip file above, in the file called bullet_styles.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Start by decomposing the problem into functions! What are the functions you would use in main()?
Basic solution
There are two parts to this problem:
getting the list of items
printing the list of items, with a certain kind of bullet
These translate directly into two functions:
content_copy
Copy
def main():
    items = get_items()
    print_items(items, '*')
    print_items(items, '-')
    print_items(items, '>')
get_items() takes no parameters — it should get the entire list of items and return a list
print_items() takes two parameters — (1) the list, and (2) a string with the type of bullet to use
This is how you should think as you write programs — decompose the problem into functions first, and then write the functions one at a time.
Getting the items
We can write an empty function for print_items():
content_copy
Copy
def print_items(items, bullet):
    pass
This lets us focus on writing get_items():
content_copy
Copy
def get_items():
    """
    Prompt the user for items until they provide 'q'
    Return the items in a list
    """
    items = []
    while True:
        item = input('Item: ')
        if item == 'q':
            break
        items.append(item)

    return items
start with an empty list
loop forever
add each item to the list
if the person enters q then break from the loop
return the list, which now has all the items the person entered
If you run this program, you can see something like this:
content_copy
Copy
Item: pencil
Item: paper
Item: eraser
Item: q
It seems to be working but how do we know if get_items() has returned a list properly? There are a couple of things you can do. First, you can use print():
content_copy
Copy
def main():
    items = get_items()
    print(items)
    print_items(items, '*')
    print_items(items, '-')
    print_items(items, '>')
Now if you run the program, you see:
content_copy
Copy
Item: pencil
Item: paper
Item: eraser
Item: q
['pencil', 'paper', 'eraser']
That’s probably enough to convince us that this is working just fine! But we have to remember to remove your print() statements when we are done.
Another option is to use the debugger. Put a breakpoint in main() on the line that calls get_items(). Then run the debugger and step over the get_items() function. After you enter your items using the console, you should see:
This is a good way to get used to the debugger, so we recommend doing this instead of using print().
Printing the items
Now we can write the print_items() function:
content_copy
Copy
def print_items(items, bullet):
    """
    Print a list of items using the provided bullet character.
    Print an extra blank line at the end of the list.
    """
    for item in items:
        print(f'{bullet} {item}')
    print()
print_items() takes two arguments, the list to print and a bullet character.
We iterate through the list using for ... in
We use string formatting to print the list items
We use print() by itself to print a blank line
Now if you run the code, you should see something like this:
content_copy
Copy
Item: pencil
Item: paper
Item: eraser
Item: q
* pencil
* paper
* eraser

- pencil
- paper
- eraser

> pencil
> paper
> eraser
Great!
Big and small
Video Transcript
Write a program that asks a person for a list of numbers (one number at a time).Then ask the user what number to use as the boundary between “big” and “small” numbers. The program should then print:
You have [how_many] numbers
These are small:
[all of the small numbers, one per line]
These are big:
[all of the big numbers, one per line]
Planning
See if you can write this program with a friend. You have starter code in the zip file above, in the file called big_and_small.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Notice that this is the same starter code as the previous problem. You should eventually get used to typing this in yourself.
Start by decomposing the problem into functions! What are the functions you would use in main()?
Basic solution
For this problem, we have a number of things to do:
getting the list of numbers
getting the boundary number
printing the number of numbers
printing the small numbers
printing the big numbers
These translate directly into two functions:
content_copy
Copy
def main():
    numbers = get_numbers()
    bound = get_bound()
    print_length(numbers)
    print_small(numbers, bound)
    print_big(numbers, bound)
We can create empty functions for each of these:
content_copy
Copy
def get_numbers():
    pass


def get_bound():
    pass


def print_length(numbers):
    pass


def print_small(numbers, bound):
    pass


def print_big(numbers, bound):
    pass
This lets us write and test one function at a time.
Getting the numbers
We can write the get_numbers() function using the same input loop as above when we got items:
content_copy
Copy
def get_numbers():
    numbers = []
    while True:
        response = input('Number: ')
        if response == 'q':
            break

        number = int(response)
        numbers.append(number)

    return numbers
Notice an important addition — we need to convert the person’s entry into an integer using int().
You should be able to test this with the debugger:
Getting the boundary number
We can write the get_bound() function:
content_copy
Copy
def get_bound():
    return int(input('Boundary: '))
Note that we are getting the input, converting it to an integer, and returning it all in one step. This code does the same thing:
content_copy
Copy
def get_bound():
    response = input('Boundary: ')
    return int(response)
and so does this code:
content_copy
Copy
def get_bound():
    response = input('Boundary: ')
    integer_response = int(response)
    return integer_response
Whether you do it in multiple steps or one is up to you!
You can use the debugger to see if this is working:
Printing the information
Now we can fill out the remaining functions, which do some printing:
content_copy
Copy
def print_length(numbers):
    print(f'You have {len(numbers)} numbers')


def print_small(numbers, bound):
    print('These are small:')
    for number in numbers:
        if number < bound:
            print(number)


def print_big(numbers, bound):
    print('These are big:')
    for number in numbers:
        if number >= bound:
            print(number)
print_length() is just one line and uses a formatted string
print_small() and print_big() both use for ... in to iterate over the numbers and print them out
If you run the program, you will see something like this:
content_copy
Copy
Number: 10
Number: 1
Number: 3
Number: 7
Number: q
Boundary: 5
You have 4 numbers
These are small:
1
3
These are big:
10
7

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Operators
We previously covered types and operators to demonstrate how different types support different operations. We now want to show you a more complete list of operators.
Arithmetic Operators
Arithmetic operators take two numbers and produce a result.
Operator Example Result
+ 7 + 2 9
- 7 - 2 5
* 7 * 2 14
/ 7 / 2 3.5
** 7 ** 2 49
// 7 // 2 3
% 7 % 2 1
Addition, subtraction, multiplication, and division are straightforward.
Exponentation ** raises the first number to the power of the second. So 7 to the power of 2 is 49.
Integer division //, also called floor division, gives the integer portion of a division operation.
Modulation % gives the remainder of a division operation.
All of these operations can be used in the following ways. First, directly using numbers:
content_copy
Copy
if __name__ == '__main__':
    print(5 + 7)
Second, within a function:
content_copy
Copy
# within a function
if __name__ == '__main__':
    number = 5
    print(number + 7)
Third, using variables:
content_copy
Copy
# using variables
if __name__ == '__main__':
    number = 5
    number = number + 7
    print(number)
Comparison operators
Operator Example Result
> 2 > 1 True
< 2 < 1 False
>= 2 >= 2 True
<= 2 <= 2 True
== 4 == 4 True
!= 4 != 6 True
We use == to check for equal to and != to check for not equal to.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
List Patterns
We are going to show you some common patterns when using lists in your programs. Recognizing these patterns will help you know how to solve a problem you are given. If a problem looks like one of these, then you can follow this pattern to write your code.
Map
The map pattern occurs when you want to take a list of values and individually map each value in the list to a new value. Here is an example:
Original Items New Items
ball ballroom
bath bathroom
bed bedroom
family familyroom
food foodroom
car carroom
Notice how we can make a new list by taking each item from the original list and concatenating ‘room’ to create a new word.
The steps for this pattern are:
create a new, empty list
iterate through each item in the original list
use the item in the original list to create a new item
append the new item to the new list
return the new list
We can see an example of this pattern in the file called make_rooms.py:
content_copy
Copy
def make_rooms(words):
    rooms = []
    for word in words:
        room = word + 'room'
        rooms.append(room)
    return rooms


if __name__ == '__main__':
    some_words = ['ball', 'bath', 'bed', 'family', 'food', 'car']
    rooms = make_rooms(some_words)
    print(f'Original words: {some_words}')
    print(f'Rooms: {rooms}')
Notice how we use the original list words to make a new list rooms. Every word in words maps to a room in rooms.
You can see another example of this pattern in smaller_numbers.py, which takes a list of numbers and makes numbers smaller by dividing them by two, keeping only the integer portion. To do this, you need to be sure to use the // operator, which does floor division, meaning it works like regular division but returns the largest possible integer that divides into numerator by the denominator.
content_copy
Copy
def make_smaller(numbers):
    smaller_numbers = []
    for number in numbers:
        smaller = number // 2
        smaller_numbers.append(smaller)
    return smaller_numbers


if __name__ == '__main__':
    original = [1, 2, 3, 4, 5, 6, 7, 8]
    divided_by_two = make_smaller(original)
    print(original)
    print(divided_by_two)
Filter
This example illustrates the filter pattern. By filter we mean that we start with a list and use its values to calculate and return a new list that has some or all of the original values. For we could take a list of numbers and return a new list that has only the odd numbers from the original list:
Original Items New Items
2 3
3 5
4
5
The steps for this pattern are:
create a new, empty list
iterate through each item in the original list
append the item to the new list if it meets some criteria
return the new list
The file only_odds.py has code for this example:
content_copy
Copy
def only_odds(numbers):
    odds = []
    for number in numbers:
        if (number % 2) == 1:
            odds.append(number)
    return odds


if __name__ == '__main__':
    print(only_odds([1, 2, 3, 4, 5, 6]))
We start by initializing a variable odds to an empty list. We then iterate through the list and check if each number is odd. We can do this by using the mod operator, %, which calculates the remainder, and check if the remainder is zero. If it is not zero, then we have an odd number, so we can append it to the list we store in the odds variable.
The function finishes by returning odds, so eventually the print function will print [1, 3, 5].
Select
This example illustrates the select pattern, which chooses a single value from a list, such as a minimum or maximum value.
The steps for this pattern are:
initialize a variable to store the selected value; this is set to None
iterate through the list
if the variable is still None or the current item is “better” (smaller or larger) than the value of the variable
change the variable so it now has the current item
return the variable
The file called find_min.py has an example:
content_copy
Copy
def find_min(numbers):
    smallest = None
    for number in numbers:
        if smallest is None or number < smallest:
            smallest = number
    return smallest


if __name__ == '__main__':
    print(find_min([3, 6, 2, 8, 1, 7]))
Here we are trying to calculate the minimum value of a list of numbers. We start by initializing smallest to None, because there is no smallest number yet. Then, when we iterate over the list, we do two checks with an if statement. First, we check if smallest is still None. If it is, that means we haven’t found a smallest number yet, so the one we are currently looking at must be the smallest. Second, we check if the current number is smaller than smallest. If either of these checks succeeds, we set smallest = number.
Here is a chart for the iterations of the loop:
Iteration number smallest
0 N/A None
1 10 10
2 8 8
3 40 8
4 22 8
5 3 3
6 5 3
At the end, smallest = 3.
Notice that if we ran this code:
content_copy
Copy
result = find_min([])
then we would get result = None.
Accumulate
This example demonstrates the accumulate pattern. By accumulate, we mean calculating a single value as we iterate, like taking a sum or an average.
The steps for this pattern are:
initialize a variable to an appropriate value (for example, zero)
iterate through the list
use the new item to modify the variable (for example, add it to the variable or subtract it)
return the variable
The file average.py contains an example:
content_copy
Copy
def average(numbers):
    total = 0
    for number in numbers:
        total = total + number
    return total / len(numbers)


if __name__ == '__main__':
    print(average([1, 2, 3, 4]))
In the average() function, we initialize the total variable to zero. Then, each time we iterate through the numbers, we increase total by the current number. We finally return the total divided by the length of the list.
Here is a chart showing how this code updates the number and total variables each time through the loop. Iteration number 0 is where we start before the for loop.
Iteration number total
0 N/A 0
1 1 1
2 2 3
3 3 6
4 4 10
At the end of the function, it returns total / 4, which is 2.5.
Multiple patterns at once
Here is a problem that requires using multiple patterns: given a list of numbers, write a function that subtracts 7 and then removes any negative numbers and any numbers greater than 10.
There is starter code in all_together.py:
content_copy
Copy
def make_it_happen(numbers):
    # Write code here
    pass


if __name__ == '__main__':
    original = [0, 7, 2, 14, 20, 32, 5, 12]
    changed = make_it_happen(original)
    print(changed)
How would you solve this problem? Focus on the functions you would call in make_it_happen().
Here is one idea of how to do this:
content_copy
Copy
def make_it_happen(numbers):
    numbers = sub_7(numbers)
    numbers = filter_numbers(numbers)
    return numbers
We create two functions — one to do the subtraction (which should use the map pattern) and one to do the filtering.
We can implement sub_7() first:
content_copy
Copy
def sub_7(numbers):
    new = []
    for number in numbers:
        new.append(number - 7)
    return new
This follows the map pattern. Notice that we do the mapping and appending all in one step with new.append(number - 7).
We can temporarily use an empty function for filter_numbers(). Since this function needs to return something, we can do this with:
content_copy
Copy
def filter_numbers(numbers):
    return numbers
That just returns the original list unchanged. Now we can run our program, which starts with:
content_copy
Copy
nums = [0, 7, 2, 14, 20, 32, 5, 12]
We get the following printed out:
content_copy
Copy
[-7, 0, -5, 7, 13, 25, -2, 5]
That looks good!
Now we can implement filtering:
content_copy
Copy
def should_keep(number):
    return number >= 0 and number <= 10


def filter_numbers(numbers):
    new = []
    for number in numbers:
        if should_keep(number):
            new.append(number)
    return new
Notice that we use a separate function should_keep() to implement the decision about whether to keep a number in the list. We can do this with number >= 0 and number <= 10. We phrased this problem as removing any negative numbers and any numbers greater than 10, but for filtering we need to turn that into a statement about which numbers to keep: keeping all numbers greater than or equal to zero and less than or equal to 10.
Now when we run our code we get:
content_copy
Copy
[0, 7, 5]
This has kept all of the numbers between and including 0 and 10.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Tuples
A tuple is a collection of one or more values, designated with parentheses:
content_copy
Copy
student = ('Emma Johns', 22, 'political science')
In this case, the values might represent a student’s name, age, and major.
Tuples are immutable
A tuple is not mutable (changeable). In other words, it is immutable (not changeable).
Remember, we can change a list by appending something to it:
content_copy
Copy
names = ['Anna', 'Angela']
names.append('Amy')
However, we cannot change a tuple. If we try:
content_copy
Copy
student = ('Emma Johns', 22, 'political science')
student.append('3.92')
then we get an error:
content_copy
Copy
Traceback (most recent call last):
  File "/Users/zappala/Documents/cs110/tuples.py", line 8, in <module>
    student.append('3.92')
AttributeError: 'tuple' object has no attribute 'append'
Unpacking
Let’s imagine we want to be able to print some information about a student. To do this, we could print the tuple directly:
content_copy
Copy
student = ('Emma Johns', 22, 'political science')
print(student)
This will print:
content_copy
Copy
('Emma Johns', 22, 'political science')
So just like printing a list will print it with the square brackets, printing a tuple will show the parentheses.
A much better way to do this is to unpack the tuple. Unpacking takes each of the parts of the tuple and stores them in separate variables:
content_copy
Copy
name, age, major = ('Emma Johns', 22, 'political science')
print(f'{name} is {age} years old and a {major} major')
We now have three separate variables, name, age, and major instead of just student. We can print those using a formatted string.
Returning multiple values
Tuples are particularly helpful for returning multiple values from a function. This function sorts two values, a and b, returning the values in sorted order:
content_copy
Copy
def sorted_order(a, b):
    """Return a and b in ascending order"""
    if a < b:
        return a, b
    else:
        return b, a
Notice that we can often leave off the parentheses when returning values from a function.
We can call this function:
content_copy
Copy
if __name__ == '__main__':
    first, second = sorted_order(4, 2)
    print(f'First comes {first}, then comes {second}')
And this will print:
content_copy
Copy
First comes 2, then comes 4
In fact, this function will work with strings as well. We can call it as:
content_copy
Copy
if __name__ == '__main__':
    first, second = sorted_order('Amy', 'Angela')
    print(f'First comes {first}, then comes {second}')
and this will print:
content_copy
Copy
First comes Amy, then comes Angela
You can find this code in sorting.py in the zip file above.
Here is another example:
content_copy
Copy
def smallest_word(words):
    """Return the smallest word along with its length"""
    smallest = None
    for word in words:
        if smallest is None or len(word) < len(smallest):
            smallest = word
    return smallest, len(smallest)
This function returns both the smallest word and the length of that word.
We can call it like this:
content_copy
Copy
if __name__ == '__main__':
    smallest_word, size = smallest_word(['apple', 'iron', 'cat', 'pigeon'])
    print(f'The smallest word is {smallest_word} and it has length {size}.')
and this will print:
content_copy
Copy
The smallest word is cat and it has length 3.
Notice how unpacking is particularly helpful when a function returns multiple values!
You can find this file in smallest.py in the zip file above.
Tuples vs lists
It’s important to recognize that lists and tuples fill different roles.
list tuple
Can add or remove items Immutable
Size dynamically determined as the program runs Size fixed once it is created
Typically stores items of the same type Often stores items of different types
The items are usually independent of each other The items usually go together as a unit of information
Typically processed with iteration Typically processed by unpacking
You typically want to use a list when you are working with a list of things that are all the same type and you don’t know how many items you will have until you run the program
You typically want to use a tuple when you are returning several values from a function or if you know in advance exactly how many items how will have (and this never changes)

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
None
Consider this function called best_animal():
content_copy
Copy
def best_animal():
    response = input('What do you think is the best animal? ')
    return response


if __name__ == '__main__':
    animal = best_animal()
If a person enters ‘giraffe’ at the prompt, then response → 'giraffe', and after the function returns animal → 'giraffe'.
However, what happens if you leave off the return statement?
content_copy
Copy
def best_animal():
    response = input('What do you think is the best animal? ')


if __name__ == '__main__':
    animal = best_animal()
In this case, the best_animal() function returns None! So then animal → None.
Using None
Having a value that represents None, or nothing, can be really useful. For example, look at this revised best_animal() function:
content_copy
Copy
def best_animal():
    response = input('What do you think is the best animal? ')
    if response == '':
        return None

    return response


if __name__ == '__main__':
    animal = best_animal()
    if animal is None:
        print("You don't have a favorite animal? 😔")
    else:
        print(f"Your favorite animal is a {animal}? Cool!")
You can find this code in best_animals.py in the zip file above. Walk through this program with the debugger to see what happens in these cases:
If you enter ‘giraffe’, then:
The variable response → 'giraffe'.
Since this is not equal to an empty string, then best_animal() returns ‘giraffe’.
This sets the variable animal → 'giraffe'.
Since animal is not None, the program prints “Your favorite animal is a giraffe? Cool!”
If you enter nothing, by just pressing the Enter key, then:
The variable response → ''.
Since response is equal to the empty string, then best_animal() returns None.
This sets the variable animal → None.
Since animal is None, the program prints “You don’t have a favorite animal? 😔”
You can check if a variable is None using is None:
content_copy
Copy
if animal is None:
    # do something
Likewise, you can check if a variable is not None using is not None`:
content_copy
Copy
if animal is not None:
    # do something

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with Tuples
These problems will help you practice with tuples.
Registering participants
First, let’s write a simple program to register participants for an event. We want to collect the first name, last name, and age for each participant. The program should then print out the list of participants. Here is a simple diagram showing how this should work:
We can translate this drawing into code by writing a simple main() function:
content_copy
Copy
def main():
    participants = register_participants()
    print_participants(participants)


if __name__ == '__main__':
    main()
Notice how the list of participants returned by register_participants() is stored in a variable and then that variable is given to print_participants() to print them out.
A list of tuples
We are going to keep track of each participant’s info as a tuple of (first, last, age). Then we are going to put those tuples in a list. So if we register three people, the list stored in the participants variable will have something like this:
content_copy
Copy
[('Emma', 'Walker', 24), ('Jorge', 'Rodriguez', 23), ('Min', 'Young', 24)]
Registering participants
Next, here is a diagram of how to register participants:
We start with an empty list.
We get a participant. This function returns either a tuple with participant info or None.
If the participant is None, break and return the list.
Otherwise, append the tuple to a list of participants and get another one.
We can translate this into code in the register_participants() function:
content_copy
Copy
def register_participants():
    people = []
    while True:
        participant = get_participant()
        if participant is None:
            break
        people.append(participant)
    return people
Start an empty list.
Use a while True loop to keep getting participants until get_participant() returns None.
If the return value is ever None, we break out of the loop at that point.
Otherwise we append the tuple for a participant to a list of people who are registered.
When the loop finishes, return the list.
Notice how this code doesn’t care if get_participant() returns a string or a tuple. We will have it return a tuple, like ('Emma', 'Walker', 24), but we can write our code the same either way.
Getting a participant
Here is a diagram of how to get a participant:
We can translate that into code in the get_participant() function:
content_copy
Copy
def get_participant():
    print('Register a participant (or enter no first name to stop)')
    first = input('First name: ')
    if first == '':
        return None
    last = input('Last name: ')
    age = int(input('Age: '))
    return (first, last, age)
Get the first name.
If that is empty, then return None
Otherwise get the rest of the info and return a tuple with all of the info.
This is how to return a tuple from a function:
content_copy
Copy
return (first, last, age)
Printing participants
Finally, we can write a function to print the participants:
content_copy
Copy
def print_participants(participants):
    for first, last, age in participants:
        print(f'{last}, {first} ({age})')
We loop through the tuples and unpack them using for ... in. Then we can print each part of the tuple using a formatted string.
Running the program
You can run this program using registration.py in the zip file linked above. When you run it, you should see somehting like this:
content_copy
Copy
Register a participant (or enter no first name to stop)
First name: Emma
Last name: Walker
Age: 24
Register a participant (or enter no first name to stop)
First name: Jorge
Last name: Rodriguez
Age: 23
Register a participant (or enter no first name to stop)
First name: Min
Last name: Young
Age: 24
Register a participant (or enter no first name to stop)
First name:
Walker, Emma (24)
Rodriguez, Jorge (23)
Young, Min (24)
Meal Planning
Video Transcript
Write a program that creates a meal plan for several days. Get a list of meals and print them out. Each individual meal needs a grain, vegetable, and fruit.
For example:
content_copy
Copy
Plan a meal
Grain: rice
Vegetable: broccoli
Fruit: strawberry
Plan a meal
Grain: pasta
Vegetable: peas
Fruit: cranberry
Plan a meal
Grain: bread
Vegetable: carrots
Fruit: apples
Plan a meal
Grain:

You planned 3 meals:
Grain: rice, Vegetable: broccoli, Fruit: strawberry
Grain: pasta, Vegetable: peas, Fruit: cranberry
Grain: bread, Vegetable: carrots, Fruit: apples
Planning
See if you can write this program with a friend. You have starter code in the zip file above, in the file called meal_planner.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Start by decomposing the problem into functions! What are the functions you would use in main()?
Maybe you recognized that this problem is quite similar to the registration program above. You can use two functions in main:
content_copy
Copy
def main():
    meals = get_meals()
    print_meals(meals)
get_meals() should return a list of tuples, with each one storing (grain, vegetable, fruit)
print_meals() should use the list of tuples to print out the meal information.
Getting the meals
To get the meals, we can follow the same steps as we did when gretting the participants, above:
content_copy
Copy
def get_meals():
    meals = []
    while True:
        meal = get_meal()
        if meal is None:
            break
        meals.append(meal)
    return meals
Start with an empty list.
Loop forever
Get a meal.
If the meal is None, break
Otherwise append the meal to the list
Return the meals
Getting one meal
To get one meal, we can do the same as when getting one participant:
content_copy
Copy
def get_meal():
    print('Plan a meal')
    grain = input('Grain: ')
    if grain == '':
        return None
    vegetable = input('Vegetable: ')
    fruit = input('Fruit: ')
    return grain, vegetable, fruit
Print the instructions.
Get the grain.
If the grain is an empty string, return None.
Otherwise get the rest of the meal info (vegetable, fruit) and return a tuple of (grain, vegetable, fruit)
Notice that in this case, we left off the parentheses when returning the tuple:
content_copy
Copy
return grain, vegetable, fruit
This is OK! Python still understands that we are returning a tuple.
Printing the meals
To print the meals, we can loop through them and use unpacking:
content_copy
Copy
def print_meals(meals):
    print()
    print(f'You planned {len(meals)} meals:')
    for grain, vegetable, fruit in meals:
        print(f'Grain: {grain}, Vegetable: {vegetable}, Fruit: {fruit}')

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Float
We have previously used integers:
content_copy
Copy
number = 7
A float is a floating point number, or in other words, a number with a decimal point:
content_copy
Copy
number = 7.34
If you want to read a decimal using input(), remember that input() always returns a string. You will need to convert the string to a float:
content_copy
Copy
if __name__ == '__main__':
    response = input('Enter a rating between 1 and 10: ')
    rating = float(response)
    print(f"Your rating: {rating}")
You can also do this in one step:
content_copy
Copy
if __name__ == '__main__':
    rating = float(input('Enter a rating between 1 and 10: '))
    print(f"Your rating: {rating}")
Round
Often when you work with floats you will want to round them:
content_copy
Copy
number = 7.3478
rounded = round(number, 2)
print(rounded)
This will round 7.3478 to two decimal places, printing:
content_copy
Copy
7.35
You can round to any number of decimal places you want:
content_copy
Copy
number = 7.3478
rounded = round(number, 3)
print(rounded)
This will print:
content_copy
Copy
7.348
Here is another example:
content_copy
Copy
if __name__ == '__main__':
    apples = 7
    people = 3
    per_person = round(apples / people, 1)
    print(f'Each person gets { per_person } apples')
This prints:
content_copy
Copy
Each person gets 2.3 apples

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Lists of Tuples
Any time you store data in a list you can work with that data using the list patterns we have learned:
map — create a new list that has the same number of items as the original list, with each item in the original list mapped to an item in the new list
filter — create a new list that has only some of the items of the original list
select — choose a single value from the list
accumulate — add or subtract the values in a list
We will show you a few examples of how to do this with lists of tuples.
Scaling a recipe
Write a program that scales a recipe, for example doubles or triples it. First, the person running the program inputs a list of ingredients. For each ingredient, they should provide the item, the quantity, and the units (for example, cups or tsps). Then the person enters a scaling factor (for example, 2 or 3). The program then prints otu the recipe scaled to that factor, with all quantities rounded to 1 decimal place. For example:
content_copy
Copy
What ingredients are in your recipe?
Ingredient: flour
Quantity: 2
Unit: cups
Ingredient: salt
Quantity: 1
Unit: tsps
Ingredient: baking soda
Quantity: 1
Unit: tsps
Ingredient: water
Quantity: 1
Unit: cups
Ingredient:
Scaling factor: 2.5
New Recipe:
  5.0 (cups) flour
  2.5 (tsps) salt
  2.5 (tsps) baking soda
  2.5 (cups) water
Planning
See if you can write this program with a friend. You have starter code in the zip file above, in the file called recipe.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Start by decomposing the problem into functions! What are the functions you would use in main()?
Here is one way to design the program:
Notice that the black arrows show return values being stored in variables, and blue arrows show those variables being used as arguments in other functions.
We can put this into code:
content_copy
Copy
def main():
    recipe = get_ingredients()
    factor = get_factor()
    recipe = scale_recipe(recipe, factor)
    print_recipe(recipe)
Getting ingredients
To get the ingredients, we need to loop forever, getting one ingredient at a time, until an ingredient is None:
content_copy
Copy
def get_ingredients():
    print('What ingredients are in your recipe?')
    recipe = []
    while True:
        item = get_ingredient()
        if item is None:
            break
        recipe.append(item)
    return recipe
This follows the same pattern we saw when doing practice with tuples.
Likewise, to get an individual ingredient we input for each of the pieces of information we need, and return either None or a tuple:
content_copy
Copy
def get_ingredient():
    ingredient = input('Ingredient: ')
    if not ingredient:
        return None
    quantity = float(input('Quantity: '))
    unit = input('Unit: ')
    return ingredient, quantity, unit
Getting a factor
To get a factor, we need to ask the person to enter a number. This could be a floating point number, like 2.5! Remember, input() can only return a string, so to convert an integer into a float, we can do this:
content_copy
Copy
def get_factor():
    response = input('Scaling factor: ')
    factor = float(response)
    return factor
Alternatively, we can do this all in one line:
content_copy
Copy
def get_factor():
    return float(input('Scaling factor: '))
Scaling the recipe
OK, now comes the part where we need to scale the recipe by the factor. So we need to write this function:
content_copy
Copy
def scale_recipe(recipe, factor):
It takes a recipe, which is a list of ingredients, and a factor, which is a float. Here is an example of what the recipe could have:
content_copy
Copy
recipe = [('flour', 2.0, 'cups'), ('salt', 1.0, 'tsps'), ('baking soda', 1.0, 'tsps'), ('water', 1.0, 'cups')
To scale the recipe, we need to map each ingredient to a new ingredient that has, for example, twice as much. The amount we use for the mapping is in the factor variable:
content_copy
Copy
new_item = (ingredient, quantity * factor, unit)
Here is the complete function:
content_copy
Copy
def scale_recipe(recipe, factor):
    new_recipe = []
    for ingredient, quantity, unit in recipe:
        new_item = (ingredient, quantity * factor, unit)
        new_recipe.append(new_item)
    return new_recipe
Printing the recipe
The last step is to print the recipe:
content_copy
Copy
def print_recipe(recipe):
    print('New Recipe:')
    for ingredient, quantity, unit in recipe:
        print(f'  {quantity} ({unit}) {ingredient}')
You should be able to run the program and see it working.
Fishing
Write a program that allows a person to input information on a series of fish they have caught. For each catch, the person should provide the place, type, and size (in inches) of the fish. Then allow the person to specify a type of fish to report on. For that type, print a report indicating:
the total number of fish of that type
the catch with the largest fish of that type
For example:
content_copy
Copy
Place: Utah Lake
Type of fish: Trout
Size (inches): 6
Place: Lake Powell
Type of fish: Bass
Size (inches): 12
Place: Flaming Gorge
Type of fish: Bass
Size (inches): 18
Place: Strawberry
Type of fish: Trout
Size (inches): 13
Place: Bear Lake
Type of fish: Trout
Size (inches): 15
Place:
Fish type: Trout
Total # of Trout: 3
Best Trout catch: 15.0 inches at Bear lake
Planning
See if you can write this program with a friend. You have starter code in the zip file above, in the file called fishing.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Start by decomposing the problem into functions! What are the functions you would use in main()?
Here is one way to design the program:
Notice that the black arrows show return values being stored in variables, and blue arrows show those variables being used as arguments in other functions.
Since this is a more complicated program, let’s work one step at a time, and just get the catches first:
content_copy
Copy
def main():
    catches = get_catches()
    print(catches)
Getting the catches
Getting the catches is just like the previous problems we have worked on:
content_copy
Copy
def get_catches():
    catches = []
    while True:
        catch = get_catch()
        if catch is None:
            break
        catches.append(catch)
    return catches
Start with an empty list of fish
Loop forever
Get info on a fish caught
If the catch is None, break
Otherwise, append the fish to the list of catches
Return the list of fish caught
To get info on an individual fish that was caught:
content_copy
Copy
def get_catch():
    place = input('Place: ')
    if place == '':
        return None
    fish = input('Type of fish: ')
    size = float(input('Size (inches): '))
    return place, fish, size
We should be able to run this program and enter a few fish:
content_copy
Copy
Place: Utah Lake
Type of fish: Trout
Size (inches): 6
Place: Lake Powell
Type of fish: Bass
Size (inches): 12
Then you will see the program print out the list of tuples:
content_copy
Copy
[('Utah Lake', 'Trout', 6.0), ('Lake Powell', 'Bass', 12.0)]
Great!
Filtering the fish
The next step in our diagram is to get a fish type and then filter the list of catches with that type. By filter we mean return a new list of fish that has only fish of that type.
First, modify main():
content_copy
Copy
def main():
    catches = get_catches()
    fish_type = get_fish_type()
    catches_of_fish = filter_to_type(catches, fish_type)
    print(catches_of_fish)
This will let us do the next step and print out the filtered list of fish, to be sure that next step is working.
Now we can write get_fish_type():
content_copy
Copy
def get_fish_type():
    return input('Fish type: ')
This is probably the easiest function you will write all semester. :-)
We can also write filter_to_type():
content_copy
Copy
def filter_to_type(catches, fish_type):
    keepers = []
    for place, fish, size in catches:
        if fish == fish_type:
            keepers.append((place, fish, size))
    return keepers
We chose to use keepers as the variable here because it does a good job of showing what filter does — it “keeps” some of the items in the original list, but throws the rest away.
We loop through all the catches, unpacking them as we go. Then only if fish == fish_type do we append the fish to the keepers.
If you run this, and enter the following:
content_copy
Copy
Place: Utah Lake
Type of fish: Trout
Size (inches): 6
Place: Lake Powell
Type of fish: Bass
Size (inches): 12
Place:
Fish type: Trout
Then the program should print:
content_copy
Copy
[('Utah Lake', 'Trout', 6.0)]
Notice how the filter works by creating a new list that keeps only the tuples we want.
Printing a report
Modify main() one more time:
content_copy
Copy
def main():
    catches = get_catches()
    fish_type = get_fish_type()
    catches_of_fish = filter_to_type(catches, fish_type)
    print_report(catches_of_fish, fish_type)
Now we have a complete program. We just need to write print_report():
content_copy
Copy
def print_report(catches, fish_type):
    place, fish, size = find_max(catches)

    print(f'Total # of {fish_type}: {len(catches)}')
    print(f'Best {fish} catch: {size} inches at {place}')
We want to have a function called find_max() that returns a tuple with all the information about the largest fish caught. This is an example of a select function. We want to select one of the tuples out of the list of tuples.
content_copy
Copy
def find_max(catches):
    best_fish = None
    best_place = None
    best_size = None
    for place, fish, size in catches:
        if best_size is None or size > best_size:
            best_size = size
            best_fish = fish
            best_place = place
    return best_place, best_fish, best_size
Start by creating three variables, one for each part of the tuple.
Initialize each of these variables to None to represent the fact that the largest fish hasn’t been found yet.
Loop through all of the fish, using unpacking
if the best size is None or the current size is bigger than the best size, then change all of the three variables to match this fish
Return a tuple with information about the biggest fish
Now you can run the program one more time and it should print out the report we need!

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Strings
We have previously seen strings. Here we will show you quite a few more details.
A string is surrounded by single or double quotes:
content_copy
Copy
name = 'Mariano'
food = "homemade lasagna is the best"
You can get the length of a string with len(), the same as the length of a list:
content_copy
Copy
if __name__ == '__main__':
    name = 'Mariano'
    food = "homemade lasagna is the best"
    print(len(name))
    print(len(food))
    print(f"'{name}' has {len(name)} characters and '{food}' has {len(food)} characters.")
This will print:
content_copy
Copy
7
28
'Mariano' has 7 characters and 'homemade lasagna is the best' has 28 characters.
Concatenating strings
You can use several operations with strings. If you add strings, they are concatenated. So this:
content_copy
Copy
result = 'fire' + 'place'
will set result to 'fireplace'.
Often you will need to take an existing string and add on to it:
content_copy
Copy
result = 'hello'
result = result + ' '
result = result + 'there'
Now result references "hello there".
You can do this more easily with +=:
content_copy
Copy
result = 'hello'
result += ' '
result += 'there'
Accumulating a result with concatenation
Concatenation is particularly useful when you want to accumulate a result. For example:
content_copy
Copy
def collect_words():
    result = ''
    while True:
        word = input('Enter a word: ')
        if word == '':
            break
        if result != '':
            result += ' '
        result += word

    return result


if __name__ == '__main__':
    print(collect_words())
In this code we use the result variable to accumulate all of the words a person types. We use the += to add in each word. We also use += to add a space between the words. We use one litle trick to do this. Notice:
content_copy
Copy
if result != '':
    result += ' '
We don’t add the space if result is an empty string. This prevents us from adding a space at the start of result before we have concatenated any words. This prevents us from adding space the first time through the loop.
When you run this code, you might see:
content_copy
Copy
Enter a word: Yer
Enter a word: a
Enter a word: wizard
Enter a word: Harry
Enter a word:
Yer a wizard Harry
Iterating over the characters in a string
You will recall that we have iterated over lists of numbers:
content_copy
Copy
numbers = [1, 2, 3]
for number in numbers:
    print(number)
lists of strings:
content_copy
Copy
names = ["Mario", "Maria", "Magda"]
for name in names:
    print(name)
and even lists of tuples:
content_copy
Copy
players = [('John', 42), ('Emma', 33), ('Jose', 10), ('Rosaria', 18)]
for name, jersey in players:
    print(f"{name} wears jersey number {jersey}")
We can likewise iterate over the characters in a string:
content_copy
Copy
line = 'what a life'
for character in line:
    print(character)
This will print out each character, including spaces, on a separate line:
content_copy
Copy
w
h
a
t

a

l
i
f
e
Functions for testing strings
Following are some of the functions you can use to test strings:
islower(): returns true if all characters are lowercase
isupper(): returns true if all characters are uppercase
isalpha(): true if all characters are alphabetic
isdigit(): true if all characters are digits
isalnum(): true if all characters are alphanumberic (alphabetic or digits)
isspace(): true if all characters are white space (space, tab, newline)
For example:
content_copy
Copy
'abc'.islower()    # True
'abC'.islower()    # False
'ABC'.isupper()    # True
'ABc'.isupper()    # False
'a'.isalpha()      # True
'ab3'.isalpha()    # False
'8'.isdigit()      # True
'89a'.isdigit()    # False
'89a'.isalnum()    # True
' \t\n'.isspace()  # True
All of these functions work on variables that reference strings, whether those strings are one or many characters long. For example:
content_copy
Copy
password = 'adam123'
if password.alnum():
    print('Yes')
else:
    print('No')
This will print Yes.
Capitalization
These functions will change capitalization:
upper(): returns a new string that is all uppercase
lower(): returns a new string that is all lowercase
For example:
content_copy
Copy
'abc'.upper()                  # 'ABC'
'ABC'.lower()                  # 'abc'
'aBc'.lower()                  # 'abc'
'ABC'.lower() == 'abc'.lower() # True
No spaces
Write a function that replaces all space characters in a string with dashes.
Work with a friend to write this code. This should take only one function. You can find starter code in no_spaces.py.
Here is a solution:
content_copy
Copy
def no_spaces(text):
    result = ''
    for c in text:
        if c.isspace():
            c = '-'
        result += c
    return result
We use the accumulate pattern to build up the result string in the variable called result. As we loop through the string, charcter by character, we change the character to be a '-' if it is a space. We then append the character to the result string.
Replacing numbers
Write a function that replaces every number in a string with a ?.
Work with a friend to write this code. This should take only one function. You can find starter code in replace_numbers.py.
Here is a solution:
content_copy
Copy
def no_numbers(text):
    result = ''
    for char in text:
        if char.isdigit():
            result += '?'
        else:
            result += char
    return result
We again use the accumulate pattern. Here instead of changing the character to ? if it is a number, we append a ?. Notice that this means we need to use else and have two places where we accumulate into the result string.
This problem is very similar to the No spaces, and either solution could be written in either style.
Sum digits
Write a function that sums all the digits in a string.
Work with a friend to write this code. This should take only one function. You can find starter code in sum_digits.py.
Here is a solution:
content_copy
Copy
def sum_digits(text):
    """Add all the digits found in the `text`."""
    total = 0
    for c in text:
        if c.isdigit():
            total += int(c)
    return total
This also uses the accumulate pattern. Surprise! :-) We use total to keep track of the total. And we have to use int() to convert the character to an integer that we can add into total.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Substrings
When working with strings, you often want to manipulate substrings, meaning a piece of the string.
Replacing substrings
You can use the replace() function to replace a substring with another substring. For example:
content_copy
Copy
text = 'Yesterday I read an amazing book.'
new_text = text.replace('amazing', 'intriguing')
print(new_text)
This will print:
content_copy
Copy
Yesterday I read an intriguing book.
Remember, a string is just a sequence of characters, so this isn’t only for replacing words:
content_copy
Copy
text = 'Yesterday I read an amazing book.'
new_text = text.replace(' ', '-')
print(new_text)
This prints:
content_copy
Copy
Yesterday-I-read-an-amazing-book.
Or:
content_copy
Copy
text = 'Yesterday I read an amazing book.'
new_text = text.replace('n amazing', ' sad')
print(new_text)
This prints:
content_copy
Copy
Yesterday I read a sad book.
Limited replacement
By default, replace() will replace all occurrences of the substring. You can limit this by adding a third parameter. For example, let’s say you want to replace the first space with a comma and a space:
content_copy
Copy
text = 'Yesterday I read an amazing book.'
new_text = text.replace(' ', ', ', 1)
print(new_text)
This prints:
content_copy
Copy
Yesterday, I read an amazing book.
Or maybe:
content_copy
Copy
text = 'The villain laughed: "HAHAHAHAHA"'
text = text.replace('HA', 'ha', 3)
print(text)
This prints:
content_copy
Copy
The villain laughed: "hahahaHAHA"
You can find all the substring replacement examples in replacing_substrings.py.
Checking for a substring
You can check whether a substring is present in a string using in. This results in very natural syntax:
content_copy
Copy
if 'BYU' in 'I am a student at BYU.':
    print('Hurray!')
else:
    print('Boo!')
This prints:
content_copy
Copy
Hurray!
Likewise:
content_copy
Copy
if 'BYU' in 'This room is full of monkeys!':
    print('Hurray!')
else:
    print('Boo!')
This prints:
content_copy
Copy
Boo!
Custom character classes
Using in allows us to create custom character classes. For example, here is a function that returns True if a letter is a vowel:
content_copy
Copy
def is_vowel(letter):
    return letter in 'AEIOUaeiou'
We can use this in the following code:
content_copy
Copy
if __name__ == '__main__':
    found = ''
    for letter in 'The Aeneid is ancient Greek literature.':
        if is_vowel(letter):
            found += letter
    print(found)
You can find this code in collect_vowels.py. This code prints:
content_copy
Copy
eAeeiiaieeeieaue
Let’s write a function that capitalizes every letter of a string that is a part of “BYU”:
content_copy
Copy
def byu(text):
    """Capitalize every letter of `text` that is part of 'BYU'"""
    result = ''
    for c in text:
        if c in 'byu':
            result += c.upper()
        else:
            result += c
    return result
Now we can call this:
content_copy
Copy
if __name__ == '__main__':
    print(byu('Any student, boy or girl, young or old, can be a yodeler.'))
You can find this code in capitalize_byu.py. This prints:
content_copy
Copy
AnY stUdent, BoY or girl, YoUng or old, can Be a Yodeler.
Early return
Using in works well with a pattern called early return. For example, here is a function that checks whether a string has brackets in it:
content_copy
Copy
def is_bracket(letter):
    return letter in '{}[]<>'

def has_brackets(text):
    for letter in text:
        if is_bracket(letter):
            return True
    return False
Notice that in has_bracket(), as soon as we find a bracket, we can return True. We don’t have to loop through the rest of the characters. By default, if we loop through all characters and don’t find the bracket, then we return False.
We can call it:
content_copy
Copy
if __name__ == '__main__':
    print(has_brackets('Just some words'))
    print(has_brackets('A Python list prints like this: [1, 2, 3, 4]'))
You can find this code in has_brackets.py. Running it will print:
content_copy
Copy
False
True
Odd numbers
Write a function that indicates whether a string has odd-numbered digits in it.
Work with a friend to write this code. You can find starter code in odd_numbers.py.
Here is a solution:
content_copy
Copy
def is_odd_digit(letter):
    return letter in '13579'


def has_odds(text):
    """Return True if the text has odd-numbered digits"""
    for letter in text:
        if is_odd_digit(letter):
            return True
    return False


def main():
    print(has_odds('I have 2 apples to share with 4 people.'))
    print(has_odds('I have 2 apples, and there are 3 people, but I will eat them all!'))


if __name__ == '__main__':
    main()
Notice that we use the early return pattern in has_odds().
This prints:
content_copy
Copy
False
True
True blue
Write a function that indicates whether a text has any of the following substrings in it:
BYU
blue
cougar
Work with a friend to write this code. You can find starter code in true_blue.py.
Here is a solution:
content_copy
Copy
def is_true_blue(text):
    """Returns True if `text` contains any of: 'BYU', 'blue', or 'cougar'"""
    for word in ['BYU', 'blue', 'cougar']:
        if word in text:
            return True
    return False


def main():
    print(is_true_blue('My friend goes to UVU'))
    print(is_true_blue('I love BYU!'))
    print(is_true_blue('The sky is blue'))


if __name__ == '__main__':
    main()
This prints:
content_copy
Copy
False
True
True
In with lists
We can also use in with lists:
content_copy
Copy
def is_suspect(person):
    return person in ['John', 'Jane', 'Susan', 'Carlos', 'Kathy', 'Morgan']
This function returns True if the person supplied as the parameter is one of the strings in the list of strings ['John', 'Jane', 'Susan', 'Carlos', 'Kathy', 'Morgan'].
Here is how we can use it:
content_copy
Copy
def identify_suspects(people):
    suspects = []
    for person in people:
        if is_suspect(person):
            suspects.append(person)
    return suspects


if __name__ == '__main__':
    students = ['George', 'Hannah', 'Kathy', 'Michael', 'John']
    print(identify_suspects(students))
    neighbors = ['Carl', 'Brooke', 'Jane', 'Jarom', 'Sally', 'John', 'Mike']
    print(identify_suspects(neighbors))
In identify_suspects(), we take a list of names, loop over them, and return a new list that has only the names that are suspects.
You can find this code in identify_subjects.py. When you run it, it prints:
content_copy
Copy
['Kathy', 'John']
['Jane', 'John']
Multiple comparisons
This is extra material
What if we want to find a suspected student who is also a neighbor? Here is a function that takes a list of students and a list of neighbors and finds the suspects who are also neighbors:
content_copy
Copy
def find_key_suspects(students, neighbors):
    suspected_students = identify_suspects(students)

    key_suspects = []
    for person in suspected_students:
        if person in neighbors:
            key_suspects.append(person)
    return key_suspects
We can use this function this way:
content_copy
Copy
def is_suspect(person):
    return person in ['John', 'Jane', 'Susan', 'Carlos', 'Kathy', 'Morgan']


def identify_suspects(people):
    suspects = []
    for person in people:
        if is_suspect(person):
            suspects.append(person)
    return suspects


def find_key_suspects(students, neighbors):
    suspected_students = identify_suspects(students)

    key_suspects = []
    for person in suspected_students:
        if person in neighbors:
            key_suspects.append(person)
    return key_suspects


if __name__ == '__main__':
    students = ['George', 'Hannah', 'Kathy', 'Michael', 'John']
    neighbors = ['Carl', 'Brooke', 'Jane', 'Jarom', 'Sally', 'John', 'Mike']
    print(find_key_suspects(students, neighbors))
You can find this code in identify_suspect_neighbors.py. When you run it, it prints:
content_copy
Copy
['John']
There are other ways to solve this problem! You could also take the list of students and filter out any that are not neighbors, using the filter pattern, then find suspects:
content_copy
Copy
def is_suspect(person):
    return person in ['John', 'Jane', 'Susan', 'Carlos', 'Kathy', 'Morgan']


def filter_to(population, group):
    keepers = []
    for item in population:
        if item in group:
            keepers.append(item)
    return keepers


def identify_suspects(people):
    suspects = []
    for person in people:
        if is_suspect(person):
            suspects.append(person)
    return suspects


def find_key_suspects(students, neighbors):
    student_neighbors = filter_to(students, neighbors)
    key_suspects = identify_suspects(student_neighbors)
    return key_suspects


if __name__ == '__main__':
    students = ['George', 'Hannah', 'Kathy', 'Michael', 'John']
    neighbors = ['Carl', 'Brooke', 'Jane', 'Jarom', 'Sally', 'John', 'Mike']
    print(find_key_suspects(students, neighbors))
This code is in identify_suspect_neighbors_alternate.py.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Practice with strings
Following are some practice problems with strings and substrings.
Fruits
Video Transcript
For this problem, write a program that asks you to enter a list of fruits. If you enter a fruit that has already been given, the program should say “You already said that.” The program should ignore casing (uppercase vs lowercase), so “Banana” is the same as “banana”.
Once 10 unique fruits have been entered, print “Way to go!” and end the program. Here is an example of input and output for this program:
content_copy
Copy
Fruit: pear
Fruit: apple
Fruit: pear
You already said that.
Fruit: kiwi
Fruit: banana
Fruit: pear
You already said that.
Fruit: apple
You already said that.
Fruit: orange
Fruit: lemon
Fruit: lime
Fruit: cherry
Fruit: orange
You already said that.
Fruit: guava
Fruit: plum
Way to go!
Planning
Work with a friend to write this code. You can find starter code in fruits.py. Try drawing a flow chart.
Here is a flow chart that shows a solution to this problem:
Notice that we are careful to lowercase the fruit a person enters. This is needed so that Banana, banana, and BaNAnA are all treated the same.
Writing code
Try translating this flow chart into code on your own.
Below is code that corresponds to the flow chart, with comments showing the relevant piece of the flow chart.
content_copy
Copy
def main():
    # make an empty list
    fruits = []
    # do we have 10 fruits yet?
    while len(fruits) < 10:
        # get a fruit and lowercase it
        fruit = input('Fruit: ').lower()
        # already in the list?
        if fruit in fruits:
            # you already said that
            print('You already said that.')
        else:
            # append to the list
            fruits.append(fruit)
    # way to go!
    print('Way to go!')
You should be able to run this code and get something like the example shown above.
Organized
Video Transcript
Write a program that “organizes” the things you type into it. “Organized” text means that all the characters are reordered to this sequence:
lowercase letters
uppercase letters
digits
everything else
whitespace is removed
Here is an example of input and output for this program:
content_copy
Copy
Text: Hello, what is your name?
ellowhatisyournameH,?
Text: BYU is my favorite school!
ismyfavoriteschoolBYU!
Text: 3.14159 is a loose approx. for PI.
isalooseapproxforPI314159...
Text:
Planning
Work with a friend to write this code. You can find starter code in organized.py. Try drawing a flow chart.
Here is a flow chart that shows a solution to this problem:
This leaves out a lot of details! But this is how you should start — do the big picture first, and then fill in the details.
Writing code
Since this flow chart is so simple, it is easy to turn it into code:
content_copy
Copy
def main():
    while True:
        text = input('Text: ')
        if text == '':
            break
        print(organize(text))
We have put all the details of organizing the text into one function — organize().
Planning the next steps
Now we need a flow chart for organizing a string of text. If you haven’t done this piece yet, work with a friend to draw this out.
Here is one way to do this:
A few important notes:
We are going to keep a variable that stores a string of lowercase letters, another one for uppercase letters, one for digits, and one for all other characters.
We are going to loop through the characters one at a time and then append each character to the appropriate variable. The blue box is illustrating a for loop.
We ignore spaces.
At the end, we can concatenate all the string variables together to get the final result.
Writing more code
Try translating this flow chart into code on your own. You are trying to write the organize() function.
OK, here is a good solution:
content_copy
Copy
def organize(text):
    lowers = ''
    uppers = ''
    digits = ''
    others = ''
    for c in text:
        if c.islower():
            lowers += c
        elif c.isupper():
            uppers += c
        elif c.isdigit():
            digits += c
        elif c.isspace():
            pass
        else:
            others += c

    return lowers + uppers + digits + others
This is pretty simple code that follows the flow chart. We set up variables for each type of character, then we loop through all the characters and add them to the appropriate variable. We skip spaces. At the end, we return the concatenation of all the string variables.
You should be able to run this code and get something like the example shown above.
Word swap
Video Transcript
Write a program that asks a person to enter a phrase, then two words or substrings to swap. Then swap the two words and print the result.
Here is some example input and output:
content_copy
Copy
Phrase: It's raining cats and dogs.
Word 1: cats
Word 2: dogs
It's raining dogs and cats.
Phrase: Do you like where you live?
Word 1: ke
Word 2: ve
Do you live where you like?
Phrase:
Planning
Work with a friend to write this code. You can find starter code in word_swap.py. Try drawing a flow chart.
Here is a flow chart that shows a solution to this problem:
Hopefully you are getting the hang of this! Using a flow chart is a great way to organize your thoughts before you begin to code.
Writing code
Try translating this flow chart into code on your own.
Below is code that corresponds to the flow chart:
content_copy
Copy
def main():
    while True:
        text = input('Phrase: ')
        if text == '':
            break
        word1 = input('Word 1: ')
        word2 = input('Word 2: ')
        print(swap(text, word1, word2))
As with the previous problem, we put all the work in a separate function, swap().
Swapping
Now comes the tricky part. How do we swap? A simple, but wrong way to to do this is below:
content_copy
Copy
def swap(text, word1, word2):
    text = text.replace(word1, word2)
    text = text.replace(word2, word1)
    return text
What will happen if we have the phrase It's raining cats and dogs. and then we want to swap cats and dogs? We will first replace cats with dogs and get: It's raining dogs and dogs. Then we will replace dogs with cats and get: It's raining cats and cats. Not good!
We have to instead do this:
replace word1 with a special symbol, e.g. @@@@
replace word2 with word1
replace @@@@ with word2
If we do this, we will get these strings:
It's raining @@@@ and dogs.
It's raining @@@@ and cats.
It's raining dogs and cats.
Here is the code:
content_copy
Copy
def swap(text, word1, word2):
    symbol = '@@@@'
    text = text.replace(word1, symbol)
    text = text.replace(word2, word1)
    text = text.replace(symbol, word2)
    return text
If you run this code, you should be able to see output like above.
Calling replace multiple times
It turns out that we can rewrite the swap function above as:
content_copy
Copy
def swap(text, word1, word2):
    symbol = '@@@@'
    return text.replace(word1, symbol).replace(word2, word1).replace(symbol, word2)
Why is this?
When you call replace(), the syntax is as follows:
It turns out that replace() returns a new string. So this means you can call it repeatedly:
content_copy
Copy
text = 'Yesterday I read an amazing book.'
new_text = text.replace('amazing', 'intriguing').replace('Yesterday', 'Today')
print(new_text)
This prints:
content_copy
Copy
Today I read an intriguing book.
This works for any string function:
content_copy
Copy
text = 'Yesterday I read an amazing book.'
new_text = text.replace('amazing', 'intriguing').replace('Yesterday', 'Today').upper()
print(new_text)
This prints:
content_copy
Copy
TODAY I READ AN INTRIGUING BOOK.
Returning to our swap() function:
content_copy
Copy
def swap(text, word1, word2):
    symbol = '@@@@'
    return text.replace(word1, symbol).replace(word2, word1).replace(symbol, word2)
Now you can see that we can chain together three calls to replace() and then return the final result, all in one step.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Using the terminal
If you have a Windows computer use the guide for the Windows terminal setup to configure your system.
Video Transcript
Normally, you will interact with your computer using a visual interface. For example, on Windows, you can use the File Explorer:
and on MacOS you can use the Finder:
Developers will often use a terminal to access the files on their computer. A terminal is a textual interface to all of the same directories and files that you can see visually.
Opening the terminal in PyCharm
In PyCharm you can access the terminal by clicking the Terminal tab at the bottom:
The terminal is opened on the bottom by default. If you are using Windows, your prompt will look like this, ending with a >:
content_copy
Copy
(venv) PS C:\Users\zappala\Documents\cs110>
If you are using MacOS, your prompt will look like this, ending with a %:
content_copy
Copy
zappala@copenhagen cs110 %
Your prompt is where you can type commands in the terminal. After you type a command, you will see a response below your command, with a new prompt.
Navigating the file system
On Windows, the file system is organized as a set of trees:
On MacOS, it looks like this:
Each icon shown in these diagrams is a directory. Directories contain files.
There are several basic commands that will let you navigate and view your file system:
pwd — print the name of the current directory
ls — list folders and files in the current directory
cd — change directory
When you open the terminal from inside PyCharm, you are placed inside the directory for your project. If you created a single project for CS 110 in a cs110 folder, then you are in that folder, e.g. C:\Users\zappala\Documents\cs110>.
The pwd command
Type the pwd command at the prompt and you will see the current directory. On Windows it will look like this:
And on MacoS it will look like this:
You may notice that your prompt will also show you your current directory, so you may not need to use this command often, but it can be helpful if you are confused.
The ls command
Type the ls command at the prompt to list the directories and files in the current directory:
If you are starting out in your cs110 directory, you will probably see the directories for all of the labs, homeworks, and projects you have done so far.
The cd command
Type the following command:
content_copy
Copy
cd lab0
This command mvoes you into the lab0 directory:
Notice how the prompt in the terminal changes to reflect the fact that you are now in the lab directory. You can type ls to see what files are there.
Now type:
content_copy
Copy
cd ..
This will go back to the parent direcotry, which in this case should be cs110, the directory we were previously in. You can type ls again to see the files here again.
Notice how cd essentially moves you down to a child directory or up to the parent directory.
Running python programs
If you are in the same directory as a program, you can run it. You should have a lab0 directory, but if not, you can download the zip file for lab0.
First, cd into the lab0 directory and use ls to list what is there:
Notice you have two more directories here — hello and intro. Now cd into the hello directory and use ls to see what is there:
Now you can see the hello.py program. You can run it like this:
content_copy
Copy
python hello.py
You should see the program run:
You should be able to do the following to run the other program that came with Lab 0:
content_copy
Copy
cd ..
cd intro
python introduce-yourself.py
The exit command
You can exit out of a terminal using the exit command. Any time you use exit, the next time you open the terminal you will be back at the main directory for your project, which should be cs110.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Program arguments
When we run a Python program from the command line, we can give it arguments. Suppose you want a program called “repeat.py” to print “wow” 10 times. You might run it from the terminal like this:
content_copy
Copy
python repeat.py wow 10
This will run the program in repeat.py and give it these arguments — wow and 10. This program could then print “wow” 10 times.
argv
To get the arguments into your program, Python puts them into a list called argv. To use argv, you have to:
content_copy
Copy
import sys
Then you can get the arguments in sys.argv:
content_copy
Copy
import sys


if __name__ == '__main__':
    print("Your arguments were:")
    print(sys.argv)
In the zip file for this guide you can find a program called arg_demo.py. If you download the zip file and put it in your cs110 directory, then you can open a terminal and run it with:
content_copy
Copy
cd arguments
python arg_demo.py first second third
then this will print:
content_copy
Copy
Your arguments were:
['arg_demo.py', 'first', 'second', 'third']
Notice how the first argument in the list is the name of the program. Then the rest of the arguments come after that.
Accessing individual arguments
Let’s talk about how a Python program gets access to these arguments. Remember, sys.argv is a list. We can number all of the items in the list starting from zero:
With all lists, we can use indexing to select an item in the list. We do this with square brackets:
content_copy
Copy
argument1 = sys.argv[1]
argument2 = sys.argv[2]
If you look at hello.py you can see this in action:
content_copy
Copy
import sys


if __name__ == '__main__':
    print(f'Hello {sys.argv[1]}!')
This program takes one argument — a name — and says “Hello {name}!“. You can see this by running:
content_copy
Copy
python hello.py Harry
You will see:
content_copy
Copy
python hello.py Harry
Hello Harry!
If you try to run a program that is expecting an argument without any arguments, this causes an error:
This is because you tried to access item 1 from the sys.argv list, and there is nothing at that index.
You can also run a program with too many arguments, but this won’t cause an error. The extra arguments will just be ignored. Try:
content_copy
Copy
python hello.py Harry Ron Hermione
Another example is in repeat.py:
content_copy
Copy
import sys


def repeat(text, number):
    print(text * number)


if __name__ == '__main__':
    text = sys.argv[1]
    number = int(sys.argv[2])
    repeat(text, number)
Every argument in sys.argv is a string. This means we need to convert the second argument into a number if we would like to use it as a number. Then we call a function repeat(), which just uses text * number to repeat the string that many times. It turns out that you can multiply a string by a number to repeat it! So:
Arguments with spaces in them
What if you want to put spaces in an argument? You need to put quotes around the argument:
content_copy
Copy
python repeat.py 'oh wow ' 10
oh wow oh wow oh wow oh wow oh wow oh wow oh wow oh wow oh wow oh wow
Things
To practice these concepts, write a program that prompts a person to input things. After they are done, print the list of things.
The number of things to input and the prompt text should be specified on the command line as arguments. For example:
content_copy
Copy
python things.py 3 Fruit
Fruit: apple
Fruit: pear
Fruit: banana

- apple
- pear
- banana
Planning
You will find an empty file in things.py where you can write code for this.
Work with a friend to write this code. Try drawing a flow chart.
Here is an example flow chart:
The main program has three pieces:
get the arguments (number of things, prompt)
get the items
display the items
To get the items, we can accumulate the items into a list:
make an empty list
while the list doesn’t have all the items
get another item
add it to the list
Writing code
Let’s write code for the main program:
content_copy
Copy
def main(how_many, prompt):
    items = get_items(how_many, prompt)
    display_items(items)


if __name__ == "__main__":
    how_many = int(sys.argv[1])
    prompt = sys.argv[2]
    main(how_many, prompt)
Some important things to notice:
we need to convert how_many into an integer
we give both arguments to main()
main() calls the next two functions to do steps two and three in the flow chart.
Now we can write get_items():
content_copy
Copy
def get_items(how_many, prompt):
    items = []
    while len(items) < how_many:
        item = input(prompt + ': ')
        items.append(item)
    return items
We keep looping as long as the length of the list is less than the desired length, which is given in how_many. We use prompt to provide the prompt when we call input(). Every time we get an item we append it to the list.
We can also write display_items():
content_copy
Copy
def display_items(items):
    for item in items:
        print(f'- {item}')
You will need to run this program from the terminal. For example:
content_copy
Copy
python things.py 5 'Your Major'
Your Major: Bioinformatics
Your Major: Mathematics
Your Major: Linguistics
Your Major: Vocal Performance
Your Major: History

- Bioinformatics
- Mathematics
- Linguistics
- Vocal Performance
- History

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Best practices for program arguments
Only reference sys.argv inside of the main block
The main block is a special if statement:
content_copy
Copy
if __name__ == "__main__":
    # this is the main block
This main block is run whenever you use python program.py, and it only runs the main block located in program.py.
Since this is the first block of code that is run when a program is run, it is best practice to only reference sys.argv inside of this block.
Bad example
First, let’s show a bad example of a program that references sys.argv outside of the main block:
content_copy
Copy
import sys


def main():
    # this accesses sys.argv outside of the main block
    print(f"This prints sys.argv[1], {sys.argv[1]}, inside of the main function!")


if __name__ == "__main__":
    print("This is the bad example!")
    main()
Good example
Now, here’s a good example that only references sys.argv inside of the main block. We encourage you to model your code after this example.
content_copy
Copy
import sys


def main(argument: str):
    print(f"This prints the argument, {argument}, that was passed to the main function!")


if __name__ == "__main__":
    print("This is the good example")
    # This references sys.argv inside of the main block
    main(sys.argv[1])
Running the program:
content_copy
Copy
python good_example.py argument1
produces the following output:
content_copy
Copy
This is the good_example!
This prints the argument, argument1, that was passed to the main function!
While the output of both the good and bad examples are nearly the same, keeping all references to sys.argv in the main block will make a critical difference in the future as you learn about modularization and testing. Following the better design now will help you avoid trouble later.
Passing the wrong number of arguments to your program
A common error that occurs when dealing with sys.argv is an IndexError. This occurs when the user doesn’t provide enough arguments to the program and the program tries to reference an argument that doesn’t exist.
Using the good example above, running the program:
content_copy
Copy
python good_example.py
results in the following error message:
content_copy
Copy
This is the good example
Traceback (most recent call last):
  File "good_example.py", line 10, in <module>
    main(sys.argv[1])
         ~~~~~~~~^^^
IndexError: list index out of range
Here, we see that the error occured on line 10 of good_example.py. The tilde ~ and caret ^ symbols point to where the error occured. In this case, the error occured when trying to reference sys.argv[1] when using it as a parameter for the main() function.
Finally, the error message tells us that the error was an IndexError. This means that we tried to access an index of a list that doesn’t exist. In this case, sys.argv only has one item at sys.argv[0], which is the name of the program, "good_example.py". As a result, the program throws an error when it tries to access sys.argv[1].
Check the length of sys.argv before using it
It is common for a program to check the number of arguments before trying to access them. If the user doesn’t provide enough arguments, the program can print a helpful message to help the user understand which arguments they need to provide. This is easier for the user to understand than an IndexError message.
For example, you could write code like this:
content_copy
Copy
import sys


def main(argument: str):
    print(f"This prints the argument, {argument}, that was passed to the main function!")


if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("You didn't provide the correct number of arguments!")
        print("Call this program with like this:")
        print("python good_example.py argument1")
        exit()

    main(sys.argv[1])
In this class, the tests we give you will always provide the correct number of arguments to your programs, so you don’t need to worry about checking the length of sys.argv in your code.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Reading and writing files
So far we have seen several ways to get data into a program (input) and out of a program (output):
Method Type Description Example
input() input get data from the terminal response = input(“What is your name? “)
print() output print to the terminal print(f”Hello {name}“)
sys.argv input get program arguments name = sys.argv[1]
Now are are going to show you how to read data from a file (input) and write data to a file (output).
Reading from a file
To read from a file, you can use the following function:
content_copy
Copy
def readlines(filename):
    with open(filename) as file:
        return file.readlines()
This function takes the name of a file — a string, such as ‘example.txt` — and returns a list of the lines in the file. There are a couple of special things going on here:
with open(filename) as file: — This opens the filename and stores a reference to it in the variable called file. Opening a file using with starts a new block, so you need to indent after the colon :, just like with a while loop or a function.
Using open(filename) tells Python to open the listed filename for reading.
file.readlines() — This reads all of the lines in the file into a list, with one entry per line.
We use return file.readlines() to return the list of lines from the function. This breaks out of the with, the same as any early return.
The file is automatically closed after we exit the with statement.
Notice the dot . in file.readlines(). This works just like bit.move() or word.replace('a', 'e'). The syntax is variable.function(). A file supports the readlines() function, a bit supports the move() function and a string supports the replace() function.
The file reading.py contains an example of how to use this function:
content_copy
Copy
import sys


def readlines(filename):
    with open(filename) as file:
        return file.readlines()


if __name__ == '__main__':
    lines = readlines(sys.argv[1])
    print(lines)
This program takes one argument — the name of a file name. Then it reads all of the lines in the file into a list and stores them in the variable called lines. It then prints the list.
To test this program, we have provided a file called example.txt, which contains:
content_copy
Copy
One fish.
Two fish.
Red fish.
Blue fish.
When we run our program, this is what it does:
content_copy
Copy
python reading.py example.txt
['One fish.\n', 'Two fish.\n', 'Red fish.\n', 'Blue fish.\n']
The list is printed, including the square brackets, the quotes around each string, and the commas separating each item in the list. Notice that each line ends with the \n character. This represents a newline and is used in files to indicate the end of a line.
Summing the numbers in a file
Let’s look at another example. The file sum_from_file.py will add all of the numbers in a file:
content_copy
Copy
# import sys, import sys, lalaLAlalala
# we need this to use sys.argv for the arguments
import sys


def readlines(filename):
    """ Read all the lines in a file and return them in a list. """
    with open(filename) as file:
        return file.readlines()


def as_ints(str_numbers):
    """ Take a list of numbers that are strings and convert them
    to a list of integers. """
    nums = []
    for str_num in str_numbers:
        # notice that we are converting each string to an integer
        # and then appending them to a list
        nums.append(int(str_num))
    return nums


def main(filename):
    """ Read the lines in a file, convert them to a list of numbers,
    add them up, and then print the total. """
    lines = readlines(filename)
    numbers = as_ints(lines)
    # the sum() function returns the sum of a list of numbers
    total = sum(numbers)
    print(f'The total in {filename} is {total}')


if __name__ == '__main__':
    # we pass the first agument directly to the main() function
    main(sys.argv[1])
In the main block, we pass the first argument in sys.argv directly to the main() function
In the main() function we (1) read the lines of the file into a list, (2) conver the list of strings into a list of integers, (3) sum the integers, and the (4) print the total.
The readlines() function is the same as above. You should be able to use this function whenever you want to read the lines from a file.
The as_ints() function converst a list of strings into a list of integers.
We have given you a file called numbers.txt:
content_copy
Copy
1
2
3
4
and another file called more_numbers.txt:
content_copy
Copy
2
3
-4
5
-6
When you run this program, you should see:
content_copy
Copy
% python sum_from_file.py numbers.txt
The total in numbers.txt is 10
% python sum_from_file.py more_numbers.txt
The total in more_numbers.txt is 0
Writing files
To write a file, we can go in the opposite direction — take a list of strings and write them to a file. Here is a function to do that:
content_copy
Copy
def writelines(filename, content):
    with open(filename, 'w') as file:
        file.writelines(content)
writelines() takes a filename (string) and content to write (a list of strings)
with open(filename, 'w') as file: — This is just like the with statement from above when reading the file, except we have to open the file for writing by using open(filename, 'w'). Notice the second 'w' as an argument to open().
file.writelines(content) — This takes a list of strings in the content variable and writes them out to the file. The strings should end with newlines \n if you want to end the lines.
You can see an example of this in the writing.py program:
content_copy
Copy
import sys


def writelines(filename, content):
    with open(filename, 'w') as file:
        file.writelines(content)


if __name__ == '__main__':
    content = ['one\n', 'two\n', 'three\n', 'four\n']
    writelines(sys.argv[1], content)
In the main block we create content and give it a list of strings, each ended with a \n.
We call the writelines() function by giving it both the first argument to the program (the name of the file to write) and the content variable.
If you run this program, it will write the content to whatever filename you specify.
Be careful! This will erase and overwrite any existing file with that name!
We are going to run this program like this:
content_copy
Copy
$ python writing.py written.txt
This doesn’t look like it does anything when we run it! But it has silently written all of its output — from the content variable — into a new file called written.txt. You should be able to see this file in PyCharm and verify that it contains:
content_copy
Copy
one
two
three
four
File Processing Pattern
Now that you can read lines from a file and write lines to a file, we want to teach you a file processing pattern. The pattern goes like this:
read a file into list of lines
change the lines in some way
write the new list of lines to a file
We have given you the readlines() function and the writelines() function so all of your focus is on the middle part — changing the list of lines into a new list of lines. You can the list patterns we have taught previously for this middle part:
map (change each line into a new line)
filter (include only some of the lines)
select (choose one line)
accumulate (summarize the lines with a single value)
Here is how the file processing pattern fits into your entire program:
get the arguments
call the main function and pass it the arguments
read a file into a list of lines
change the lines in some way
write the new list of lines to a file
All caps
Here is an example that uses the file processing pattern. This program in the file called all_caps.py reads a file, changes all of the lines to uppercase, and then writes these lines to a new file.
content_copy
Copy
import sys


def readlines(filename):
    """ Read all the lines in a file and return them in a list. """
    with open(filename) as file:
        return file.readlines()


def writelines(filename, content):
    """ Write all the lines in the list called <content> into a file
    with the name `filename`. """
    with open(filename, 'w') as file:
        file.writelines(content)


def make_upper(lines):
    """ Convert a list of strings to uppercase. """
    # this function uses the map pattern

    new_lines = []
    for line in lines:
        new_lines.append(line.upper())
    return new_lines


def main(input_file, output_file):
    """ Read all of the lines from <input_file>, uppercase them,
    then write them to <output_file>. """
    # read the lines
    lines = readlines(input_file)
    # change the lines
    lines = make_upper(lines)
    # write the lines
    writelines(output_file, lines)


if __name__ == '__main__':
    # Takes two arguments -- an input filename and an output filename
    main(sys.argv[1], sys.argv[2])
Notice how we:
get the arguments in the main block, then call main() with these arguments
in main we
read the lines
change the lines
write the lines
You can run this program with python all_caps.py <input_file> <output_file>:
content_copy
Copy
python all_caps.py example.txt big.txt
Again, this will appear to not do anything. But look at the file called big.txt in PyCharm and you will see:
content_copy
Copy
ONE FISH.
TWO FISH.
RED FISH.
BLUE FISH.
When you run a program like this, be sure that the output_file you specify does not exist! Otherwise you will erase it and overwrite it with the new file.
Exciting
This is a chance for you to practice reading and writing files. Write a program that reads in a file and then does the following to the lines:
changes “a boring” to “an exciting”
changes “needs” to “has”
puts a star emoji and a space at the start of each line.
It should write the results to a new file. We have given you a file called boring.txt:
content_copy
Copy
This is a boring file.
It needs some pizzaz.
Like bullets at the front of each line.
When you run python exciting.py boring.txt exciting.txt, the program should create a new file called exciting.txt that has:
content_copy
Copy
⭐️ This is an exciting file.
⭐️ It has some pizzaz.
⭐️ Like bullets at the front of each line.
Planning
We have given you a file in exciting.py that contains this code:
content_copy
Copy
import sys


def readlines(filename):
    with open(filename) as file:
        return file.readlines()


def writelines(filename, content):
    with open(filename, 'w') as file:
        file.writelines(content)


def main(infile, outfile):
    lines = readlines(infile)
    # Write code here to change the lines
    writelines(outfile, lines)


if __name__ == '__main__':
    main(sys.argv[1], sys.argv[2])
This handles the entire file processing pattern except for the critical middle step — changing the lines. So your job is to write just this piece.
Work with a friend to write this code. Try drawing a flow chart.
Here is a flow chart that shows a solution to this problem:
Fixing the wording
We need to fix the wording by doing some string replacement. Remember we want to:
change “a boring” to “an exciting”
change “needs” to “has”
We can do this by writing a function called fix_wording():
content_copy
Copy
def fix_wording(lines):
    new_lines = []
    for line in lines:
        line = line.replace('a boring', 'an exciting')
        line = line.replace('needs', 'has')
        new_lines.append(line)
    return new_lines
This follows the map pattern. A slightly shorter way to do this is:
content_copy
Copy
def fix_wording(lines):
    new_lines = []
    for line in lines:
        fixed = line.replace('a boring', 'an exciting').replace('needs', 'has')
        new_lines.append(fixed)
    return new_lines
Notice that we can call replace() twice in a row to do both replacements.
We can call this function in main():
content_copy
Copy
def main(infile, outfile):
    # read lines from infile
    lines = readlines(infile)
    # fix the wording of each line
    lines =  fix_wording(lines)
    # write the lines
You could run this code and see that it fixes the wording but does not add the bullets.
content_copy
Copy
% python exciting.py boring.txt exciting.txt
You can look at the file exciting.txt in PyCharm to see the changes.
Adding bullets
Now we need to add bullets. This also follows the map pattern. We can write add_bullets():
content_copy
Copy
def add_bullets(lines):
    new_lines = []
    for line in lines:
        new_lines.append('⭐️ ' + line)
    return new_lines
This just prepends each line with a star emjoi and a space. We can call this function in main() as well:
content_copy
Copy
def main(infile, outfile):
    # read lines from infile
    lines = readlines(infile)
    # fix the wording of each line
    lines =  fix_wording(lines)
    # put bullets in front of each line
    lines = add_bullets(lines)
    # write the lines
    writelines(outfile, lines)
You should be able to run the program again:
content_copy
Copy
% python exciting.py boring.txt exciting.txt
Then look at the file exciting.txt in PyCharm.
Isn’t that exciting?
Photo by Zachary Nelson on Unsplash
Count BYU
Video Transcript
Write a program that reads in a file and then does the following to the lines:
replaces each line with a count of the number of times the letters “B”, “Y”, and “U” are found in the line, ignoring casing
It should write the results to a new file. We have given you a file called byu_text.txt:
content_copy
Copy
Your big book is unique.
Yuba is beyond.
Yes.
No.
BYU!
When you run python count_byu.py byu_text.txt counts.txt, the program should create a new file called counts.txt that has:
content_copy
Copy
6
5
1
0
3
Planning
We have given you a file in count_byu.py that contains this code:
content_copy
Copy
import sys


def readlines(filename):
    with open(filename) as file:
        return file.readlines()


def writelines(filename, content):
    with open(filename, 'w') as file:
        file.writelines(content)


def main(infile, outfile):
    lines = readlines(infile)
    # Write code here to change the lines
    writelines(outfile, lines)


if __name__ == '__main__':
    main(sys.argv[1], sys.argv[2])
This is the same code as the previous problem! Hopefully this helps you see how the file processing pattern works, and you can focus on the middle step.
Work with a friend to write this code. Try drawing a flow chart.
Here is a flow chart that shows a solution to this problem:
Counting BYU
Now we need to write some functions to do this. Let’s first write one to count the letters “B”, “Y”, “U” in a single line:
content_copy
Copy
def count_byu(line):
    total = 0
    for letter in line.lower():
        if letter in 'byu':
            total += 1
    return total
This uses the accumulate pattern.
Now we can write a function that changes all the lines into a count:
content_copy
Copy
def change_lines(lines):
    new_lines = []
    for line in lines:
        count = count_byu(line)
        new_lines.append(f'{count}\n')
    return new_lines
This uses the map pattern. We can call this like this:
content_copy
Copy
def main(infile, outfile):
    lines = readlines(infile)
    lines = change_lines(lines)
    writelines(outfile, lines)
We can run the program with python count_byu.py byu_text.txt counts.txt. Then look at counts.txt to see that it has what you expect.
Photo by Brie Odom-Mabey on Unsplash

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Split and join
In many tasks it is helpful to find all the words in a string. The split() function does this by converting a string to a list of words. The join() function goes in the opposite direction, converting a list of words into a string.
Split
The default use of split() is to convert a string into words that are separated by spaces:
content_copy
Copy
question = 'Do you know the muffin man?'
print(question.split())
This will print:
content_copy
Copy
['Do', 'you', 'know', 'the', 'muffin', 'man?']
By providing an argument to split(), called the delimiter, you can split a string based on any character:
content_copy
Copy
statement = "It is possible that I might, under other circumstances, have something to say, but right now I don't"
print(statement.split(','))
This will print:
content_copy
Copy
['It is possible that I might', ' under other circumstances', ' have something to say', " but right now I don't"]
Here is a small program that uses split(), which you can find in cats.py:
content_copy
Copy
def has_cat(text):
    """ return true if the string has the word cat in it """
    words = text.split()
    return 'cat' in words


if __name__ == '__main__':
    phrases = [
        'I have a dog.',
        'My cat eats bugs.',
        'Can you concatenate two strings?'
    ]
    for phrase in phrases:
        print(phrase)
        print(f'has_cat: {has_cat(phrase)}')
        print(f'"cat" in: {"cat" in phrase}')
        print()
Take a close look at has_cat(). We (1) split the text into a set of words, based on white space, and then (2) check if ‘cat’ is in those words.
Now take a look at the main block. We loop through all of the phrases and we print:
the phrase
whether ‘cat’ is one of the words (using has_cat())
whether ‘cat’ is contained in the string (without splitting into words)
If you run this program, it will print:
content_copy
Copy
My cat eats bugs.
has_cat: True
"cat" in: True

Can you concatenate two strings?
has_cat: False
"cat" in: True
Notice that has_cat() is False for the last phrase, because ‘cat’ is not one of the words we get when we split the phrase, whereas ‘cat’ is in ‘concatenate’.
Join
Join takes a list of strings and joins them into a single string, using whichever delimiter you specify. Taking our first example, let’s put those words back together into a string:
content_copy
Copy
words = ['Do', 'you', 'know', 'the', 'muffin', 'man?']
sentence = ' '.join(words)
print(sentence)
This looks a little strange, but what we are saying is that we want to use a space as a delimiter. This is the quotes with a space between them: ' '. We can then call the join() function on this string, meaning take all the strings in the words variable and turn them into one long string, with each word separated by a space.
This will print:
content_copy
Copy
Do you know the muffin man?
We could instead use '-' as a delimiter:
content_copy
Copy
words = ['Do', 'you', 'know', 'the', 'muffin', 'man?']
sentence = '-'.join(words)
print(sentence)
and this will print:
content_copy
Copy
Do-you-know-the-muffin-man?
Similarly:
content_copy
Copy
result = ' and '.join(['apples','oranges','bananas','pears'])
print(result)
will print:
content_copy
Copy
apples and oranges and bananas and pears
Here is a small program that uses both split() and join, which you can find in cats_to_cougars.py:
content_copy
Copy
def cats_to_cougars(line):
    words = line.split()
    new_words = []
    for word in words:
        if word == 'cat':
            word = 'cougar'
        new_words.append(word)
    return ' '.join(new_words)


def main():
    lines = ["BYU's mascot is cool, like a cat or something.",
             "Just like a cat can, he can catch stuff."]
    for line in lines:
        print(cats_to_cougars(line))


if __name__ == '__main__':
    main()
Take a close look at cats_to_cougars(), because it has a few core ideas:
split() the line into words
make a new list of words, so we can change ‘cat’ to ‘cougar’
join() that new list of words using space, so we can get back to a line
return that new line
To work with the words in a line, we have to change the line into words, manipulate the words, and then put the words back into a line.
Unemployment data
Video Transcript
We are going to do some work with a file that contains unemployment data. This file is in unemployment.txt and the top of the file looks like this:
content_copy
Copy
         State/Area  Year  Month  %_Unemployed
             Alabama  1976      1           6.6
              Alaska  1976      1           7.1
             Arizona  1976      1          10.2
            Arkansas  1976      1           7.3
          California  1976      1           9
The columns are separated by tabs. The file contains data for many years! The bottom of the file looks like this:
content_copy
Copy
               Texas  2022     12           3.8
                Utah  2022     12           2.4
             Vermont  2022     12           3.0
            Virginia  2022     12           3.1
          Washington  2022     12           4.5
       West-Virginia  2022     12           4.1
           Wisconsin  2022     12           3.0
             Wyoming  2022     12           3.9
We want to write a program that finds the maximum unemployment for a given state, taken over all those years. This program takes two arguments:
the input file
the state
We have given you some starter code in unemployment.py:
content_copy
Copy
import sys


def readlines(filename):
    with open(filename) as file:
        return file.readlines()


def main(input_file, state):
    lines = readlines(input_file)
    # write code here
    # use additional functions

if __name__ == '__main__':
    main(sys.argv[1], sys.argv[2])
Planning
Work with a friend to design a solution for this problem. Can you develop a flow chart?
Here are two possible flow charts:
The solution on the left focuses on lines, so it first finds the relevant lines for the selected state, then goes through those lines to find the maximum unemployment rate.
The solution on the right is similar, but focuses on rates. So it first finds the relevant rates for the selected state, returning them as a list, then it uses the built-in max() function to get the maximum of those rates.
A word on splitting and indexing lines
Remember, lists can be indexed by integers. If we have a list:
content_copy
Copy
names = ['Mariano', 'Anna', 'Salvadore', 'Lucia']
Then the first name, Mariano, is at names[0] and the last name, Lucia, is at names[3].
We also saw this with sys.argv, which is just a list of arguments given to the program. So sys.argv[0] is the name of the program, sys.argv[1] is the first argument, and so on.
If we have a line that we call split() on, then we can likewise use indexing to get the “words” or “columns” in that line. So:
content_copy
Copy
line = 'Alabama  1976      1           6.6'
info = line.split()
print(f"{line[0]} had {line[3]} percent unemployment in {line[1]} in month {line[2]})
will print:
content_copy
Copy
Alabama had 6.6 percent unemployment in 1976 in month 1
Code for solution #1
Here is code that matches the flow chart on the left:
content_copy
Copy
import sys


def readlines(filename):
    with open(filename) as file:
        return file.readlines()


def should_keep(line, state):
    tokens = line.split()
    return tokens[0] == state


def get_state_metrics(lines, state):
    state_metrics = []
    for line in lines:
        if should_keep(line, state):
            state_metrics.append(line)
    return state_metrics


def find_max_unemployment(state_metrics):
    max_ue = None
    for line in state_metrics:
        # % Unemployment is 4th token
        record = line.split()
        unemployment = float(record[3])
        if max_ue is None or unemployment > max_ue:
            max_ue = unemployment
    return max_ue


def main(input_file, state):
    lines = readlines(input_file)
    state_metrics = get_state_metrics(lines, state)
    max_unemp = find_max_unemployment(state_metrics)
    print(f'The max unemployment for {state} between 1976 and 2022 was {max_unemp}')


if __name__ == '__main__':
    main(sys.argv[1], sys.argv[2])
Read this code from the bottom up:
main() follows the flow chart: get the lines ➡️ get just the lines for a given state ➡️ get the maximum unemployment rate
get_state_metrics() uses a filter pattern to get just the lines that are for the given state
should_keep() uses the fact that the state is in the first column, which is index 0 in the list that is returned by split()
find_max_unemployment uses the select pattern to get the maximum rate; it uses the fourth column, which is index 3 in the list that is returned by split(); it also has to use float() to convert the number to a float
Code for solution #2
Here is code that matches the flow chart on the right:
content_copy
Copy
import sys


def readlines(filename):
    with open(filename) as file:
        return file.readlines()


def get_state_rates(lines, state):
    rates = []
    for line in lines:
        tokens = line.split()
        if tokens[0] == state:
            rates.append(float(tokens[3]))

    return rates


def main(input_file, state):
    lines = readlines(input_file)
    ue_rates = get_state_rates(lines, state)
    max_unemp = max(ue_rates)
    print(f'The max unemployment for {state} between 1976 and 2022 was {max_unemp}')


if __name__ == '__main__':
    main(sys.argv[1], sys.argv[2])
Read this code from the bottom up:
main() follows the flow chart: get the lines ➡️ get the rates for the state ➡️ find the maximum unemployment rate
get_state_rates() uses the filter pattern, just like get_state_metrics() above, but does it all in one function and returns a list of rates (converted to a float) instead of a list of lines
we can use the built-in max() function to get the maximum of a list of floats
Is one of these approaches better?
Both of these are good solutions! The second solution takes advantage of the built-in max() function so it uses a little less code. But the first solution returns more information, so the maximum function could, for example, also return the year and month for that maximum rate.
Ultimately, this is a judgement you make as a programmer to decide what you need, both to solve this problem and to provide flexibility for the future.
Photo by Damian Siodłak on Unsplash

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Random
Sometimes we want to be able to introduce randomness into a program. For example, if you are writing a game, you may need to have a treasure or a monster appear at random times in the game. If you are writing a password manager, you may want to create random passwords.
Python has a random module that you can import with import random.
Random choice
Look at the code in choice.py. To choose a random item from a list, use random.choice():
content_copy
Copy
import random


if __name__ == '__main__':
    fruits = ['pear','mango','banana','strawberry','kumquat']
    selection = random.choice(fruits)
    print(selection)
This will choose a random fruit from the list.
Random integer
Look at the code in integer.py. To choose a random integer between (and including) a low value and a high value, use random.randint():
content_copy
Copy
import random


if __name__ == '__main__':
    number = random.randint(1, 10)
    print(number)
Random float
Look at the code in float.py. To choose a random float between (and including) 0 and 1, use random.random():
content_copy
Copy
import random


if __name__ == '__main__':
    number = random.random()
    print(number)
If you want to scale this to be between 0 and some larger number, you can scale it with multiplication. For example, to choose a float between 0 and 100:
content_copy
Copy
import random


if __name__ == '__main__':
    number = random.random() * 100
This is particularly useful for doing something with a random probability. For example, if you want your code to do something 20% of the time (or 1 in 5 chances), then:
content_copy
Copy
import random


if __name__ == '__main__':
    number = random.random()
    if number <= 0.2:
        print("This should print one in 5 times.")
    else:
        print("This should print 4 in 5 times.")
You can find a more complete example in fruits.py:
content_copy
Copy
import random


def apples(size):
    """
    Collect a list of 'apples', but 10% of the time, an item is 'bananas!' instead.
    """
    result = []
    while len(result) < size:
        if random.random() < 0.1:
            result.append('bananas!')
        else:
            result.append('apples')
    return result


if __name__ == '__main__':
    fruits = apples(40)
    print(fruits)
This will set fruits to be a list of mostly apples but 10% of the time bananas! (more or less, depending on how the random numbers come up).
Random sample
Look at the code in washington.py. To sample letters from a string, use random.sample():
content_copy
Copy
import random


if __name__ == '__main__':
    name = 'Washington'
    letter = random.sample(name, 2)
    print(letter)
This will return a list that has two random letters from Washington — removing each letter as it is chosen. This means at most you can choose 10 letters from Washington, with no repeats. If you chose to sample all 10 letters, you would end up with Washington scrambled.
The code in shuffle.py has a function that does exactly this:
content_copy
Copy
import random

def shuffle(string):
    """
    Use random.sample to get the letters in the string in a random order.
    Then join the letters together with the empty string.
    """
    shuffled_letters = random.sample(string, len(string))
    return ''.join(shuffled_letters)


if __name__ == '__main__':
    shuffled = shuffle('Washington')
    print(shuffled)
Example
Video Transcript
Write a function that will randomly inject “umm” into a sentence at a frequency of about 20%:
content_copy
Copy
def ummify(text):
    """
    Randomly inject 'umm' into the given text at a frequence of 20%
    """
Here is how you might write out an algorithm to solve this problem in English:
create a new, empty list — result
loop through all of the words in the input string
generate a random float
if the float is less than or equal to 0.2, then append umm to the result list
append the current word to the result list
convert the list of words back into a string
return the new string
The file in ummify.py has a solution that follows this algorithm:
content_copy
Copy
import random

def ummify(text):
    """
    Randomly inject 'umm' into the given text at a frequence of 20%
    """
    words = text.split(' ')
    result = []
    for word in words:
        if random.random() < 0.2:
            result.append('umm')
        result.append(word)
    return ' '.join(result)


if __name__ == '__main__':
    speech = ["Four score and seven years ago our fathers brought forth, on this continent, a new nation, conceived in Liberty, and dedicated to the proposition that all men are created equal.",
    "Now we are engaged in a great civil war, testing whether that nation, or any nation so conceived and so dedicated, can long endure. We are met on a great battle-field of that war.",
    "We have come to dedicate a portion of that field, as a final resting place for those who here gave their lives that that nation might live. It is altogether fitting and proper that we should do this."]

    for line in speech:
        print(ummify(line))

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Coiteration with zip
There are times when we want to iterate over two lists at the same time. For example, we may have a list of fruits:
content_copy
Copy
fruits = ['apple', 'pear', 'peach']
and a list of prices:
content_copy
Copy
prices = [0.25, 0.40, 10.0]
and we want to print a list that shows each fruit and its price:
content_copy
Copy
apple : $0.25
pear : $0.40
peach : $10.0
Yes, peaches are worth that much more than any other fruit. They are amazing.
zip
To iterate over two lists at the same time, we can use zip() to turn combine the two lists. This code is in fruit_prices.py:
content_copy
Copy
if __name__ == '__main__':
    fruits = ['apple', 'pear', 'peach']
    prices = [0.25, 0.40, 10.0]
    for fruit, price in zip(fruits, prices):
        print(f'{fruit} : ${price}')
This will produce the list of fruits and their prices as shown above.
How is this working? The zip() function creates a collection of tuples:
content_copy
Copy
(apple, 0.25)
(pear, 0.40)
(peach, 10.0)
You can then iterate over this collection using for ... in, just like with a list, a file, or a string.
You can zip as many lists as you want
You don’t have to stop at zipping just two lists. Here is an example that zips three lists, which you can find in students.py:
content_copy
Copy
if __name__ == '__main__':
    names = ['John', 'Juan', 'João', 'Giovanni']
    ages = [23, 18, 24, 22]
    majors = ['Chemistry', 'Animation', 'Sociology', 'Secondary Education']

    for name, age, major in zip(names, ages, majors):
        print(f'{name} is {age} years old and studies {major}')
zip stops zipping as soon as one of the lists runs out
Thsi code is in unequal_lists.py. If you zip these lists:
content_copy
Copy
if __name__ == '__main__':
    fruits = ['apple', 'pear', 'blueberry', 'grape', 'strawberry']
    plant_types = ['tree', 'tree', 'bush', 'vine']

    for fruit, plant_type in zip(fruits, plant_types):
        print(f'The {fruit} grows on a {plant_type}.')
Then you get this output:
content_copy
Copy
The apple grows on a tree.
The pear grows on a tree.
The blueberry grows on a bush.
The grape grows on a vine.
Notice that we never get any output about strawberry because there is no accompanying plant type for this fruit.
zip works with anything that is iterable
Since zip() works with anything that is iterable, you can use it to zip strings as well. This code is in compare_strings.py:
content_copy
Copy
if __name__ == '__main__':
    word1 = 'planter'
    word2 = 'started'

    for letter1, letter2 in zip(word1, word2):
        if letter1 == letter2:
            print(f'{letter1} == {letter2} ✅')
        else:
            print(f'{letter1} != {letter2}')
This will print:
content_copy
Copy
p != s
l != t
a == a ✅
n != r
t == t ✅
e == e ✅
r != d
enumerate
Sometimes you want to iterate through a list and get the index for each item as you go. You can get the indexes for a list with enumerate(). See this code in names.py:
content_copy
Copy
if __name__ == '__main__':
    for index, name in enumerate(['Paula', 'Patty', 'Peter', 'Penelope']):
        print(f'{index}: {name}')
This will print:
content_copy
Copy
0: Paula
1: Patty
2: Peter
3: Penelope
It turns out that enumerate() returns a collection of tuples, just like zip().

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Dictionaries
A dictionary is a map of keys to values. For example, this dictionary maps a key that is a meal to a value that is a string describing that meal:
content_copy
Copy
meals = {
    'breakfast': 'yogurt, granola, and fruit',
    'lunch': 'Cupbop',
    'dinner': 'lasagna and salad'
}
The purpose of the dictionary is to be able to store and look up key/value pairs. The dictionary above lets us store what we ate today and then to perform calculations on it.
This is similar to what meal tracking or fitness tracking apps do! The screenshot below shows how a meal tracking app stores a list of items along with their nutrition information for each meal. We will eventually show you how to store more complex information in a dictionary.
Getting key/value pairs from a dictionary
You can retrieve the value for a key by using square brackets:
content_copy
Copy
food = meals['dinner']
If you try to retrieve a key that is not present, you will get an error. For example, asking for meals['brunch'] with the above example cause an error:
content_copy
Copy
KeyError: 'brunch'
You can also use the get() function:
content_copy
Copy
food = meals.get('brunch', 'buttered toast and apple juice')
This tells Python to look for brunch in the meals dictionary and return the value. But if that key doesn’t exist, then return buttered toast and apple juice instead.
Here are these ideas put into a program, which is in meals.py:
content_copy
Copy
if __name__ == '__main__':
    meals = {
        'breakfast': 'yogurt, granola, and fruit',
        'lunch': 'Cupbop',
        'dinner': 'lasagna and salad'
    }
    food = meals['dinner']
    print(f"I had {food} for dinner.")
    food = meals.get('brunch', 'buttered toast and apple juice')
    print(f"I had {food} for brunch.")
If you run this program, you get:
content_copy
Copy
I had lasagna and salad for dinner.
I had buttered toast and apple juice for brunch.
Iterate over the key/value pairs in a dictionary
You can iterate over all of the keys and values using for ... in and items():
content_copy
Copy
for meal, description in meals.items():
    print(f'For {meal} we are serving {description}. 😋')
The file all_meals.py has this short program:
content_copy
Copy
if __name__ == '__main__':
    meals = {
        'breakfast': 'yogurt, granola, and fruit',
        'lunch': 'Cupbop',
        'dinner': 'lasagna and salad'
    }
    for meal, description in meals.items():
        print(f'For {meal} we are serving {description}. 😋')
If you run it, this will print:
content_copy
Copy
For breakfast we are serving yogurt, granola, and fruit. 😋
For lunch we are serving Cupbop. 😋
For dinner we are serving lasagna and sald. 😋
To understand what items() is doing, it uses your dictionary, gets all of the key/value pairs, and returns a sequence of key/value tuples. You can turn this into a list:
content_copy
Copy
print(list(meals.items()))
This will print:
content_copy
Copy
[('breakfast', 'yogurt, granola, and fruit'), ('lunch', 'Cupbop'), ('dinner', 'lasagna and sald')]
Checking whether a key is in a dictionary
You can check whether a key is in a dictionary using in. For example:
content_copy
Copy
if 'dinner' in meals:
    print("Yay, we are eating dinner.")
if 'brunch' in meals:
    print("Yay, we are eating brunch.")
will print
content_copy
Copy
print("Yay, we are eating dinner.")
Here is another example, which is in home_towns.py:
content_copy
Copy
if __name__ == '__main__':
    hometowns = {
        'Dallin Oaks': 'Provo, UT',
        'Jeffery Holland': 'St George, UT',
        'Merril Bateman': 'Lehi, UT',
        'Cecil Samuelson': 'Salt Lake City, UT',
        'Kevin Worthen': 'Dragerton, UT',
        'Shane Reese': 'Logan, UT'
    }
    for person in ['Kevin Worthen', 'Henry Eyring', 'Shane Reese', 'Ernest Wilkinson', 'Karl Maeser']:
        if person in hometowns:
            print(f'{person} was born in {hometowns[person]}.')
        else:
            print(f"I don't know where {person} was born.")
Here the dictionary maps Presidents of BYU to the place they were born. If you run this code you will see:
content_copy
Copy
Kevin Worthen was born in Dragerton, UT.
I don't know where Henry Eyring was born.
Shane Reese was born in Logan, UT.
I don't know where Ernest Wilkinson was born.
I don't know where Karl Maeser was born.
Replacing words with emojis
Video Transcript
The world can always use more emojis! You are given a dictionary mapping words to emojis. For example:
content_copy
Copy
emojis = {'dog': '🐶', 'cat': '🐱', 'tree': '🌳', 'bird': '🐦'}
Your goal is to replace all instances of a word in a string with it’s corresponding emoji. You need to ignore the case of the word.
Using the dictionary above, the string 'My dog has fleas' becomes 'My 🐶 has fleas'.
Write a function to do this, add_emojis(text, emojis). We have given you starter code in emojis.py:
content_copy
Copy
import sys


def add_emojis(text, emojis):
    """Replace words in `emojis` with their corresponding symbols."""
    # Write code here
    pass


if __name__ == '__main__':
    emojis = {
        'dog': '🐶',
        'puppy': '🐶',
        'dogs': '🐶🐶',
        'cat': '🐱',
        'tree': '🌳',
        'bird': '🐦'
    }
    print(add_emojis(sys.argv[1], emojis))
Here is a solution:
content_copy
Copy
def add_emojis(text, emojis):
    new_words = []
    # split the text into words
    for word in text.split():
        # check if this word is in the dictionary as a key
        if word in emojis:
            # get the emoji from the dictionary that corresponds to this word
            word = emojis[word]
        # append either the original word or the emoji to the list of words
        new_words.append(word)
    # combine the new words into a string, with spaces between them, and return that string
    return " ".join(new_words)
We use split() to split the string into a set of words
We use if word in emojis to check if the dictionary has a key for a given word
We use emojis[word] to get the emoji for a given word
We use join() to turn a list of words back into a string, with each word separated by spaces
If we run the code
content_copy
Copy
python emojis.py "The dog chased the cat which chased the bird that sat in the tree in my yard."
We get:
content_copy
Copy
The 🐶 chased the 🐱 which chased the 🐦 that sat in the 🌳 in my yard.
Team assignments
Video Transcript
Let’s imagine you want to write a small program to help community members register for sports teams at the local recreation center. You have a dictionary that maps age groups to team names:
content_copy
Copy
teams_by_age = {
    0: 'Team Toddlers',
    3: 'Tiny Troupers',
    6: 'Starting Stars',
    9: 'Mighty Middles',
    12: 'Too Cool',
    15: 'Boundless'
}
You also have a list of participants and their ages:
content_copy
Copy
participants = [
    ('Joe', 14),
    ('Jane', 6),
    ('Johnny', 4),
    ('Jennifer', 20),
    ('Jack', 16),
    ('Janice', 2)
]
You want to assign each participant to a team based on their age:
content_copy
Copy
def assign_teams(participants, teams_by_age):
    """Returns a list of tuples of name and team."""
This function should return a list of tuples that list person name and team such as (‘Joe’,‘Too Cool’).
To figure out which team a person is assigned to, find the nearest multiple of 3 that is less than or equal to the participant age. You can do this with:
content_copy
Copy
nearest_multiple = (age // 3) * 3
If the participant does not have an age-group assignment, their team is “Adult League”.
There is starter code in assign_teams.py:
content_copy
Copy
def assign_teams(participants, teams_by_age):
    """Return a list of (person, team) tuples"""
    # Write code here
    pass


def print_teams(teams):
    for player, team in teams:
        print(f'{player} is on team {team}')


def main(participants, age_groups):
    teams = assign_teams(participants, age_groups)
    print_teams(teams)


if __name__ == '__main__':
    age_groups = {
        0: 'Team Toddlers',
        3: 'Tiny Troupers',
        6: 'Starting Stars',
        9: 'Mighty Middles',
        12: 'Too Cool',
        15: 'Boundless'
    }

    participants = [
        ('Joe', 14),
        ('Jane', 6),
        ('Johnny', 4),
        ('Jennifer', 20),
        ('Jack', 16),
        ('Janice', 2)
    ]

    main(participants, age_groups)
Here is code to do this:
content_copy
Copy
def assign_teams(participants, teams_by_age):
    # make a list of tuples (person, team)
    result = []
    # loop through all the tuples of (name, age)
    for name, age in participants:
        # compute the group for this age (nearest multiple of 3)
        age_group = (age // 3) * 3
        # loop up the team name for this age group, and if none, then the team is 'Adult League'
        team_name = teams_by_age.get(age_group, "Adult League")
        # append a tuple of (name, group) to the list of tuples
        result.append((name, team_name))
    return result
go through all the participants, which are tuples of (name, age)
find the nearest age group for the participant
get the team for that age group
create a new tuple of (name, team) and append to a list of tuples
return all the tuples
If we run the code, then we get:
content_copy
Copy
[('Joe', 'Too Cool'), ('Jane', 'Starting Stars'), ('Johnny', 'Tiny Troupers'), ('Jennifer', 'Adult League'), ('Jack', 'Boundless'), ('Janice', 'Team Toddlers')]
Cipher
Video Transcript
You are given a codex, which is a dictionary mapping letters to their “encoded” letter. Your job is to use this codex to encode a message.
For example, if the codex maps d -> x, o -> p, and g -> e, then dog is encoded as xpe. This is the most simple way of encoding messages and is really easy for a computer to break, but it is usually the starting point to discuss the concept of encryption.
The codex only contains lowercase letters, but you should encode uppercase letters also. Be sure to preserve casing.
Here is an example of a codex:
content_copy
Copy
codex = {
 'a': 'd',
 'b': 'e',
 'c': 'z',
 'd': 'h',
 'e': 'g',
 'f': 's',
 'g': 'n',
 'h': 'r',
 'i': 'a',
 'j': 'b',
 'k': 'k',
 'l': 'j',
 'm': 'c',
 'n': 'u',
 'o': 'y',
 'p': 't',
 'q': 'q',
 'r': 'x',
 's': 'w',
 't': 'v',
 'u': 'p',
 'v': 'f',
 'w': 'i',
 'x': 'l',
 'y': 'm',
 'z': 'o'
}
Here is the function to write:
content_copy
Copy
def encode(codex, message):
    """Return the encoded message using the codex to map letters."""
You have some starter code in encode.py:
content_copy
Copy
import sys


def encode(codex, message):
    """Return the encoded message using the codex to map letters."""
    # Write code here
    pass


def main(message, codex):
    encoded = encode(codex, message)
    print(encoded)


if __name__ == '__main__':
    simple_codex = {
        'a': 'd',
        'b': 'e',
        'c': 'z',
        'd': 'h',
        'e': 'g',
        'f': 's',
        'g': 'n',
        'h': 'r',
        'i': 'a',
        'j': 'b',
        'k': 'k',
        'l': 'j',
        'm': 'c',
        'n': 'u',
        'o': 'y',
        'p': 't',
        'q': 'q',
        'r': 'x',
        's': 'w',
        't': 'v',
        'u': 'p',
        'v': 'f',
        'w': 'i',
        'x': 'l',
        'y': 'm',
        'z': 'o'
    }
    main(sys.argv[1], simple_codex)
This works the same way as the emoji problem above! You just have to be sure to worry about case.
Here is one way to solve this problem:
content_copy
Copy
def encode(codex, message):
    # accumulate a new string
    result = ""
    # loop through all of the characters in the message
    for char in message:
        # start out with the new character being the same as the old one
        new_char = char
        # check if the lowercase version of the character is in the codex
        if char.lower() in codex:
            # get the encoded character from the codex
            new_char = codex[char.lower()]
        if char.isupper():
            # if the character was originally uppercase, be sure the new character is also uppercase
            new_char = new_char.upper()

        # note, any punctuation is left alone because it won't be in the codex!

        # append the encoded character in the string
        result += new_char
    return result
If we run the completed code:
content_copy
Copy
python encode.py "I like fish."
we get:
content_copy
Copy
A jakg sawr.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
Building Dictionaries
Remeber: a dictionary is a map of keys to values:
So far we have shown you how to use dictionaries:
content_copy
Copy
# a dictionary
meals = {
    'breakfast': 'yogurt, granola, and fruit',
    'lunch': 'Cupbop',
    'dinner': 'lasagna and salad'
}

# get the value for a key
food = meals['dinner']
In this guide we will show you how to build a dictionary.
Building a dictionary
There are two steps to building a dictionary, (1) creating an empty dictionary, and (2) adding key/value pairs to the dictionary.
Creating an empty dictionary
You can create an empty dictionary using a pair of curly braces:
content_copy
Copy
meals = {}
Add key/value pairs to a dictionary
You can add key/value pairs to the dictionary one at a time using square brackets:
content_copy
Copy
meals['lunch'] = 'crackers and cheese'
Dictionaries cannot have duplicate keys
This will over-write the value of the ‘lunch’ key:
content_copy
Copy
meals['lunch'] = 'peanut butter and jelly sandwich'
Putting these together
If you want to create an entire dictionary from scratch:
content_copy
Copy
meals = {}
meals['breakfast'] = 'ogurt, granola, and fruit'
meals['lunch'] = 'Cupbop'
meals['dinner'] = 'lasagna and salad'
You can do this in one step with:
content_copy
Copy
meals = {
    'breakfast': 'yogurt, granola, and fruit',
    'lunch': 'Cupbop',
    'dinner': 'lasagna and salad',
}
But there will be time when you will need to build a dictionary one item at a time. We will see examples of this below.
Room assignments
You are helping to organize the next Women in Computer Science (WICS) Skillathon, where students can come hear various speakers in CS provide brief workshops on various tech skills. You have a list of speakers and a list of available rooms. You want to pair up speakers with a room. Write a function that takes a list of speakers and a list of rooms (both having the same length) and returns a dictionary of room assignments.
Let’s say that you have these two lists:
content_copy
Copy
speakers = ['Page', 'Jones', 'Bean', 'Zappala', 'Clement', 'Fulda']
rooms = ['2233', '2228', '2230', '2242', '2220', '2238']
You want to write a function make_room_assignments() that creates a dictionary mapping each speaker to a room:
content_copy
Copy
def make_room_assignments(speakers, rooms):
    """
    Return a dictionary mapping each speaker to a room
    """
To solve this problem, you need to iterate over two lists at a time, so that you can map “Page” to “2233, “Jones to “2228”, and so forth. Remember, zip helps you iterate over two lists:
Zip creates a list of tuples. It makes these tuples by taking one element from each list at a time.
Here is how we can use this in a solution, which you can find in room_assignments.py:
content_copy
Copy
def make_room_assignments(speakers, rooms):
    """
    Return a dictionary mapping each speaker to a room
    """
    # create an empty dictionary
    assignments = {}
    # zip the speakers and rooms, then loop through all of the tuples
    for speaker, room in zip(speakers, rooms):
        # map the speaker to the room in the dictionary
        assignments[speaker] = room
    # return the dictionary
    return assignments


if __name__ == '__main__':
    speakers = ['Page', 'Jones', 'Bean', 'Zappala', 'Clement', 'Fulda']
    rooms = ['2233', '2228', '2230', '2242', '2220', '2238']
    room_assignments = make_room_assignments(speakers, rooms)
    print(room_assignments)
Look through the comments in the code to see what each line is doing. Notice how we:
create an empty dictionary
zip the speaker and room lists together, then loop through the tuples
add each speaker to room mapping to the dictionary
return the dictionary at the end
If you run this program, you should see:
content_copy
Copy
{'Page': '2233', 'Jones': '2228', 'Bean': '2230', 'Zappala': '2242', 'Clement': '2220', 'Fulda': '2238'}
Itineraries
This problem continues on from the previous one. Now that you have a list of speakers and room assignments, you need to assign each speaker to a time. You are given a list of speakers and their desired speaking times. You need to write a function that takes:
desired_speaker_times: a list of (speaker, time) tuples
room_assignments: a dictionary that maps speakers to rooms
and returns a list of speaker/room/time tuples.
content_copy
Copy
def make_itinerary(desired_speaker_times, room_assignments):
    """
    desired_speaker_times: list of (speaker, time) tuples
    room_assignments: a dictionary that maps speakers to rooms
    Return a list of (speaker, room, time) tuples
    """
This picture illustrates what we are trying to do:
Notice that this function takes a list of (speaker, time) tuples and returns (speaker, room, time) tuples. So you can solve this problem by iterating through the desired speaker times and creating a new list of tuples as you go:
content_copy
Copy
def make_itinerary(desired_speaker_times, room_assignments):
    """
    Input: list of (speaker, time) tuples
    Return a list of (speaker, room, time) tuples
    """
    # create an empty list
    itinerary = []
    # iterate through the list of (speaker, time) tuples
    for speaker, time in desired_speaker_times:
        # append a new tuple to the list, using the dictionary to look up the room for the speaker
        itinerary.append((speaker, room_assignments[speaker], time))
    return itinerary


if __name__ == '__main__':
    desired_lineup = [('Fulda', '9am'), ('Page', '10am'), ('Jones', '11am'), ('Zappala', '12pm')]
    room_assignments = {'Page': '2233', 'Jones': '2228', 'Bean': '2230', 'Zappala': '2242', 'Clement': '2220', 'Fulda': '2238'}
    itinerary = make_itinerary(desired_lineup, room_assignments)
    print(itinerary)
The key piece of this is where we create the new list of tuples:
content_copy
Copy
itinerary.append((speaker, room_assignments[speaker], time))
Notice that we create a new tuple of (speaker, room, time), and we get the middle piece of this — the room — by looking up the room in the room_assignments dictionary.
If you run the program, which is in itinerary.py, you should see:
content_copy
Copy
[('Fulda', '2238', '9am'), ('Page', '2233', '10am'), ('Jones', '2228', '11am'), ('Zappala', '2242', '12pm')]
Inverting a dictionary
The speaker-to-room dictionary was helpful for making individual itineraries. Now the building scheduling crew wants a dictionary that maps rooms to speakers. Because the room-assignments dictionary is 1-to-1 (the keys and the values are all unique), we can do this.
You should write a function called invert_assignments that takes the room assignments dictionary:
room_assignments: a dictionary that maps speakers to rooms
and returns a new dictionary that maps rooms to speakers.
This picture illustrates what we are trying to do:
To do this, you need to iterate through all of the (speaker, room) tuples in the room_assignments dictionary, which you can do using items():
content_copy
Copy
def invert_assignments(speaker_rooms):
    """
    Return a new dictionary mapping room to speaker
    """
    # create an empty dictionary
    room_speakers = {}
    # loop through all of the (speaker, room) tuples in the dictionary
    for speaker, room in speaker_rooms.items():
        # create a new entry in the new dictionary, mapping room to speaker
        room_speakers[room] = speaker
    # return the new dictionary
    return room_speakers


if __name__ == '__main__':
    room_assignments = {'Page': '2233', 'Jones': '2228', 'Bean': '2230', 'Zappala': '2242', 'Clement': '2220', 'Fulda': '2238'}
    assigned_rooms = invert_assignments(room_assignments)
    print(assigned_rooms)
Notice that we are making room to speaker, when the original dictionary mapped speaker to room:
content_copy
Copy
room_speakers[room] = speaker
When you run this code, it should show:
content_copy
Copy
{'2233': 'Page', '2228': 'Jones', '2230': 'Bean', '2242': 'Zappala', '2220': 'Clement', '2238': 'Fulda'}
Everything all at once
We can put all of these pieces into one program that:
makes room assignments
makes an itinerary
makes the assigned rooms
You can see this program in skillathon.py:
content_copy
Copy
def make_room_assignments(speakers, rooms):
    """
    Return a dictionary mapping each speaker to a room
    """
    assignments = {}
    for speaker, room in zip(speakers, rooms):
        assignments[speaker] = room
    return assignments

def make_itinerary(desired_speaker_times, room_assignments):
    """
    Input: list of (speaker, time) tuples
    Return a list of (speaker, room, time) tuples
    """
    # create an empty list
    itinerary = []
    # iterate through the list of (speaker, time) tuples
    for speaker, time in desired_speaker_times:
        # append a new tuple to the list, using the dictionary to look up the room for the speaker
        itinerary.append((speaker, room_assignments[speaker], time))
    return itinerary


def invert_assignments(speaker_rooms):
    """
    Return a new dictionary mapping room to speaker
    """
    # create an empty dictionary
    room_speakers = {}
    # loop through all of the (speaker, room) tuples in the dictionary
    for speaker, room in speaker_rooms.items():
        # create a new entry in the new dictionary, mapping room to speaker
        room_speakers[room] = speaker
    # return the new dictionary
    return room_speakers


def print_room_assignments(assignments):
    print("Room Assignments:")
    for speaker, room in assignments.items():
        print(f"* {speaker}: {room}")


def print_itinerary(itinerary):
    print("The itinerary:")
    for speaker, room, time in itinerary:
        print(f"* {speaker}: {room}, {time}")


def print_assigned_rooms(assigned_rooms):
    print("Assigned rooms:")
    for room, speaker in assigned_rooms.items():
        print(f"* {room}: {speaker}")

if __name__ == '__main__':
    # Make the room assignments and print them out
    speakers = ['Page', 'Jones', 'Bean', 'Zappala', 'Clement', 'Fulda']
    rooms = ['2233', '2228', '2230', '2242', '2220', '2238']
    room_assignments = make_room_assignments(speakers, rooms)
    print_room_assignments(room_assignments)
    print()

    # Make an itinerary and print it out
    desired_lineup = [('Fulda', '9am'), ('Page', '10am'), ('Jones', '11am'), ('Zappala', '12pm')]
    the_itinerary = make_itinerary(desired_lineup, room_assignments)
    print_itinerary(the_itinerary)
    print()

    # Make a list of assigned rooms and print it out
    rooms = invert_assignments(room_assignments)
    print_assigned_rooms(rooms)
We have also added some nicer printing by iterating through the dictionaries and lists and printing them out with bullets. If you run this program, you get:
content_copy
Copy
Room Assignments:
* Page: 2233
* Jones: 2228
* Bean: 2230
* Zappala: 2242
* Clement: 2220
* Fulda: 2238

The itinerary:
* Fulda: 2238, 9am
* Page: 2233, 10am
* Jones: 2228, 11am
* Zappala: 2242, 12pm

Assigned rooms:
* 2233: Page
* 2228: Jones
* 2230: Bean
* 2242: Zappala
* 2220: Clement
* 2238: Fulda

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Counting
Dictionaries make it easy to count items. For example let’s say we wanted to count the number of vowels in a string. Here is what this program should do:
content_copy
Copy
% python vowel_counts.py 'Hello. How are you?'
{'a': 1', 'e': 2, 'i': 0, 'o': 3, 'u': 1}
Notice that for the string Hello. How are you? we have created a dictionary that maps each vowel to the number of times it appears:
a: 1
e: 2
i: 0
o: 3
u: 1
To see how we can do this, take a look at this function:
content_copy
Copy
def count(letters, text):
    # create an empty dictionary
    counts = {}

    # loop through all of the letters we are counting
    # and initialize their counts to zero
    for letter in letters:
        counts[letter] = 0

    # loop through all of the letters in the text
    # be sure to convert to lowercase
    for c in text.lower():
        # if this letter is one we are counting, add 1 to its count
        if c in counts:
            counts[c] += 1

    # return the dictionary
    return counts
This function takes a set of letters to count and a string. For example, we could call this with:
content_copy
Copy
vowel_counts = count('aeiou', text)
In this function we:
create an empty dictionary
loop through all of the letters we are counting and initialize their counts to zero
loop through all of the letters in the text
if the letter we are looking at is one of the ones we are counting, then add one to its count
Here is a program that uses this function, which you can find in vowel_counts.py:
content_copy
Copy
import sys


def count(letters, text):
    # create an empty dictionary
    counts = {}

    # loop through all of the letters we are counting
    # and initialize their counts to zero
    for letter in letters:
        counts[letter] = 0

    # loop through all of the letters in the text
    # be sure to convert to lowercase
    for c in text.lower():
        # if this letter is one we are counting, add 1 to its count
        if c in counts:
            counts[c] += 1

    # return the dictionary
    return counts


def main(text):
    # count how many times each vowel occurs in the text
    vowel_counts = count('aeiou', text)
    # print out the dictionary
    print(vowel_counts)


if __name__ == '__main__':
    main(sys.argv[1])
We can test this program by giving it another string:
content_copy
Copy
% python vowel_counts.py "I am going to double major in Computer Science and Journalism"
{'a': 4, 'e': 4, 'i': 5, 'o': 6, 'u': 3}
Looks like it works!
States
To practice this, we are going to write a program that has a group of people enter their home state or country. After all of the places are entered, the program then prints out how many people are from each place. For example:
content_copy
Copy
% python place_count.py
State or Country: Delaware
State or Country: Montana
State or Country: Pakistan
State or Country: Iran
State or Country: Montana
State or Country: Pakistan
State or Country: India
State or Country: California
State or Country:
{'Delaware': 1, 'Montana': 2, 'Pakistan': 2, 'Iran': 1, 'India': 1, 'California': 1}
Here is a function to do compute the dictionary:
content_copy
Copy
def get_places():
    # create an empty dictionary
    places = {}
    while True:
        # get a place
        place = input('State or Country: ')
        # break if we are done
        if not place:
            break
        # if this place is not in the dictionary yet
        # then initialize this place to zero
        if place not in places:
            places[place] = 0
        # increment this place by one
        # this doesn't cause an error because we were sure
        # to initialize it to zero above
        places[place] += 1

    # return the dictionary
    return places
Notice that this follows a similar pattern as when we counted values. However, the difference here is that we don’t know the keys for the dictionary in advance. If we are counting vowels, the keys are always “aeiou”. But for this problem, the keys are whatever states and countries people enter.
We can handle this problem by using this code:
content_copy
Copy
if place not in places:
    places[place] = 0
Whenever we find a place that is not in the dictionary, then we initailize its value to zero.
Here is a complete program using this function, which you can find in places_count.py:
content_copy
Copy
def get_places():
    # create an empty dictionary
    places = {}
    while True:
        # get a place
        place = input('State or Country: ')
        # break if we are done
        if not place:
            break
        # if this place is not in the dictionary yet
        # then initialize this place to zero
        if place not in places:
            places[place] = 0
        # increment this place by one
        # this doesn't cause an error because we were sure
        # to initialize it to zero above
        places[place] += 1

    # return the dictionary
    return places

def main():
    places = get_places()
    print(places)


if __name__ == '__main__':
    main()
Removing punctuation
Counting words
For this program, we are going to count all times each word occurs in a file. But we need to ignore both case and punctuation. This is important because if the file contains:
content_copy
Copy
Twinkle, twinkle, little star,
how I wonder, what you are!
Up above the world so high,
like a diamond in the sky.
Twinkle, twinkle, little star,
how I wonder what you are!
Then we need “Twinkle” to be counted the same as “twinkle”, and we need to remove commas and exclamation points.
Reading the file as a long string
When we want to count words in a file, we could read the file as a list of lines, like we usually do, and then split each line into words. However, a simpler thing to do is to read the file as one long string. Then you can split this long string into words all at once using split().
Here is how to read a file as one long string:
content_copy
Copy
def readfile(filename):
    with open(filename) as file:
        return file.read()
This function uses file.read() instead of file.readlines():
file.read() — read an entire file and return it as one long string:
content_copy
Copy
'Line one\n, Line two\n, Line three\n'
file.readlines() — read an entire file and return it as a list of strings, one per line in the file:
content_copy
Copy
['Line one\n', 'Line two\n', 'Line three\n']
Removing punctuation
To remove punctuation, we can use strip(). Normally, strip() removes all leading and trailing white space. But if we give it a string as an argument, then we can remove all trailing and leading characters that are in the string.
For example, this will remove just exclamation points and question marks:
content_copy
Copy
word = word.strip('!?')
To remove all punctuation, you could imagine trying to list all the punctuation characters in something like:
content_copy
Copy
word = word.strip('.,?!#@$%^&*()')
However, with this strategy it can be easy to overlook something. Instead, python can provide us with a full list of all the punctuation characters:
content_copy
Copy
from string import punctuation
word = word.strip(punctuation)
A function to count words
Here is a function that will count words in a long string (containing multiple lines):
content_copy
Copy
from string import punctuation

def count_words(content):
    """Count the number of each word in content.
    Ignore casing and punctuation."""
    # create an empty dictionary
    counts = {}
    # loop through all of the words, first converting to lowercase
    # and then splitting them using white space
    for word in content.lower().split():
        # strip any leading or trailing punctuation from the word
        word = word.strip(punctuation)
        # if the word is not in the dictionary,
        # initialize an entry to zero
        if word not in counts:
            counts[word] = 0
        # increment the count by one for this word
        counts[word] += 1
    # return the dictionary
    return counts
The two important things to notice here are:
we convert the content to lowercase using lower() before we split it into words using split()
we remove all of the punctuation using strip()
Otherwise, this follows the same pattern as counting places.
The file count_words.py contains a complete program:
content_copy
Copy
import sys
from string import punctuation


def readfile(filename):
    with open(filename) as file:
        return file.read()


def count_words(content):
    """Count the number of each word in content.
    Ignore casing and punctuation."""
    # create an empty dictionary
    counts = {}
    # loop through all of the words, first converting to lowercase
    # and then splitting them using white space
    for word in content.lower().split():
        # strip any leading or trailing punctuation from the word
        word = word.strip(punctuation)
        # if the word is not in the dictionary,
        # initialize an entry to zero
        if word not in counts:
            counts[word] = 0
        # increment the count by one for this word
        counts[word] += 1
    # return the dictionary
    return counts


def main(filename):
    # read the file
    content = readfile(filename)
    # count how many times each word appears
    counts = count_words(content)
    # print the counts dictionary
    print(counts)


if __name__ == '__main__':
    main(sys.argv[1])
You can run this using the file twinkle.txt:
content_copy
Copy
python count_words.py twinkle.txt
{'twinkle': 4, 'little': 2, 'star': 2, 'how': 2, 'i': 2, 'wonder': 2,
 'what': 2, 'you': 2, 'are': 2, 'up': 1, 'above': 1, 'the': 2, 'world': 1,
 'so': 1, 'high': 1, 'like': 1, 'a': 1, 'diamond': 1, 'in': 1, 'sky': 1}

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
Guide
Getting Started
What is the course about?
Discord
File system
Configure Powershell for Windows
Installing Python
Creating a conda environment
Installing PyCharm
Creating a PyCharm project
Setting a conda environment
Opening a PyCharm project
Downloading a zip file
Running a Python program
Disabling AI tools
Quality code
Unit 1
Introduction to Bit
Practice with Bit
Functions
Practice with functions
While loops
Practice with while loops
Practice -- Fix the bridge
Practice -- Blue ocean
Unit 2
If statements
Practice with if
Return
Combining conditions
Practice with conditions
Practice with event streams
Decomposition
Variables
Practice with variables
Unit 3
Interactive programs
Using a debugger
Using pytest
Upgrading a package
Types and operators
Input loops
Lists
Practice with lists
Operators
List Patterns
Tuples
None
Practice with tuples
Float
Lists of tuples
Unit 4
Strings
Substrings
Practice with strings
Using the terminal
Windows terminal setup
Program arguments
Best practices for program arguments
Reading and writing files
Split and join
Random
Coiteration with zip
Unit 5
Dictionaries
Building dictionaries
Counting
Grouping
Unit 6
List indexing
Range
Functions that mutate
Grids
Extras
Modules and __name__
To start this guide, download this zip file.
Grouping
One of the things you can do with a dictionary is group related items together. For example, you could take a list of words and group all of the words that start with the same first letter:
We are going to show you a pattern for grouping lists of things into a dictionary.
A dictionary that holds lists
If we wanted to manually put these words into a dictionary, we could do the following:
content_copy
Copy
groups = {}
groups['a'] = ['apple', 'avocado']
This maps the letter a to the list ['apple', 'avocado'].
If we wanted to put words into the dictionary one at a time, we could do this:
content_copy
Copy
groups['b'] = []
groups['b'].append('banana')
This maps the letter b to the list [] and then appends banana to this list. So in the end we have b mapped to ['banana'].
Grouping words one by one
You usually will not know in advance what words you want to group, so you will need to group them one by one. Here is a function that groups words based on their first letter:
content_copy
Copy
def group_by_first_letter(words):
    # create an empty dictionary to map letters to lists of words
    groups = {}
    for word in words:
        # define the key, which in this case is the first letter of the word
        key = word[0]

        # initialize the key to an empty list if it is not in the dictionary
        if key not in groups:
            groups[key] = []

        # add this word to the list of words
        groups[key].append(word)

    # return the dictionary
    return groups
Here is the pattern this follows:
create an empty dictionary
for each word
define the key (e.g. the first letter in the word)
initialize the dictionary for this key if needed, using an empty list
add the word to the list of words for this key
You can see this in action in the file group_by_first_letter.py:
content_copy
Copy
def group_by_first_letter(words):
    """
    Group a list of words by their first letter.

    words -> a list of strings

    returns a dictionary that maps a letter to a list of words
    """
    # create an empty dictionary to map letters to lists of words
    groups = {}
    for word in words:
        # define the key, which in this case is the first letter of the word
        key = word[0]

        # initialize the key to an empty list if it is not in the dictionary
        if key not in groups:
            groups[key] = []

        # add this word to the list of words
        groups[key].append(word)

    # return the dictionary
    return groups


def get_words():
    """
    Get a list of words from input
    """
    words = []
    while True:
        word = input("Word: ")
        if word == "":
            break
        words.append(word)

    return words


def main():
    words = get_words()
    print(words)
    groups = group_by_first_letter(words)
    print(groups)


if __name__ == '__main__':
    main()
This code gets a list of words from input(), prints the list of words, groups the words by first letter, then prints the groups. If you run it, you should see something like this:
content_copy
Copy
Word: horse
Word: goat
Word: hamster
Word: guinea pig
Word: cow
Word:
['horse', 'goat', 'hamster', 'guinea pig', 'cow']
{'h': ['horse', 'hamster'], 'g': ['goat', 'guinea pig'], 'c': ['cow']}
Grouping is a lot like counting
Grouping is really similar to counting! If we were counting words starting with the same letter, we would initialize the count to zero and then add one for each word. For grouping words starting with the same letter, we initialize the list to an empty list and then append each word to the list.
You can see this in action in the file count_by_first_letter.py. It has nearly the same code, with small changes to make it count instead of group. If you run the code, you get something like this:
content_copy
Copy
Word: horse
Word: goat
Word: hamster
Word: guinea pig
Word: cow
Word:
['horse', 'goat', 'hamster', 'guinea pig', 'cow']
{'h': 2, 'g': 2, 'c': 1}
Grouping words by length
Can you modify group_by_first_letter.py to instead group by length? How would you do this?
Here is a solution, which is in group_by_length.py:
content_copy
Copy
def group_by_length(words):
    """
    Group a list of words by their length.

    words -> a list of strings

    returns a dictionary that maps a letter to a list of words
    """
    groups = {}
    for word in words:
        # key is the length of the word
        key = len(word)

        if key not in groups:
            groups[key] = []

        groups[key].append(word)

    return groups


def get_words():
    """
    Get a list of words from input
    """
    words = []
    while True:
        word = input("Word: ")
        if word == "":
            break
        words.append(word)

    return words


def main():
    words = get_words()
    print(words)
    groups = group_by_length(words)
    print(groups)


if __name__ == '__main__':
    main()
Other than the name of the function and its documentation, the only thing that changes in group_by_length() is the key:
content_copy
Copy
key = len(word)
The important part of grouping is picking the right key. Choose wisely.
If you run this program, you should see something like this:
content_copy
Copy
Word: amazing
Word: totally
Word: fantastic
Word: just
Word: coolcool!
Word:
['amazing', 'totally', 'fantastic', 'just', 'coolcool!']
{7: ['amazing', 'totally'], 9: ['fantastic', 'coolcool!'], 4: ['just']}
Using a tuple as a key
It is possible to use tuples as keys! For example, maybe you want to keep track of which classes are offered, based on combinations of day and time:
content_copy
Copy
data = {
    ('Monday', '1pm'): 'CS 110',
    ('Tuesday', '2pm'): 'CS 235',
    ('Wednesday', '1pm'): 'CS 110',
    ('Thursday', '2pm'): 'CS 235',
    ('Friday', '1pm'): 'CS 110'
}
For example, the key ('Monday', '1pm') maps to 'CS 110'.
First and last
This problem is a good example of using a tuple as as key. Can you modify group_by_first_letter.py so that it groups words by both their first and last letter?
Hint: To get the last letter of a word, you can use:
content_copy
Copy
last_letter = word[-1]
Here is a solution, which is in group_by_first_and_last.py:
content_copy
Copy
def group_by_first_and_last_letter(words):
    """
    Group a list of words by their first and last letters.

    words -> a list of strings

    returns a dictionary that maps a letter to a list of words
    """
    # create an empty dictionary to map letters to lists of words
    groups = {}
    for word in words:
        # the key is the first and last letter of the word
        key = (word[0], word[-1])

        # initialize the key to an empty list if it is not in the dictionary
        if key not in groups:
            groups[key] = []

        # add this word to the list of words
        groups[key].append(word)

    # return the dictionary
    return groups


def get_words():
    """
    Get a list of words from input
    """
    words = []
    while True:
        word = input("Word: ")
        if word == "":
            break
        words.append(word)

    return words


def main():
    words = get_words()
    print(words)
    groups = group_by_first_and_last_letter(words)
    print(groups)


if __name__ == '__main__':
    main()
Again, the only line that has changed here is the key, which this time is a tuple:
content_copy
Copy
key = (word[0], word[-1])
If you run this program, you should see something like:
content_copy
Copy
Word: awesome
Word: great
Word: apple
Word: goat
Word: wow
Word: willow
Word:
['awesome', 'great', 'apple', 'goat', 'wow', 'willow']
{('a', 'e'): ['awesome', 'apple'], ('g', 't'): ['great', 'goat'], ('w', 'w'): ['wow', 'willow']}
Group by number of vowels
Here is one last example. Can you change this same code so that it groups by the number of vowels in the word?
Here is a solution, which is in group_by_number_of_vowels.py:
content_copy
Copy
def count_vowels(word):
    total = 0
    for c in word.lower():
        if c in 'aeiou':
            total += 1
    return total


def group_by_number_of_vowels():
    """
    Group a list of words by the number of vowels they contain.

    words -> a list of strings

    returns a dictionary that maps a letter to a list of words
    """
    # create an empty dictionary to map letters to lists of words
    groups = {}
    for word in words:
        # the key is the first and last letter of the word
        key = count_vowels(word)

        # initialize the key to an empty list if it is not in the dictionary
        if key not in groups:
            groups[key] = []

        # add this word to the list of words
        groups[key].append(word)

    # return the dictionary
    return groups


def get_words():
    """
    Get a list of words from input
    """
    words = []
    while True:
        word = input("Word: ")
        if word == "":
            break
        words.append(word)

    return words


def main():
    words = get_words()
    print(words)
    groups = group_by_number_of_vowels(words)
    print(groups)


if __name__ == '__main__':
    main()
Notice that this time we need a function to compute the key. We wrote a function called count_vowels() that takes a word and returns the number of vowels in the word. We can use the return value of this function for the key.
You should see something like this if you run the program:
content_copy
Copy
Word: just
Word: really
Word: smashing
Word: great
Word: job
Word:
['just', 'really', 'smashing', 'great', 'job']
{1: ['just', 'job'], 2: ['really', 'smashing', 'great']}
Closing words
In all of these examples, we got the words to group from input(). You might in some cases get the words from a regular file, or you might get rows of data from a CSV file. If you decompose the problem so that you first get the data and then group it, then you should be able to follow the pattern we have shown here.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
Homework 0 — Getting Started
1. Use the TA Help Queue
To get help from a TA outside of your lab section, you can either go to the CS 110 TA Lab in the Talmage building (room 1119) or meet with a TA virtually (e.g. over Zoom).
In either venue, you will first check in on the TA Help Queue. This ensures that those who have been waiting longer are served first.
CS 110 TA Help Queue
Take a moment, while TAs have office hours, to visit the TA Help Queue and submit a request. Say that you are doing the Homework 0 Help Queue activity. They may open a chat box to demonstrate how that works, but may simply remove you from the queue.
2. Sign on to Discord
We will be using Discord for our class communication. Discord is messaging system that also supports video and audio chatting. You will use Discord to chat with classmates and TAs about assignments and to get help. Instead of sending email, use Discord to message TAs, your lab section leader, or the instructor.
You can find an invitation for our Discord server in Canvas.
Once you have joined, you need a TA to give you access to all the channels on the server. You can find a TA:
In your lab section
In TMCB 1119
Via the TA help queue: CS 110 TA Help Queue
In the discord welcome channel:
type @ta First Last, Lecture: #, Section # and a TA should be with you shortly
The TA will verify that you are part of the class, set your server nickname to your preferred first and last name, and grant you access to the rest of the server.
After you have access, go to the getting-started-activity channel and post your favorite meme.
3. Run a Python program
Download the zip file listed above
Copy the contents into your cs110 project so your files look like this:
Run the program called game.py that is in the game folder. Play it with a friend a few times.
Remember, to run the program, you want to click the green triangle to the left of the main block:
Review these links from the guide if you do not remember how to do these tasks:
Downloading a zip file
Running a Python program
Grading
To finish Homework 0, take the Canvas quiz.

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Introduction To Bit
Practice With Bit
Homework 1a — Introduction to Bit
Preparation
Download the zip file listed above, extract its contents, and put the files into a folder called homework1a, inside of your cs110 folder. Your folder organization should look like this:
Notice that in this folder you have some Python files and then a directory called worlds. This directory contains worlds that Bit can operate in. When you see a line like this in a Python file:
content_copy
Copy
@Bit.worlds('fix-me')
this tells Bit to use the world called fix-me.start.txt inside of the worlds folder. It uses fix-me.finish.txt to check whether you reached the correct finishing world.
Collapse All
1. Fix me
You are given some code in fix_me.py. Bit starts from a blank 5x3 world:
Bit should finish with a world that looks like this:
Run the code in fix-me.py. It will finish with a comparison error. Fix the error so the code runs correctly.
2. Fix me too!
You are given some code in fix_me_too.py. Bit starts from a blank 5x3 world:
Bit should finish with a world that looks like this:
Run the code in fix-me-too.py. It will show an error in the terminal. Fix the error so the code runs correctly.
Note: there are multiple errors in this file
3. Make me smile
You are given some starter code in make-me-smile.py. Bit starts from a 7x6 world with just some eyes:
Bit should finish with a world that has a completed smile:
Write code in make-me-smile.py to complete the smile.
Note: you need the correct finishing position and direction for Bit as well!
4. Picasso
Now it’s your turn! Write a script called picasso.py that draws whatever you want.
Follow the pattern we used in Lab 1a, Exercise 1, which shows how to start from an empty world. Use a world of size 8x8.
You can call your function anything you want, but a good name is picasso :-)
🧑🏼‍🎨
Rules:
you have to move/turn/paint at least 20 times
Grading
Turn your Python files in on Canvas, which will link you to Gradescope.
Activity Points
fix_me.py 5
fix_me_too.py 5
make_me_smile.py 5
picasso.py 5
Manual Grading
We love looking at your picasso submissions!
Make sure you read the style section of the Quality Code guide page.
In future homework assignments, we will grade you based on the other sections of the Quality Code guide page.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Functions
Practice With Functions
Homework 1b — Functions
Collapse All
1. One Tree
You are given some code in one_tree.py. Bit starts in a 5x4 world:
Bit should draw a tree:
In the code we have given you, we have decomposed the problem for you:
content_copy
Copy
from byubit import Bit


def move_to_tree(bit):
    """ Moves to the trunk """
    pass


def draw_trunk(bit):
    """ Draws the trunk (two red squares)  """
    pass


def draw_branches(bit):
    """ Draws the branches """
    pass


def go_back_down(bit):
    """ Moves back down to the ground, below the right-most branch, facing right. """
    pass


@Bit.worlds("one_tree")
def one_tree(bit):
    move_to_tree(bit)
    draw_trunk(bit)
    draw_branches(bit)
    go_back_down(bit)


if __name__ == '__main__':
    one_tree(Bit.new_bit)
We want you to see an example of how each function does one small thing.
You should be able to draw the tree by filling in each of these four functions, without using any glue code.
2. Trees
You are given some code in trees.py. Bit starts in a 13x4 world:
Bit needs to draw three trees, with some space between them:
Copy and paste your one_tree() function and the other helper functions from the previous problem. Be sure to remove the @Bit.worlds("one_tree") decorator from the one_tree() function.
This problem shows you how using functions makes it easy to re-use code. In future units, you can use an import statement to reuse functions, but for the Bit units you will need to copy and paste.
3. Boxes
You are given some code in boxes.py. Bit starts in a 3x10 world:
Bit needs to stack three boxes, each sitting on a pallet:
The boxes are blue and the pallets are red.
This problem is meant to give you practice with decomposition, so you should write some additional functions and then call them from the stack_boxes() function.
4. Quilt
You are given some code in quilt.py. Bit starts in a 13x3 world:
Bit needs to draw a quilt pattern:
This problem is meant to give you practice with decomposition, so you should write some additional functions and then call them from the make_a_quilt() function.
Grading
Turn your Python files in on Canvas, which will link you to Gradescope.
Activity Points
one_tree.py 5
trees.py 5
boxes.py 5
quilt.py 5
Manual Grading
Now that you have learned about functions, we will be grading you on function names and appropriate decomposition.
We recommend breaking problems into the biggest chucks first. For example, the biggest repeated section in trees.py is painting a full tree. You should have a function that paints an entire tree. Then, you can break that function into smaller parts by creating more functions with one clear purpose.
There are multiple ways to do these problems well, but there are a few things that indicate that your code could be better. One is long sections of duplicate code. Duplicate code should be put in a function, and you should call the function multiple times.
The other indicator is very long functions. Even when you don’t have repeated code, breaking a problem into parts can help your code be more readable. one_tree.py is an excellent example of decomposing a problem even when sections of code are not repeated.
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
While Loops
Practice With While Loops
The following link covers essentials of using Bit: Bit Reference
Homework 1c — While
Collapse All
1. Blue square
Run the code in blue_square.py. You will notice that it has an error. Can you fix it? The final world should look like this:
2. Go to the lake
Bit wants to get to the lake. He doesn’t know how to get there. He asks for directions.
Bit: “How do I get to the lake?”
Helpful passerby: “Take a left at the stop sign.”
Write your code in go_to_lake.py. There are two starting worlds; in both worlds, bit starts at the bottom, pointing up towards a red square, with the lake on the left. This one of the starting worlds:
This is how it should look when Bit has arrived at the lake:
3. Red line
Bit needs to leave his room (black squares), finish the red line, and return to his room.
Write your code in red-line.py. This is the starting world:
This is how it should look after Bit finishes their task:
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Remember to break the problem down into functions with one clear purpose.
Go to lake and red line both tell a story. We want you to practice decomposition. For full points, use multiple functions on these two problems.
Intent
The intent of this assignment is for you to correctly use while loops.
Code that calls bit.move() many times is likely incorrect.
While loops that only run once are unnecessary, and we will point them out to you.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10
Grading
Activity Points
blue_square.py 4
go_to_lake.py 8
red_line.py 8

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
If Statements
Practice With If Statements
Practice With Event Streams
Homework 2a — If
Collapse All
1. Invert
Bit needs to turn blue squares white, and turn white squares blue. For example, if Bit starts in this world:
then the final world needs to look like this:
To check if a square is empty, use:
content_copy
Copy
bit.is_on_white()
To erase the color in any square, use:
content_copy
Copy
bit.paint('white')
Use the starter code in invert.py to write your code.
Be sure to check all three worlds! You will also see a world called invert2:
and a world called invert-careful. Note that the red squares are not converted, but white squares are turned to blue:
2. Wander
Bit starts in this world:
Bit follows these rules:
Bit moves until it’s blocked in front
Bit turns left when encountering a green square
Bit turns right when encountering a blue square
Bit paints empty squares red
The final world should look like this:
Use the starter code in wander.py to write your code.
Be sure to check both worlds! You will see a second world called wander2:
3. Fix the pipe
Bit is inside of a pipe and wants to patch the holes. The starting world looks like this:
Bit patches the holes with blue sealant. So when Bit is finished, the world should look like this:
Use the starter code in fix_pipe.py to write your code.
Grading
Activity Points
invert.py 5
wander.py 5
fix_pipe.py 10
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is for you to correctly use if-else statements.
You should not have if and else branches that do the same thing.
We do not expect you to use concepts like or, and, or break.
Do not use while-else. Simply write code after/outside the while loop.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Return
Combining Conditions
Practice With Conditions
Homework 2b — Conditions
Note: You are required to use a function that returns a boolean in at least one of the following problems.
Collapse All
1. Paint and exit
For this problem, Bit wants to paint the room blue and then go to its green car. There is only one starting world:
Bit paints the room blue and then leaves:
The starter code is in paint_and_exit.py.
Advice:
Notice that this problem should be done in two steps. You don’t need to write everything in a single while loop.
Be sure to decompose this problem into multiple functions. You probably want two additional functions (one to paint, one to exit).
Write one function at a time and test it to be sure it works.
For each function, think about the stopping condition and any other conditions the function needs.
Use the event stream pattern. For example, instead of thinking of painting the room as doing four walls, think of how to do this using an event stream. Likewise, don’t think of moving to the car as two steps, but one step with an event stream.
2. Remove Rocks
For this problem, Bit is in a garden and wants to remove rocks:
The rocks are shown in blue.
The green blocks mark the beginning and end of the strawberry patch. Only the rocks inside the patch should be removed.
Do not remove the strawberries, which are the red squares!
After removing the rocks, the world should look like this:
Your solution should also solve the second starting world:
The starter code is in remove_rocks.py.
Advice:
This problem naturally divides into three steps. You don’t need to do everything in a single while loop.
Be sure to decompose this problem into multiple functions. You probably want three additional functions (one for each step).
When removing rocks, use the event stream pattern.
3. Scurry
At least one of your files needs to include a function that returns a boolean. (This is to make sure you learned the material; not because this is the best way to solve the problem). Submissions that do not include a function that returns a boolean will be docked 3 points. For a reminder of how to use return, see the guide on return.
For this problem, Bit is running around in a world like this:
Bit follows these rules:
Bit moves until the front, left, and right are all blocked.
Bit prefers to move straight.
If the front is blocked, Bit turns in the direction that is open.
As Bit moves, it paints empty squares green and green squares blue.
If Bit follows these rules for the world above, the ending world will look like this:
There is a second world that looks like this:
The second ending world looks like this:
The starter code is in scurry.py.
Advice:
Be sure to decompose this problem into multiple functions. You probably need at least one additional function.
Be sure you have the right stopping condition.
Think carefully about the additional conditions you need.
Grading
Activity Points
paint_and_exit.py 6
remove_rocks.py 6
scurry.py 8
==At least one of your files needs to include a function that returns a boolean.== (This is to make sure you learned the material; not because this is the best way to solve the problem). Submissions that do not include a function that returns a boolean will be docked 3 points.
The returned value must be used as the condition for a while loop or if statement. For more information see the guide.
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you correctly use conditions with if statements and while loops, and that you decompose complicated problems.
As a standard of decomposition, we expect that your while loops are not nested within the same function.
This is an example of a nested while loop:
content_copy
Copy
while not bit.is_on_green():
    if bit.can_move_right():
        while bit.can_move_front():
            bit.move()
“Nested” means that one while loop is inside of another while loop. Deeply nested code is hard to read.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Decomposition
Homework 2c — Decomposition
Collapse All
1. Barcodes
For this problem, Bit wants to finish the barcodes. There are two starting worlds:
The finishing worlds should look like this:
The starter code is in barcodes.py.
2. Soccer fields
For this problem, Bit wants to plant grass in the soccer fields. There are two starting worlds:
Bit’s job is to put green inside each soccer field:
The starter code is in soccer_fields.py.
3. Bit-a-thon
Bit is participating in a triathlon! Help Bit climb down a mountain, swim across the river, and then cycle to the finish line. There are two race courses:
Bit should finish the course, tracing the running path in green and the cycling path in red:
The starter code is in bitathon.py.
Grading
Activity Points
barcodes.py 4
soccer_fields.py 8
bitathon.py 8
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is for you to decompose complicated problems well. Quality code uses functions to break a problem into pieces. Each function should have a descriptive name that indicates what it does. The quality code guide contains our standards for decomposition.
Not only will decomposition improve the quality of your code, it will make these problems much easier. Break the problem into the largest repeated sections first, like painting one soccer field. Then break that problem into its largest sections, like dropping down, painting one column, and climbing up.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Variables
Practice With Variables
New Colors
Bit can now paint some new colors! There are too many to keep track of, so you won’t use them directly. Instead, you’ll do something like the following:
content_copy
Copy
color = bit.get_color()
paint_column(bit, color)
Homework 2d — Variables
Collapse All
1. Color bars
For this problem, Bit wants to make bars of color. For this starting world:
the ending world should look like this:
There is a second world:
that Bit should turn into this:
The starter code is in color_bars.py.
2. Wells and vines
For this problem, Bit wants to grow vines and fill wells. However, Bit doesn’t know what color the wells or vines should be until reaching a colored square. Bit lives in this world:
Bit’s job is to grow each vine and fill each well:
There is a second world that looks like this:
When bit is done, the world will look like this:
The starter code is in wells_and_vines_.py.
3. More lines
Bit starts in a world with some incomplete lines in each row:
Bit should fill all of the lines in each row:
There is a second world:
That Bit should turn into this:
The starter code is in more_lines.py.
Grading
Activity Points
color_bars.py 4
wells_and_vines.py 8
more_lines.py 8
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is for you to start to use variables, and that you write code that solves worlds of any size.
When a function has an additional argument (like color), it should use that argument somewhere within the function.
Make sure to follow the maximum indentation rule.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Interactive Programs
Using A Debugger
Using Pytest
Homework 3a — Interactive Programs
For all interactive programs, be sure to include a space at the end of the string you give to input().
For example:
content_copy
Copy
name = input('What is your name? ')
Notice the space between the question mark and the quotation mark.
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading Policy:
Starting in Unit 3, the autograder will give partial credit. Even if your output doesn’t exactly match the correct output, you can still get most of the points.
Collapse All
1. Pizza time
For this problem, write a program that takes a pizza order. The program input and output should look like this:
content_copy
Copy
Welcome to Papa John's!
What is your name? <person enters name>
What kind of pizza do you want? <person enters kind of pizza>
What toppings do you want? <person enters toppings>
<name> wants a <kind> pizza with <toppings>!
The starter code is in pizza_time.py.
There are tests in test_pizza_time.py.
2. Mad libs (short)
Write a mad libs that has input and output like this:
content_copy
Copy
Welcome to Mad Libs!
Please enter the following words:
Noun: <person enters a noun>
Adjective: <person enters an adjective>
Noun: <person enters a noun
Character: <person enters a character>
Animal (Plural): <person enters an animal>
<noun1> sat on a <noun2>. <noun1> had a <adjective> fall. 
All <character>'s <animal> and all the <character>'s men couldn't put <noun1> together again.
The starter code is in mad_libs_short.py.
There is a test in test_mad_libs.py — use the short test.
3. Mad libs (long)
Write a mad libs that has input and output like this:
content_copy
Copy
Welcome to Mad Libs!
Please enter the following words:
Noun: <person enters noun>
Adjective: <person enters adjective>
Adjective: <person enters adjective>
Noun: <person enters noun>
Number: <person enters number>
Adjective: <person enters adjective>
Past-Tense Verb: <person enters verb>
Game: <person enters game>
Verb: <person enters verb>
Once upon a time a student at found themselves in a <noun1> class. 
The teacher was so <adjective> that the student started to daydream about a <noun2>. 
Then the student woke up and realized that they were still in class. 
The teacher was so <adjective2> that they gave the student a <number> on the assignment. 
The student was so <adjective3> that he <past_tense_verb> the class and went home to play <game>. 
The moral of the story is that you should never <verb2> in class.
The starter code is in mad_libs.py.
There is a test in test_mad_libs.py.
4. Write your own
Write your own interactive program in the file called write_your_own.py. Your program should:
Use input() exactly three times (EOF or EOFError means you called input() too many times)
Use print() at least three times
Use formatted strings
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Pizza Time 5
Mad Libs (short) 5
Mad Libs (long) 5
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Decomposition
At a minimum, you should have a function to get a noun in both mad libs files. You should have a function to get adjectives in the longer mad libs file.
Intent
The intent of this assignment is for you to use input() correctly and practice printing.
5 points will be removed if “write your own” does not use input() ==3 times== or does not use print() at least ==3 times==. This refers to the number of times the function is called, not the number of lines printed.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Types And Operators
Input Loops
Homework 3b — Input loops
For all interactive programs, be sure to include a space at the end of the string you give to input().
For example:
content_copy
Copy
name = input('What is your name? ')
Notice the space between the question mark and the quotation mark.
Grading Policy:
It’s best to try to pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
However, while pytest checks for exact matches, the autograder gives partial credit for any partially correct solution. Even if your output doesn’t exactly match the correct output, you can still get most of the points.
Assistance with Errors:
You may find the resource on Python errors useful as you complete homework assignments in Unit 3.
Collapse All
1. Words
Write a program in words.py that asks a person to guess a word. The program continually prompts the person to enter a guess until they get it right. When the person enters a guess, the program checks whether it is alphabetically less than, equal to, or greater than the correct word. It has these potential responses:
Lower!
Higher!
You got it!
The file words.py takes a users input and stores it as secret_word. It passes secret_word as an argument to the play() function. For a review on how arguments work, see the guide.
content_copy
Copy
def play(secret_word):
    pass


if __name__ == '__main__':
    secret_word = input('Enter a secret word: ')
    play(secret_word)
Here is a sample session of someone guessing a word:
content_copy
Copy
Enter a secret word: python
Guess a word: slate
Lower!
Guess a word: crane
Higher!
Guess a word: pickles
Higher!
Guess a word: quiz
Lower!
Guess a word: poodle
Higher!
Guess a word: python
You got it!
2. Calculator
Write a program in calculator.py that provides a basic calculator. The program provides the following menu:
content_copy
Copy
<empty line>
What would you like to do?
 1) Add
 2) Subtract
 3) Quit
Option:
Always print a blank line at the start of the menu.
Also note the space before each number.
If a person enters 1, then prompt for two numbers:
content_copy
Copy
Number 1: 5
Number 2: 6
and print out the result of adding them.
If a person enters 2, then prompt for two numbers:
content_copy
Copy
Number 1: 6
Number 2: 17
and print out the result of subtracting them.
If a person enters 3, then quit the program.
If a person enters something other than these three numbers, print:
content_copy
Copy
Unrecognized response: [response]
The file calculator.py has some starting code:
content_copy
Copy
def calculator():
    pass


if __name__ == '__main__':
    calculator()
Here is a sample session of someone interacting with the calculator:
content_copy
Copy
What would you like to do?
 1) Add
 2) Subtract
 3) Quit
Option: 2
Number 1: 16
Number 2: 7
9

What would you like to do?
 1) Add
 2) Subtract
 3) Quit
Option: 1
Number 1: 91
Number 2: 22
113

What would you like to do?
 1) Add
 2) Subtract
 3) Quit
Option: help
Unrecognized response: help

What would you like to do?
 1) Add
 2) Subtract
 3) Quit
Option: 3
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Words 10
Calculator 10
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you use input loops correctly.
In words.py, we provide code for getting the secret word. You  don’t need to change the parameter of the main function or anything below if __name__ == "__main__":.
Calculator should be decomposed into functions.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Lists
Practice With Lists
Homework 3c — Lists
Collapse All
1. Alphabetical Split
This program will print out words that are “smaller” and “bigger” than a boundary word, using alphabetical order. Write a program that:
Gets a list of words, ending with a blank line.
Gets a boundary word.
Prints the total number of words.
Prints the words that come alphabetically before the boundary word.
Prints the words that come alphabetically after the boundary word.
Here is some sample input and output from the program:
content_copy
Copy
Word: fantastic
Word: zip
Word: sad
Word: mark
Word: wood
Word: beautiful
Word: amazing
Word: greatness
Word:
Boundary: honors
You have 8 words
These are small:
fantastic
beautiful
amazing
greatness
These are big:
zip
sad
mark
wood
You can find starter code in words.py.
2. Custom bullets
Write a program that prints a list with a variety of custom bullets. The program should:
Get a list of words, ending with a blank line.
Get a list of bullets, ending with a blank line.
Print the list multiple times, once with each type of bullet.
Here is some sample input and output for the program:
content_copy
Copy
Item: Soul
Item: Incredibles
Item: Brave
Item: Wall-e
Item: Finding Nemo
Item: A Bug's Life
Item:

Custom Bullet Point: *
Custom Bullet Point: o
Custom Bullet Point: -
Custom Bullet Point:

* Soul
* Incredibles
* Brave
* Wall-e
* Finding Nemo
* A Bug's Life

o Soul
o Incredibles
o Brave
o Wall-e
o Finding Nemo
o A Bug's Life

- Soul
- Incredibles
- Brave
- Wall-e
- Finding Nemo
- A Bug's Life
Hint: print(), with no arguments, will print an empty line.
You can find starter code in custom_bullets.py.
3. Compare lists
Write a program that compares how many fruits you eat with how many vegetables you eat. The program should:
Get a list of fruits, ending with a blank line.
Get a list of vegetables, ending with a blank line.
If the list of fruits is longer:
Prints the list of fruits
Prints the list of vegetables
Prints “You need more vegetables!”
If the list of vegetables is longer:
Prints the list of vegetables
Prints the list of fruits
Prints “You need more fruit!”
If the lists are the same length:
Prints the list of fruits
Prints the list of vegetables
What a healthy balanced diet! (the lists are equal lengths)
To get full credit, you must write and use a generic function (see Lab 3c - Shopping List for an example) to query the user for both lists.
Here is some sample input and output for the program:
content_copy
Copy
Enter a Fruit: apple
Enter a Fruit:
Enter a Vegetable: carrot
Enter a Vegetable: squash
Enter a Vegetable:
Vegetables:
 - carrot
 - squash
Fruits:
 - apple
You need more fruit!
You can find starter code in compare_lists.py.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Alphabetical split 6
Custom bullets 7
Compare lists 7
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is for you to use generic functions to create and print lists.
Your functions should be similar to what is shown in lab3b.
See the lab solutions if needed.
Generic functions will be expected for most assignments after this one. The ability to write generic functions is a major learning outcome of this class.
Decomposition
Rereading the section on decomposition from the quality code guide is a good idea at this point in the course.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Operators
List Patterns
Homework 3d — List Patterns
1. Simplify
You are teaching your nephew to read, and you want a list of words that are short enough for him to pronounce. Write a program that does the following:
A person enters a list of words, ending with a blank line.
A person enters a maximum length.
Filter the list of words so that it only contains words whose length is <= to the maximum length.
Print out the list of words that are short, using ”- ” before each word.
The input and output of the program should look like this:
content_copy
Copy
Enter a word: horse
Enter a word: cat
Enter a word: dog
Enter a word: question
Enter a word: hello
Enter a word: fantastic
Enter a word: great
Enter a word: slow
Enter a word: fast
Enter a word: walking
Enter a word:
Enter a length: 5
There are 7 short words:
- horse
- cat
- dog
- hello
- great
- slow
- fast
There is sample code in simplify.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Start by decomposing the problem into a set of functions that you can call in main():
Function Parameters Description Pattern
1.
2.
3.
4.
5.
6.
The number 6 is not intended to represent the number of functions you must have — you may have fewer! List the pattern you might use for this function (input, input loop, map, filter, select, accumulate), if one of them applies. Once you have your solution designed, implement these functions. If you need help from the TAs, bring this table with you.
2. Counting Grouse
Sage grouse are a ground-dwelling bird found in Utah that are considered a sensitive species, meaning on the path toward extinction.
Write a program that can be used to count the number of grouse observed in a particular area and report some data on the grouse. The program should:
Allow an observer to enter a list of the number of grouse observed in each area, ended by a blank line.
Print some information about the grouse counts, including:
the total number of grouse observed,
the smallest number of grouse observed in an area, and
the largest number of grouse observed in an area.
Allow the observer to enter an estimation factor, since they may not have counted all the grouse (e.g. 2, or 3 to represent there may have been 2 or 3 times as many grouse in reality).
Multiply all the counts by the estimate factor.
Print out the estimated grouse populations using the corrected counts.
The input and output of the code should look like this:
content_copy
Copy
Enter an observation count: 50
Enter an observation count: 75
Enter an observation count: 100
Enter an observation count: 25
Enter an observation count: 0
Enter an observation count: 30
Enter an observation count:
There are 280 total grouse.
The smallest count is: 0
The largest count is: 100
Enter factor: 2
The estimated grouse populations are:
- 100
- 150
- 200
- 50
- 0
- 60
You can find starter code in counting_grouse.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Start by decomposing the problem into a set of functions that you can call in main():
Function Parameters Description Pattern
1.
2.
3.
4.
5.
6.
List the pattern you might use for this function (input, input loop, map, filter, select, accumulate), if one of them applies. Once you have your solution designed, implement these functions. If you need help from the TAs, bring this table with you.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Simplify 8
Counting Grouse 12
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you can use the most common list patterns.
Using built-in functions is ok.
Be aware that knowing the list patterns, as shown in class and lab, will be useful when working with lists of tuples and on the midterm.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Tuples
None
Practice With Tuples
Homework 3e — Tuples
1. Student Ratings
Write a program to analyze student ratings of a class. Each rating should contain a score and a comment inputted by the students. Scores should be 1-10, and can be decimals, such as 7.3. Your program should collect all the student ratings from input as a list of tuples, then print the average rating (rounded to 1 decimal place) and all of the comments in a bulleted list.
Here is an example of the input and output for the program:
content_copy
Copy
Enter ratings for this class.
Each rating includes a score and a comment.
Use a blank score to end.
Score: 9.5
Comment: Great class!
Score: 8.3
Comment: Good, but too much homework.
Score: 9.2
Comment: I like the teacher but don't like the material much.
Score: 7.1
Comment: I couldn't stay awake.
Score: 8.8
Comment: I learned a lot because the TAs were awesome.
Score:
Average rating: 8.6
Comments:
- Great class!
- Good, but too much homework.
- I like the teacher but don't like the material much.
- I couldn't stay awake.
- I learned a lot because the TAs were awesome.
Be sure to print the instructions and input prompts as shown.
There is starter code in student_ratings.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Start by decomposing the problem into a set of functions that you can call in main():
Function Parameters Description
1.
2.
3.
4.
5.
6.
The number 6 is not intended to represent the number of functions you must have — you may have fewer! Once you have your solution designed, implement these functions. If you need help from the TAs, bring this table with you.
2. Personal Library
Write a program to keep track of the books you have read. Each book has a title, author, and number of pages (an integer). Your program should collect all the books you have read, then ask you to enter an author’s name. The program then prints the number of books you have read by that author and the total number of pages you have read by that author.
Here is an example of the input and output for the program:
content_copy
Copy
Enter the title, author, and pages of each book.
End with a blank title.
Title: To Kill a Mockingbird
Author: Harper Lee
Pages: 281
Title: Beloved
Author: Toni Morrison
Pages: 324
Title: Jane Eyre
Author: Charlotte Bronte
Pages: 536
Title: Shirley
Author: Charlotte Bronte
Pages: 572
Title:
Enter an author to report on.
Author: Charlotte Bronte
You have read 2 books by Charlotte Bronte.
You have read 1108 pages by Charlotte Bronte.
Be sure to print the instructions and input prompts as shown.
You can find starter code in personal_library.py:
content_copy
Copy
def main():
    # Write code here
    pass


if __name__ == '__main__':
    main()
Start by decomposing the problem into a set of functions that you can call in main():
Function Parameters Description
1.
2.
3.
4.
5.
6.
Once you have your solution designed, implement these functions. If you need help from the TAs, bring this table with you.
3. Grades
Write a program to collect grades for an assignment. A grade consists of a student and a score (a float). The program should:
collect all the grades
have the grader enter a bonus as a decimal, e.g. 0.10 to mean 10%
have the grader enter a cutoff as decimal, e.g. 90
apply the bonus to every student’s score
print all of the scores over the cutoff
Here is an example of the input and output for the program:
content_copy
Copy
Enter scores for each student.
Enter a blank student name to end.
Student: Sarah
Score: 90
Student: John
Score: 88
Student: Peter
Score: 85
Student: Lana
Score: 80
Student:
Bonus: 0.1
Cutoff: 90
High Scores:
- 99.0: Sarah
- 96.8: John
- 93.5: Peter
Be sure to print the instructions and input prompts as shown.
To calculate the bonus, you can use this formula:
content_copy
Copy
new_score = score *(1 + bonus)
Round the scores to 1 decimal point after you apply the bonus.
Start by decomposing the problem into a set of functions that you can call in main():
Function Parameters Description
1.
2.
3.
4.
5.
6.
Once you have your solution designed, implement these functions. If you need help from the TAs, bring this table with you.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Student Ratings 5
Personal Library 7
Grades 8
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is for you to create lists of tuples from input, and use the list patterns to work with list of tuples.
It’s ok to use lists of strings or integers if that simplifies the problem, but you shouldn’t use a dictionary (Unit 5).
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Float
Lists Of Tuples
Homework 3f — Structured Data
1. Pokemon
Write a program that queries the user for a sequence of Pokemon.
For each pokemon, the user will provide a name, type, and hit-points (HP) value.
The user provides an empty name to indicate they are done providing pokemon data.
Then the program queries the user for a pokemon type and prints the pokemon that has the maximum HP for that type.
Use the prompts and formatting as demonstrated in the example.
Example
content_copy
Copy
Name: Charmander
Type: Fire
HP: 39
Name: Squirtle
Type: Water
HP: 44
Name: Blastoise
Type: Water
HP: 79
Name: Charizard
Type: Fire
HP: 78
Name: Rattata
Type: Normal
HP: 30
Name: Mudkip
Type: Water
HP: 50
Name: 
Get max HP for type: Water
Blastoise has the highest HP (79) for type Water.
2. Date Ideas
Write a program that helps the user organize date ideas.
Each idea has a description and a cost.
The user provides an empty idea to indicate they are done entering ideas.
Then the program queries the user for a maximum date cost and displays all the dates that are of equal or lesser cost.
Follow the prompts and formatting of the example.
Example
content_copy
Copy
Date idea: Running
Date cost: 0
Date idea: Ice Cream
Date cost: 15
Date idea: Bowling
Date cost: 20
Date idea: Fancy Dinner
Date cost: 70
Date idea: Hiking the Y
Date cost: 0
Date idea: 
Get max cost for date: 20
Here are all the dates below $20:
- Running costs $0.
- Ice Cream costs $15.
- Bowling costs $20.
- Hiking the Y costs $0.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Pokemon 10
Date Ideas 10
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is for you to create lists of tuples from input, and use the list patterns to work with list of tuples.
It’s ok to use lists of strings or integers if that simplifies the problem, but you shouldn’t use a dictionary (Unit 5).
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Strings
Homework 4a — Strings
1. Practice Problems
The following programs are incomplete:
count_whitespace.py
replace_digits.py
remove_punctuation.py
most_punctuation.py
keep_big_phrases.py
Complete each program by implementing the unfinished function. Follow the instructions given in the docstring.
Write additional functions as necessary. We recommend additional functions such as the following:
count_uppercase(string: str) -> int
count_punctuation(string: str) -> int
NOTE: Punctuation is both not whitespace and not alphanumeric.
2. BYU Students
Write a program that asks for a list of students.
Each student has name, hometown, and school.
When a person enters nothing for the name, the list is complete.
Then:
Print out all the names of students from BYU in ALL CAPS.
Print out all the names of students from other schools.
Match the prompts and formatting from the following example:
content_copy
Copy
Enter a student.
Name: Eliza Snow
Hometown: Becket
School: BYU
Enter a student.
Name: George Smith
Hometown: Provo
School: UVU
Enter a student.
Name:
BYU Students:
- ELIZA SNOW
Other Students:
- George Smith
You can find starter code in students.py.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Practice problems 10
BYU Students 10
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is for you to correctly:
use the string functions
build strings using the filter and mapping patterns
use for loops to iterate through lists of strings and characters in a string
Your for loops should show that you know if you are iterating through strings in a list or characters in a string.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Substrings
Practice With Strings
Homework 4b - Substrings
1. Practice Problems
In practice_problems.py you will find the stubs of several functions, along with documentation that explains what each function should do:
for_reals(text) — Replace all ’%’ with ’ percent’ and all ’!’ with ’ (for reals).’ Notice there are spaces in these.
doubles(text) — Replace all “oo” with “oooooo” and all “ee” with “eeeeee”.
upper_vowels(text) — Make all vowels uppercase.
only_o(text) — Replace all vowels (aeiou) with ‘o’, preserving the casing of each letter.
You should implement all of these. There are tests provided.
You may write additional functions in the file as needed.
2. Reverse Wordle
Write a program that:
Prompts the person for a string of characters to block out
Prompts the person for a replacement character
Prompts the person for a sequence of inputs
Replace all blocked characters in the input with the replacement character
Match the prompts and formatting from the example.
Example
content_copy
Copy
Characters to block: blocked
Replacement: *
Word: fish
fish
Word: book
****
Word: CHOOSE
*H**S*
Word:
3. Out of Stock
Write a program that:
Using a sequence of inputs, prompt the person for a list of out-of-stock items
Using a sequence of inputs, prompt the person for the items they would like to purchase
If the item is out-of-stock, inform the person
Otherwise add it to the list of items requested
Print the available items the person indicated they want to purchase
Match the prompts and formatting from the example.
Example
content_copy
Copy
What items are out of stock?
Item: toilet paper
Item: eggs
Item:
What items would you like to purchase?
Item: tuna
Item: eggs
I'm sorry, the item EGGS is out of stock.
Item: spinach
Item:
You have 2 items:
- tuna
- spinach
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Practice problems 6
reverse_wordle.py 6
out_of_stock.py 8
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you can detect and replace substrings, while recognizing when to build strings using the pattern shown in 4a. You should understand how in applies to strings and lists.
Some problems are best solved using replace(), like when looking for a substring bigger than a character. Your code might look something like this:
content_copy
Copy
new_string = string.replace(old_substring, new_substring)
Other problems are best solved using a for loop. Replacing single characters with other single characters is typically done by building the string one character at a time. Your code might look something like this:
content_copy
Copy
new_string = ""
for char in string:
    if condition(char):
        char = change_letter(char)
    new_string += char
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Using The Terminal
Program Arguments
Best Practices For Program Arguments
Homework 4c - Program arguments
If you have a Windows computer use the guide for the Windows terminal setup to configure your system.
Grading
Activity Points
hello.py 2
product.py 2
big_words.py 8
in_there.py 8
Decomposition (No functions are needed for Hello)
-2 points: sys.argv is used outside of if __name__ == "__main__".
-2 points: System arguments are not passed into other functions as arguments. See the best practices guide for an example.
1. Hello!
Write a program named hello.py that takes a name as an argument and prints “Hello {name}!”
Examples
content_copy
Copy
$ python hello.py world
Hello world!
content_copy
Copy
$ python hello.py CS110
Hello CS110!
2. Product
Write a program named product.py that takes four numbers as arguments and prints their product.
Examples
content_copy
Copy
$ python product.py 1 2 3 4
24.0
content_copy
Copy
$ python product.py -1 1 -1 1
1.0
3. Big Words
Write a program named big_words.py that takes a minimum word size as an argument.
The program then prompts the user for 5 words:
If the length of the word is less than the minimum size, print Too short.
Otherwise add the word to the list
After getting 5 words of sufficient size, print the words out.
Follow the prompts and formatting demonstrated in the example.
Example
content_copy
Copy
$ python big_words.py 3
Word: word
Word: cat
Word: at
Too short.
Word: I
Too short.
Word: dog
Word: goat
Word: cow
- word
- cat
- dog
- goat
- cow
4. In there somewhere…
Write a program named in_there.py that takes a short string as an argument.
Then the program prompts the user for a guess:
If the guess matches the secret string, print You got it! and exit the program
If the secret string is a substring of the guess, print It's in there... and continue prompting guesses
Otherwise print Nope. and continue prompting guesses
Follow the prompts and formatting of the example.
Example
content_copy
Copy
$ python in_there.py ar
Guess: dog
Nope.
Guess: cougar
It's in there...
Guess: ug
Nope.
Guess: gar
It's in there...
Guess: ar
You got it!
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you understand how to use system arguments.
See the quality code section on if __name__ == "__main__":.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Reading And Writing Files
Homework 4d — Files
For each of these problems, you will be using the file processing pattern. See the guide on reading and writing files for help. You will be starting with a blank file for each of these problems. The accompanying lab was designed to get you ready for this. Good luck! :-)
1. Add bullets
Write a program named add_bullets.py that takes the following arguments, in this order:
an input file
an output file
a string to use for bullets
The program takes the input file and adds the supplied string, plus a space, before each line.
We have given you an input file called bullets.input.txt that contains:
content_copy
Copy
here are some lines
add some bullets to them
and have a great day!
When you run your add_bullets.py program like this:
content_copy
Copy
python add_bullets.py bullets.input.txt bullets.output.txt "@"
Then the file called bullets.output.txt should contain:
content_copy
Copy
@ here are some lines
@ add some bullets to them
@ and have a great day!
2. Filter NaN
Write a program named filter_nan.py that takes the following arguments, in this order:
an input file
an output file
The input file will have a set of lines, each one containing either an integer, a float, or “NaN”, which means “not a number”. You need to remove any lines that contain “NaN” and write the output file with all the other lines.
We have given you an input file called nan_input.txt that contains:
content_copy
Copy
NaN
42
NaN
NaN
3.0
1.23456789
NaN
When you run your filter_nan.py program like this:
content_copy
Copy
python filter_nan.py nan_input.txt nan_output.txt
then the file nan_output.txt should contain:
content_copy
Copy
42
3.0
1.23456789
3. Ooooo
Write a program named ooooo.py that takes the following arguments, in this order:
an input file
an output file
The input file will have a set of lines. You need to replace all vowels with the letter o, then write the result to the output file.
We have given you an input file called peter_piper.txt that contains:
content_copy
Copy
Peter Piper picked a peck of pickled peppers,
A peck of pickled peppers Peter Piper picked;
If Peter Piper picked a peck of pickled peppers,
Where’s the peck of pickled peppers Peter Piper picked?
When you run your ooooo.py program like this:
content_copy
Copy
python ooooo.py peter_piper.txt peter_ooooo.txt
then the file peter_ooooo.txt should contain:
content_copy
Copy
Potor Popor pockod o pock of pocklod poppors,
o pock of pocklod poppors Potor Popor pockod;
of Potor Popor pockod o pock of pocklod poppors,
Whoro’s tho pock of pocklod poppors Potor Popor pockod?
4. Redaction
Write a program named redaction.py that takes the following arguments, in this order:
an input file
an output file
a string pattern
The input file will have a set of lines. You need to replace all substrings equal to the pattern with ****, then write the result to the output file.
We have given you an input file called peter_piper.txt that contains:
content_copy
Copy
Peter Piper picked a peck of pickled peppers,
A peck of pickled peppers Peter Piper picked;
If Peter Piper picked a peck of pickled peppers,
Where’s the peck of pickled peppers Peter Piper picked?
When you run your redaction.py program like this:
content_copy
Copy
% python redaction.py peter_piper.txt peter_redacted.txt "Peter Piper"
then the file peter_redacted.txt should contain:
content_copy
Copy
**** picked a peck of pickled peppers,
A peck of pickled peppers **** picked;
If **** picked a peck of pickled peppers,
Where’s the peck of pickled peppers **** picked?
This is only fitting, since Peter Piper is a suspect but has not yet been convicted.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Add bullets 5
Filter NaN 5
Ooooo 5
Redaction 5
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
==For the purpose of decomposition in this class, we expect reading lines, processing lines, and writing lines to happen in at least three distinct functions.==
Intent
The intent of this assignment is that you can read and write to files, using list patterns on lists of lines, as well as characters within a line.
Follow the guidelines in the quality code section on if __name__ == "__main__":.
Reading a file using read_lines() will give you a list of strings. Your for loops should show that you know if you are iterating through strings in a list or characters in a string.
You should understand how in applies to strings and lists.
Some problems are best solved using replace(), like when looking for a substring bigger than a character. Your code might look something like this:
content_copy
Copy
new_string = string.replace(old_substring, new_substring)
Other problems are best solved using a for loop. Replacing single characters with other single characters is typically done by building the string one character at a time. Your code might look something like this:
content_copy
Copy
new_string = ""
for char in string:
    if condition(char):
        char = change_letter(char)
    new_string += char
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Split And Join
Homework 4e — Split and join
For some of these problems you will be using the file processing pattern. See the guide on reading and writing files for help.
You will also be using split and join to modify words in a line, using concepts taught in the guide on split and join. The previous lab was designed to get you ready for this.
1. Sum numbers
Write a program named sum_nums.py that takes the following arguments, in this order:
an input file
The input file will have a set of lines, each one containing various integers. The program should sum all of these numbers.
We have given you an input file called sum_nums.input.txt that contains:
content_copy
Copy
10 20 5
1 7 8
230
When you run your program like this:
content_copy
Copy
python sum_nums.py sum_nums.input.txt
then it should print:
content_copy
Copy
The total is 281
2. Replace a word
Write a program named replace_word.py that takes the following arguments, in this order:
an input file
an output file
an old word
a new word
The program takes the input file and replaces each instance of the old word with the new word. This should replace words only, and should not do string replacement. Write the new contents of the file to the output file.
We have given you an input file called replace_word.input.txt that contains:
content_copy
Copy
How much wood would a woodchuck chuck if a woodchuck could chuck wood?
He would chuck (he would) as much as he could, and chuck as much wood
As a woodchuck would if a woodchuck could chuck wood.
When you run your replace_word.py program like this:
content_copy
Copy
python replace_word.py replace_word.input.txt output.txt chuck pluck
Then the file called output.txt should have the same contents as the input file, but the word “chuck” replaced with the word “pluck”.
3. Older customers
Write a program named older_customers.py that takes the following arguments, in this order:
an input file
an output file
an age (integer)
The input file is a CSV file. This means it will have a set of lines, and each line has fields that are separated by a comma ,. The fields are:
Customer ID
Gender (Male/Female)
Age (integer)
Annual Income in Dollars (integer)
Spending Score (from 1 to 100)
Profession
Work Experience (integer)
Family Size (integer)
You need to write the output file so that it only has lines of individuals older than the specified age. Be sure to also keep the first line. You can identify the first line by checking if the first word, after you split the line, is equal to “CustomerID”, or checking to see if “CustomerID” is in the line.
After checking for the first line, you will need to to split each line into different items. To get a specific item, you could either use list indexing or unpack the list like a tuple.
For example:
content_copy
Copy
split_line = line.split(',')
id, gender, age, income, score, profession, exp, family = split_line
or
content_copy
Copy
age = split_line[2]
You can run your program like this:
content_copy
Copy
% python older_customers.py customers_small.csv older.csv 20
This should keep only two customers in the new file:
content_copy
Copy
CustomerID,Gender,Age,Annual Income ($),Spending Score (1-100),Profession,Work Experience,Family Size
2,Male,21,35000,81,Engineer,3,3
4,Female,23,59000,77,Lawyer,0,2
4. Average income
Write a program named average_income.py that takes the following arguments, in this order:
an input file
a profession
The input file is the same CSV file as above. The program should find all of the lines where the person has the same profession as given and then calculate the average income for those people. The average should be rounded to an integer.
You can run your program like this:
content_copy
Copy
% python average_income.py customers_small.csv Engineer
This should keep average the income for just the customers who are Engineers and print:
content_copy
Copy
The average income of Engineer is 60500
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Sum numbers 2
Replace word 4
Older customers 7
Average income 7
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you use split and join to modify text separated by commas or spaces.
Your code should show that you understand:
Split creates a list of strings
Join takes a list of strings and makes one big string
Join puts a delimiter between the strings, not at the ends
Strip removes characters from the ends of strings
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Random
Coiteration With Zip
Homework 4f — Random and coiteration
1. Quote Chooser
Write a program that displays a randomly selected quote from a file.
The name of the quotes file is provided as a commandline argument.
The quotes file has the following format:
Each quote is on a separate line
The quote is separated into parts by | characters
Example line
content_copy
Copy
Life is infinitely stranger than anything which| the mind of man could invent.| - Arthur Conan Doyle
Your program should randomly select a quote from the provided file and then display the quote with each part on a separate line.
For example, if the above quote were selected from the quotes file, it should be displayed this way:
content_copy
Copy
Life is infinitely stranger than anything which
 the mind of man could invent.
 - Arthur Conan Doyle
Testing
There is a provided test_quote_chooser.py file that will grade your program, but it might not be very helpful in debugging your program.
To make sure your program is working correctly, you should run it on your own in the terminal.
Change to the directory containing quote_chooser.py. You can run your program with the provided quotes file like this:
Windows
content_copy
Copy
python quote_chooser.py test_files\quotes.txt
Mac
content_copy
Copy
python quote_chooser.py test_files/quotes.txt
You should run your program several times to see that the quotes are being selected randomly (i.e. it shouldn’t be the same quote every time, and every quote should show up eventually).
2. Compare strings
Write a program named compare_strings.py that prompts the user for two words. Then compare the words character-by-character and print the result.
If the pair of characters match, output a *
If the pair does not match, output a .
The user enters an empty string for word 1 to end the program.
Follow is some example input and output. Follow this same format.
content_copy
Copy
python compare_strings.py
Word 1: when
Word 2: what
**..
Word 1: tacos
Word 2: catch
.*...
Word 1:
Note
You will want to write you own main block.
content_copy
Copy
def main():
 # Write code here


if __name__ == '__main__':
 main()
3. Word guess
Write a program named word_guess.py that takes a file as an argument. This file should contain a sequence of words, one word per line.
The program then randomly chooses a word from this file for the user to guess. The user guesses a word:
if the guess matches the secret word, print “That’s it!”
otherwise, if the guess is a substring of the secret word, print “almost”
otherwise, if any of the letters in the guess can be found in the secret word, print “close”
otherwise print “nope”
The file word_list.txt contains an example file to use for input:
word_list.txt
content_copy
Copy
cat
dog
fish
Following is an example of how you might run the program:
content_copy
Copy
% python word_guess.py word_list.txt
Guess a word: dog
nope
Guess a word: ball
close
Guess a word: at
almost
Guess a word: cat
That's it!
Following is an example of how you might run the program:
content_copy
Copy
% python word_guess.py word_list.txt
Guess a word: fish
nope
Guess a word: cat
nope
Guess a word: done
close
Guess a word: do
almost
Guess a word: dog
That's it!
==Tips==
When reading in lines from a file, each line will end with a newline character \n. You may find it useful to remove this character using strip. For example:
content_copy
Copy
line = line.strip()
This will remove any whitespace from the start and end of line, including the newline character.
For the “close” option, you should define a function that takes two words, and returns True or False.
content_copy
Copy
def any_char_matches(word1: str, word2: str) -> bool:
 # Write code here
If word1 was ‘dog’, and word1 was ‘catastrophe’, you could:
Check if ‘d’ is in catastrophe.
Check if ‘o’ is in catastrophe.
Since it is, return True.
If no letters of ‘dog’ are in ‘catastrophe’, return False
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Quote Chooser 5
Compare Strings 5
Word Guess 10
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you use zip for coiteration of lists and strings, not indexing. You shouldn’t convert strings into lists of characters before zipping them.
As a reminder, nested loops usually indicate a great place to further decompose your code. We often recommend moving the inside for loop to another function as a way to increase the quality of your code.
Remember, joining a list is not the only way to build a string. If you don’t have a delimiter, it makes sense to use += instead of appending to a list.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Dictionaries
Homework 5a — Dictionaries
1. Postal routing
Write a program in postal_routing.py that sorts mail into bins. This program takes two arguments on the command line:
an input file of addresses
an output file
An example of the input file is in addresses.txt:
content_copy
Copy
9927 Giffin Ct, Windermere, FL 34786
221B Baker St., London 5208
350 Fifth Avenue, New York City, NY 10118
62 West Wallaby Street, Wigan, Lancashire 227
17 Cherry Tree Lane, London 5208
You are given a dictionary that maps zip codes to bins:
content_copy
Copy
zip_code_to_delivery_bin = {
        '5208': '16',
        '10118': '4',
        '227': '76',
        '12345': '1',
        '84604': '25',
        '84602': '25',
        '20895': '82'
    }
Your program should go through each address in the input file, one by one, find the zip code, and then map that zip code to its bin. The program should write the bins, one per line to the output file. If no bin is found the program should write “unknown” for that line.
Hint: You can grab the last element of list with name_of_list[-1]. For example:
content_copy
Copy
address = ['9927', 'Giffin', 'Ct,', 'Windermere,', 'FL', '34786']
address[-1] = '34786'
Given the above dictionary, if you run the program:
content_copy
Copy
python postal_routing.py addresses.txt bins.txt
then the file bins.txt should contain:
content_copy
Copy
unknown
16
4
76
16
We have given you starter code in postal_routing.py.
2. Autocorrect
Write a program in auto_correct.py that automatically corrects words. This program takes two arguments on the command line:
an input file of text
an output file
An example of the input file is in "sloppy.txt:
content_copy
Copy
i saw yuo adn the dog at teh park
did you see what thye were doing there
You are given a dictionary that maps incorrect words to correct words:
content_copy
Copy
corrections = {
        'teh': 'the',
        'adn': 'and',
        'thye': 'they',
        'yuo': 'you',
        'i': 'I'
    }
Your program should go through each word in every line of the input file, find any words in the corrections dictionary, and then map those words to their correct word. The program should write the corrected lines to the output file.
It is recommended that you decompose this problem in similar way to the “Doubling a recipe” activity from lab 4e.
Given the above dictionary, if you run the program:
content_copy
Copy
python auto_correct.py sloppy.txt neat.txt
then the file neat.txt should contains:
content_copy
Copy
I saw you and the dog at the park
did you see what they were doing there
We have given you starter code in auto_correct.py.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Postal routing 10
Autocorrect 10
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you know how to access the value for a given key in a dictionary. Make sure you remember this skill for future assignments.
Using a global variable is generally bad practice if the variable could easily be passed as an argument instead. However, in postal routing, the dictionary we provide never changes, and it’s awkward to put it inside a function. On this assignment, we won’t dock points for where you put the dictionary, meaning you can use it as a global variable or include it inside a function.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Building Dictionaries
Homework 5b — Building Dictionaries
1. Scheduling
Write a program in scheduling.py that takes
a file containing names (one name per line)
a file containing time slots (one time per line)
The program assigns each person in the first file to a time slot in the second file.
In actual practice, you might choose to randomly assign the individuals to the time slots, but for the purposes of grading this activity, simply assign each person to the next available time slot, in the order they are listed. So the first name is assigned to the first time slot, the second person to the second time slot, and so forth.
After each person is assigned a time slot, allow the user to enter the names of participants in order to find their assigned time. If the name entered is not assigned, indicate that the person has no assignment.
Follow the formatting and prompts of the example.
Example
students.txt
content_copy
Copy
Juan
Julia
Robert
timeslots.txt
content_copy
Copy
10:00 AM
10:30 AM
11:30 AM
1:00 PM
content_copy
Copy
python scheduling.py students.txt timeslots.txt
Name: Julia
Julia is assigned 10:30 AM
Name: Charles
Charles is not assigned a timeslot
Name: Robert
Robert is assigned 11:30 AM
Name:
Strategy
We recommend approaching this problem with the following steps:
Fill in scheduling.py with basic starter code: import sys, def main..., if __name__..., etc.
Write a function to get a list of lines from a file.
Write a function that strips all the newlines from the ends of a list of lines.
Write a function that takes a list of people and a list of times and returns a dictionary that maps people to times. Use the guide for help.
Write an input loop to look up names.
You can test your program on your own using:
content_copy
Copy
python scheduling.py students.txt timeslots.txt
2. Shopping Carts
Write a program in shopping_total.py that takes
A CSV file containing items and quantities (representing a shopping cart)
A CSV file containing item names and prices
The program then prints out the total price for the given shopping cart (rounded to 2 decimal places).
Follow the format shown in the example.
Example
items.csv
content_copy
Copy
potatoes,5.4
bananas,3.1
pizza,1
prices.csv
content_copy
Copy
strawberries,2.98
watermelon,4.37
plums,1.97
potatoes,0.43
bananas,0.63
pizza,6.96
milk,2.63
content_copy
Copy
python shopping_total.py items.csv prices.csv
The total is $11.24
Strategy
We recommend approaching this problem using the following steps:
Fill in scheduling.py with basic starter code: import sys, def main..., if __name__..., etc.
Write a function that reads a list of lines from a file.
Write a function that turns a list of CSV lines into a dictionary that maps the first token to the second token.
Write a function that takes a dictionary of items-to-quantities and a dictionary of items-to-prices and compute the total. For example, if you want to buy 1.5 bananas, and bananas cost
2.25
,
y
o
u
w
i
l
l
a
d
2.25,youwillad3.75 to the total cost.
Print the rounded total.
You can test your program on your own using:
content_copy
Copy
python shopping_total.py items.csv prices.csv
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Scheduling 10
Shopping Cart 10
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
The intent of this assignment is that you understand how to create dictionaries from other data sources. For coiteration, you should use zip, not indexing.
We advise following the provided decomposition strategy for both assignments. We expect you to recognize which functions are generic and can be used multiple times.
Remember not to use system arguments outside of if __name__ == "__main__":.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Counting
Homework 5c — Counting
1. Voting
Write a program in voting.py that takes
a prompt (a string)
The program should read from input a series of votes and then print out a dictionary that counts which person or thing got the most votes.
For example, you could use this program to vote for your favorite foods:
content_copy
Copy
python voting.py food
food: lasagna
food: pizza
food: chicken parmesan
food: lasagna
food: pizza
food: pizza
food:
{'lasagna': 2, 'pizza': 3, 'chicken parmesan': 1}
Or you could use this program to vote for your favorite CS 110 topic:
content_copy
Copy
python voting.py 'CS 110 topic'
CS 110 topic: Dictionaries
CS 110 topic: Bit
CS 110 topic: Bit
CS 110 topic: Dictionaries
CS 110 topic: Bit
CS 110 topic:
{'Dictionaries': 2, 'Bit': 3}
2. Count letters
Write a program in count_letters.py that takes
a string of characters to count
a file
The program counts how often each character appears in the file.
For example, the file twinkle.txt contains:
content_copy
Copy
Twinkle, twinkle, little star,
how I wonder, what you are!
Up above the world so high,
like a diamond in the sky.
Twinkle, twinkle, little star,
how I wonder what you are!
If you run your program as shown below, you should get the following output:
content_copy
Copy
python count_letters.py altoz twinkle.txt
{'a': 9, 'l': 10, 't': 14, 'o': 10, 'z': 0}
We recommend using the readfile() function to read the entire file as one long string. You can find an example of this in the guide on counting.
3. Counting values
Write a program in value_count.py that takes
a CSV file name
a column (integer)
The program counts how many times each value appears in that column of the CSV file.
For example, the start of the file nba_players.csv contains:
content_copy
Copy
14,Ike,Anigbogu,12,IND,Indiana,East,Central,Indiana Pacers,Pacers
25,Ron,Baker,20,NYK,New York,East,Atlantic,New York Knicks,Knicks
47,Jabari,Bird,2,BOS,Boston,East,Atlantic,Boston Celtics,Celtics
67,MarShon,Brooks,15,MEM,Memphis,West,Southwest,Memphis Grizzlies,Grizzlies
71,Lorenzo,Brown,28,TOR,Toronto,East,Atlantic,Toronto Raptors,Raptors
These columns are:
id
first name
last name
team id
abbreviation
city
conference
division
team name
team nickname
If you run this program and specify column 6 (starting from zero) this counts all of the players in the East and West conferences:
content_copy
Copy
python value_count.py nba_players.csv 6
{'East': 496, 'West': 504}
If you run this program and specify column 9, then it counts all of the players per team:
content_copy
Copy
python value_count.py nba_players.csv 9
{'Pacers': 24, 'Knicks': 16, 'Celtics': 37, 'Grizzlies': 29, 'Raptors': 22, 'Thunder': 25,
'Pistons': 41, 'Clippers': 36, 'Warriors': 45, '76ers': 38, 'Jazz': 34, 'Kings': 34,
'Cavaliers': 35, 'Rockets': 45, 'Trail Blazers': 33, 'Hawks': 41, 'Magic': 39,
'Bucks': 33, 'Suns': 46, 'Timberwolves': 43, 'Mavericks': 41, 'Nuggets': 46,
'Heat': 39, 'Wizards': 44, 'Nets': 26, 'Hornets': 28, 'Spurs': 18, 'Lakers': 29,
'Bulls': 33}
Note, this problem is similar to the Pokemon problem from the lab, except you need to be able to count values from an arbitrary column, since the column you are using is one of the command line arguments.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Voting 5
Count letters 7
Counting values 8
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
You should not use a csv reader for this assignment. They are useful, but so is understanding how to strip and split a line yourself.
Remember that splitting a string into a list of characters is unnecessary. Simply use a for loop to iterate through characters in a string.
We do not expect you to sort the dictionaries. Doing so is unnecessary, will cause you to fail the tests, and is a key indicator that you are using AI to write your code for you.
This is a good point in the class to reread the academic integrity section of the syllabus. AI tools should not be used to complete your assignments.
Remember not to use system arguments outside of if __name__ == "__main__":.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

Computer Science
dark_mode
CS 110 How To Program | Winter 2025
Home
Syllabus
Staff
Getting Help
Guide
Resources
To start this assignment, download this zip file.
The following guide pages cover material needed for this assignment:
Grouping
Homework 5d — Grouping
1. Blue score
Write a program in blue_score.py that reads phrases from input and then groups those phrases by their “blue score”. You can calculate a “blue score” for a phrase by counting how many times it contains one of these words: 'byu', 'cougar', 'cougars', 'blue'. Ignore case and punctuation. For example, here are some phrases and their scores:
Word Blue Score
I saw a blue bird at BYU. 2
The blue cougar was feeling blue. 3
BYU is great. Go cougars! 2
What does the cougar say? 1
Write your program so the output matches what is shown below:
content_copy
Copy
Phrase: I saw a blue bird at BYU.
Phrase: The blue cougar was feeling blue.
Phrase: BYU is great. Go cougars!
Phrase: What does the cougar say?
Phrase:
2:
I saw a blue bird at BYU.
BYU is great. Go cougars!

3:
The blue cougar was feeling blue.

1:
What does the cougar say?
Note that there is an extra blank line after each group of phrases.
Tip
To remove punctuation from a word you can do this:
content_copy
Copy
from string import punctuation

word = word.strip(punctuation)
2. Word groups
Write a program in word_groups.py that takes
a file name
The program should read all of the words in the file and then group them by their length and their first letter, as a tuple (length, letter).
For example, the file some_words.txt contains:
content_copy
Copy
Apple, ash, aspen.
Pears and plums, pretty please?
Where what whom!
If you run the program, it should produce this:
content_copy
Copy
% python word_groups.py words.txt
(5, 'a'): ['apple', 'aspen']
(3, 'a'): ['ash', 'and']
(5, 'p'): ['pears', 'plums']
(6, 'p'): ['pretty', 'please']
(5, 'w'): ['where']
(4, 'w'): ['what', 'whom']
Tips
To get a list of all the words in a file, given the filename, use this function:
content_copy
Copy
def readwords(filename):
    """
    Read a file given by the filename and
    return a list of all of the words. The words
    are separated based on whitespace.
    Note, punctuation remains with the words!
    """
    with open(filename) as file:
        return file.read().split()
To convert a word to lowercase and remove punctuation, recall that we can do this for a word:
content_copy
Copy
from string import punctuation

word = word.lower().strip(punctuation)
3. Group CSV
In this problem, you are going to write code that can group columns from a CSV file. Write your code in group_csv.py. This program takes three arguments:
an input file name
a column to group by (column A)
a column of values (column B)
The program should group all of the values in column B based on the keys in column A. For example, we have given you a CSV file called grades.csv:
content_copy
Copy
Emma,A,A
Harold,B,A-
McKayla,C+,B-
Jose,A-,B+
Jenna,B+,B
Joshua,F,A+
Sarah,B,B
If you run the program with:
content_copy
Copy
python group_csv.py grades.csv 1 0
then the program will group all of the students by their grades on the 1st assignment (i.e. the 2nd column; remember we count columns starting at zero!)
This should print:
content_copy
Copy
A: ['Emma']
B: ['Harold', 'Sarah']
C+: ['McKayla']
A-: ['Jose']
B+: ['Jenna']
F: ['Joshua']
You can also run the program to group the students based on their grades on the 2nd assignment:
content_copy
Copy
python group_csv.py grades.csv 2 0
This should print:
content_copy
Copy
A: ['Emma']
A-: ['Harold']
B-: ['McKayla']
B+: ['Jose']
B: ['Jenna', 'Sarah']
A+: ['Joshua']
This is very similar to a problem from the lab, except we are telling you the column for the key and the column for the value.
Tests
Be sure you can pass the tests before you turn in the assignment. Review the guide on using pytest if you need to review using pytest and what to do if a test fails.
Grading
Activity Points
Blue score 5
Word groups 7
Group CSV 8
Manual Grading
Refer to the Quality Code guide page for detailed explanations and examples on each of these rubric criteria.
Intent
You should not use a csv reader for this assignment. They are useful, but so is understanding how to strip and split a line yourself.
Remember not to use system arguments outside of if __name__ == "__main__":.
Printing a dictionary to look like {"key" : "value" }, in the order that keys were added, is an easy task. Simply use print(name_of_dictionary).
This is a good point in the class to reread the academic integrity section of the syllabus. AI tools should not be used to complete your assignments.
Rubric Points
Whitespace 1
Naming 1
Decomposition 4
Intent 4
Total 10

================================================================================

