Project Report - Network Routing:
  Baseline:
    Design Experience:
      - State your discussion partner
      - Provide a brief summary of your conversation
    Theoretical Analysis - Dijkstra's With Linear PQ:
      Time:
        - Include annotated code in report [Annotated code]
        - Annotate all non-trivial parts of your code [Non-trivial annotated code]
        - Provide explanation of time complexity [Time complexity explanation]
        - State all assumptions regarding the time complexity clearly [State all assumptions]
        - Bold final time complexity [Bold complexity]
      Space:
        - Include annotated code in report [Annotated code]
        - Annotate all non-trivial parts of your code [Non-trivial annotated code]
        - Provide explanation of space complexity [Space Complexity Explanation]
        - State all assumptions regarding the space complexity clearly [State all assumptions]
        - Bold final space complexity [Bold complexity]
    Empirical Data - Dijkstra's With Linear PQ:
      - Fill in empirical runtimes table
    Comparison of Theoretical and Empirical Results - Dijkstra's With Linear PQ:
      - Provide plot comparing theoretical time complexity to observed runtimes
      - If theoretical and empirical results match
        - Simply state this
      - If they do not match
        - Provide a plot showing a theoretical time complexity that more closely follows the observed runtimes
        - Provide a brief discussion explaining what sections of your code might account for the difference
  Core:
    Design Experience:
      - State your discussion partner
      - Provide a brief summary of your conversation
    Theoretical Analysis - Dijkstra's With Heap PQ:
      Time:
        - Include annotated code in report [Annotated code]
        - Annotate all non-trivial parts of your code [Non-trivial annotated code]
        - Provide explanation of time complexity [Time complexity explanation]
        - State all assumptions regarding the time complexity clearly [State all assumptions]
        - Bold final time complexity [Bold complexity]
      Space:
        - Include annotated code in report [Annotated code]
        - Annotate all non-trivial parts of your code [Non-trivial annotated code]
        - Provide explanation of space complexity [Space Complexity Explanation]
        - State all assumptions regarding the space complexity clearly [State all assumptions]
        - Bold final space complexity [Bold complexity]
    Empirical Data - Dijkstra's With Heap PQ:
      - Fill in empirical runtimes table
    Comparison of Theoretical and Empirical Results - Dijkstra's With Heap PQ:
      - Provide plot comparing theoretical time complexity to observed runtimes
      - If theoretical and empirical results match
        - Simply state this
      - If they do not match
        - Provide a plot showing a theoretical time complexity that more closely follows the observed runtimes
        - Provide a brief discussion explaining what sections of your code might account for the difference
    Relative Performance Of Linear versus Heap PQ Performance:
      - Remark on the relative performance between the Dijkstra's with Heap PQ v Linear PQ. Which is faster? Why might this be?
  Stretch 1:
    Design Experience:
      - State your discussion partner
      - Provide a brief summary of your conversation
    Empirical Data:
      - Fill in empirical runtimes table
    Plot:
      - Create a plot showing Density versus Runtime versus PQ
    Discussion:
      - Compare empirical versus theoretical for density versus runtime versus PQ; Do your plots match the expected result?; How does density affect runtime for heap PQ versus linear PQ implementations?
  Stretch 2:
    Design Experience:
      - State your discussion partner
      - Provide a brief summary of your conversation
    Provided Graph Generation Algorithm Explanation:
      - Explain how the provided graph generation algorithm in main.py works and how each of the parameters influence the result
      - Discuss how the density, noise, and distribution parameters are implemented
      - Discuss which real world applications it would work well in and which ones it would not
    Selected Graph Generation Algorithm Explanation:
      - Implement and discuss your own graph generation algorithm in stretch2_graph_generation.py
      - You are encouraged to research and use an existing graph-generation algorithm you think is interesting
      - Discuss why you chose your selected algorithm and how you implemented it
      - Describe which real-world scenarios are better modeled by your selected algorithm than the provided algorithm
    Screenshots of Working Graph Generation Algorithm:
      - Run your shortest path algorithm on a small, a medium, and a large graph generated by your algorithm
      - Take a screenshot showing the graphs you generated and the shortest path your algorithm found and include these screenshots in your report
  Project Review:
    - Compared code and results with a classmate
