Rules:
  Annotated code: |
    
    The is an example of an annotation: 
    
    <correct>
    
    for i in range(): # this is an example of an annotation
      print("10")
    
    </correct>
    
    
    This code is not annotated:   
    
    <incorrect>
    for i in range():
      print("10")
    </incorrect>
    
    

  Non-trivial annotated code: |
      Annotated code should include comments showing the time or space complexity 
      for lines significantly contributing to the overall complexity.
      
      Not every line needs to be annotated. 
      
      Here is an example of annotating non-trivial code for time complexity:  
      
      ```py
      def fib_iterative(n):
          """Calculates the fibonacci sequence using iteration"""
          if n < 2:                                           
              return n                                        
      
          seq = [0, 1]                                        
          for i in range(1, n):                               # O(n) - The overall loop is O(n) - the for loop loops n times 
              seq.append(seq[i] + seq[i - 1])                 # O(1) - The python append function is constant time, and addition is also constant time
          return seq[-1]                                      
      ```

  Time complexity explanation: |
    
    For a time complexity explanation to be correct, it needs to include an explanation. 

    Including the time complexity without an explanation should be marked incorrect. 
    
    An example correct response:
      The largest operation is the for loop. 
      The loop loops n times with a constant time complexity for each loop leading to an overall time complexity of **O(n)**.
    
    An example incorrect response:
      **O(n)**.

    An example correct response:
      There are no loops and the largest time complexity operation is assigning variables. Thus overeall time complexity is **O(1)**.
    
    An example incorrect response:
      **O(1)**.



  State all assumptions: |
      When explaining the complexity, the responses should the assumptions. 
      State any assumptions. Assumptions may include:
    
      - the time/space complexity of built-in functions in Python (e.g. sort)
      - including/excluding space complexity of parameters
      - which parameters vary in size and affect algorithm performance (e.g. size of variable-length numbers vs size of graph, etc.)
  
      <correct-example>
    
        ```py
        def fib_iterative(n):                           
            """Calculates the fibonacci sequence using iteration"""
            if n < 2:                                        
                return n                                     
        
            seq = [0, 1]                                    
            for i in range(1, n):                           # O(1) - Range has constant space complexity, see note below
                seq.append(seq[i] + seq[i - 1])             # O(n) - seq grows to the size of n
            return seq[-1]          
        ```
        
        For analyzing space complexity of this function, we will look at the data structures and the space complexity of the functions being called.
        
        Within the context of this function, there is only 1 data structure being used -- `seq`. The variable declarations can be assumed to be constant time. The `seq` array will contain `n` items at the end, resulting in an overall space complexity of O(n).
        
        The functions called within this context are `range` and `append`. The [python documentation][1] for range states that only a small amount of memory will be used as it stores only the start, stop, and step values. Thus, range results in O(1) space complexity. The built in `append` function does not use additional space complexity.
        
        The overall space complexity is **O(n)** because the largest space complexity within the function is O(n).
    
      </correct-example>

  Bold complexity: |
    The final bolded complexity can be in markdown: 
    
    <correct-example>
      The final complexity is **O(n)**
    </correct-example>
    
    <incorrect-example>
      The final complexity is O(n)
    </incorrect-example>

  Space Complexity Explanation: |
    
    This example is correct because it explains what the space complexity is. 
    
      <correct>
    
        For analyzing space complexity of this function, we will look at the data structures and the space complexity of the functions being called.
        
        Within the context of this function, there is only 1 data structure being used -- `seq`. The variable declarations can be assumed to be constant time. The `seq` array will contain `n` items at the end, resulting in an overall space complexity of O(n).
        
        The functions called within this context are `range` and `append`. The [python documentation][1] for range states that only a small amount of memory will be used as it stores only the start, stop, and step values. Thus, range results in O(1) space complexity. The built in `append` function does not use additional space complexity.
        
        The overall space complexity is **O(n)** because the largest space complexity within the function is O(n).
    
      </correct>
  
      This is missing any explanations and thus it is incorrect.
    
      <incorrect>
        
        The overall space complexity is **O(n)**. 
    
      </incorrect>
    
    
  
  
